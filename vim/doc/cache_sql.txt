*cache_sql.txt*	For Vim version 7.2.  Last change: 2009 Nov 11


                	  VIM REFERENCE MANUAL 
                               adopted by 
                     Andriy Diulin <diulin at gmail dot com>
		          Caché manual pages
			      SQL functions

For instructions on installing this file, type
	:help add-local-help
|add-local-help| inside Vim.

*ABS*  #{{{

A numeric function that returns the absolute value of a numeric expression.
Synopsis

ABS(numeric-expression)
{fn ABS(numeric-expression)}

Arguments

numeric-expression  A number whose absolute value is to be returned.

Description
ABS returns the absolute value, which is always zero or a positive number. ABS
returns the same data type as numeric-expression. If numeric-expression is not
a number (for example, the string 'abc', or the empty string '') ABS returns 0.
ABS returns <null> when passed a NULL value.
Note that ABS can be used as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
This function can also be invoked from Caché ObjectScript using the following
method call:

  WRITE $SYSTEM.SQL.ABS(-0099)
Examples
The following examples show the two forms of ABS:

SELECT DISTINCT ABS(-99) AS AbsoluteValue
FROM Sample.Person

SELECT DISTINCT {fn ABS(-99)} AS AbsoluteValue
FROM Sample.Person
both returns 99.
The following examples show how ABS handles some other numbers. Caché SQL
deletes leading and trailing zeros, and evaluates exponents, before invoking 
ABS.

SELECT DISTINCT ABS(007) AS AbsoluteValue
FROM Sample.Person
returns 7.

SELECT DISTINCT ABS(-0.000) AS AbsoluteValue
FROM Sample.Person
returns 0.

SELECT DISTINCT ABS(-99E4) AS AbsoluteValue
FROM Sample.Person
returns 990000.

SELECT DISTINCT ABS(-99E-4) AS AbsoluteValue
FROM Sample.Person
returns .0099.
See Also

  • SQL functions: CONVERT TO_NUMBER
  • Caché ObjectScript function: $ZABS


 #}}}
*ACOS*  #{{{

A scalar numeric function that returns the arc-cosine, in radians, of a given
cosine.
Synopsis

{fn ACOS(float-expression)}

Arguments

float-expression  An expression of type float or real, whose value is between
                  -1 and 1. This is the cosine of the angle.

Description
ACOS takes a numeric value and returns the inverse (arc) of its cosine as a
floating point number. The value of float-expression must be a signed decimal
number ranging from 1 to -1 (inclusive). A number outside of this range causes
a runtime error, generating an SQLCODE -400 (fatal error occurred). ACOS
returns NULL if passed a NULL value. ACOS treats nonnumeric strings, including
the empty string (''), as the numeric value 0.
ACOS returns a value of data type FLOAT with a precision of 19 and a scale of
18.
ACOS can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following examples show the effect of ACOS on two cosines:

SELECT DISTINCT {fn ACOS(0.52)} AS ArcCosine
FROM Sample.Person
returns 1.023945...

SELECT DISTINCT {fn ACOS(-1)} AS ArcCosine
FROM Sample.Person
returns pi (3.14159...).
See Also

  • SQL functions: ASIN ATAN COS COT SIN TAN
  • Caché ObjectScript function: $ZARCCOS


 #}}}
*%ALPHAUP*  #{{{

Deprecated. A case-transformation function that converts alphabetic characters
to the ALPHAUP collation format.
Synopsis

%ALPHAUP(expression)
%ALPHAUP expression

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

Description
This is a deprecated collation function. Please refer to %SQLUPPER for new
development. %SQLUPPER provides superior handling for non-alphabetic
characters.
%ALPHAUP converts all alphabetic characters to uppercase (i.e., the ALPHAUP
format) and removes all blanks and punctuation characters except commas and
question marks.
%ALPHAUP (unlike %SQLUPPER and %STRING) does not force numerics to be
interpreted as a string. Caché Basic converts a numeric to canonical form
(removing leading and trailing zeros, expanding exponents, etc.) before passing
the numeric to the function. (Caché Basic does not convert numeric strings to
canonical form.) %ALPHAUP then removes the decimal separator character, the
minus sign, and any other punctuation or blanks. For this reason, %ALPHAUP must
be used with caution on any expression containing non-alphabetic information.
%ALPHAUP is a Caché SQL extension and is intended for SQL lookup queries.
You can perform the same collation conversion in Caché ObjectScript using the
$ZUTIL(28) function. This function can also be invoked from Caché ObjectScript
using the following method call:
$SYSTEM.SQL.ALPHAUP(expression)
Alphanumeric Collation Order
The case conversion functions collate data values that begin with a number
using different algorithms, as follows:

%ALPHAUP and %STRING                     %SQLUPPER, %SQLSTRING, and all other
                                         case conversion functions

5988 Clinton Avenue, 6023 Washington     5988 Clinton Avenue, 6 Oak Avenue,
Court, 6090 Elm Court, 6185 Clinton      6023 Washington Court, 6090 Elm Court,
Drive, 6209 Clinton Street, 6284 Oak     6185 Clinton Drive, 6209 Clinton
Drive, 6310 Franklin Street, 6406 Maple  Street, 6284 Oak Drive, 6310 Franklin
Place, 641 First Place, 6572 First       Street, 6406 Maple Place, 641 First
Avenue, 6643 First Street, 665 Ash       Place, 6572 First Avenue, 66 Main
Drive, 66 Main Street, 672 Main Court,   Street, 6643 First Street, 665 Ash
6754 Oak Court, 6986 Madison Blvd, 6     Drive, 672 Main Court, 6754 Oak Court,
Oak Avenue, 7000 Ash Court, 709 Oak      6986 Madison Blvd, 7000 Ash Court, 709
Avenue                                   Oak Avenue

Examples
In the following example, %ALPHAUP is used to convert the Name field to
uppercase, so that the contains operator ([) can test for the letter  Y . This
query returns all names in Sample.Person that contain the letter  Y , either
uppercase or lowercase:

SELECT Name FROM Sample.Person
WHERE %ALPHAUP(Name) [ 'Y'
The following embedded SQL example shows how %ALPHAUP can be used with Unicode
alphabetic characters, in this case Greek letters:

  SET greek=$CHAR(952,945,955,945,963,963,945)
  WRITE !,"lowercase Greek: ",greek
  &sql(SELECT %ALPHAUP(:greek)
       INTO :capgreek
       FROM Sample.Person)
  WRITE !,"uppercase Greek: ",capgreek
The following cautionary examples show how %ALPHAUP may treat as identical
strings that are in fact quite different:

SELECT %ALPHAUP('Max Wells'),%ALPHAUP('Maxwell S.'),
   %ALPHAUP('Release 3.2'),%ALPHAUP('Re: Lease 32'),
   %ALPHAUP('12/2/04'),%ALPHAUP('1/22/04'),
   %ALPHAUP('-36.5 degrees'),%ALPHAUP('365 Degrees')
See Also
%SQLUPPER

 #}}}
*ASCII*  #{{{

A string function that returns the integer ASCII code value of the first
(leftmost) character of a string expression.
Synopsis

ASCII(string-expression)
{fn ASCII(string-expression)}

Arguments

                   A string expression, which can be the name of a column, a
                   string literal, or the result of another scalar function,
string-expression  where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR). A string
                   expression of type CHAR or VARCHAR.

Description
ASCII returns NULL if passed a NULL or an empty string value. The returning of
NULL for empty string is consistent with SQL Server.
Note that ASCII can be invoked as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
Examples
The following queries both returns 90, which is the ASCII value of the
character Z:

SELECT DISTINCT ASCII('Z') AS AsciiCode
FROM Sample.Person

SELECT DISTINCT {fn ASCII('ZEBRA')} AS AsciiCode
FROM Sample.Person
Caché SQL parses numerics before performing ASCII conversion. The following
example returns 55, which is the ASCII value of the number 7:

SELECT DISTINCT ASCII(+007) AS AsciiCode
FROM Sample.Person
This number parsing is not done if the numeric is presented as a string. The
following example returns 43, which is the ASCII value of the plus (+)
character:

SELECT DISTINCT ASCII('+007') AS AsciiCode
FROM Sample.Person
See Also

  • SQL functions: CHAR
  • Caché ObjectScript functions: $ASCII $ZLASCII $ZWASCII


 #}}}
*ASIN*  #{{{

A scalar numeric function that returns the arc-sine, in radians, of the sine of
an angle.
Synopsis

{fn ASIN(float-expression)}

Arguments

float-expression  An expression of type float, whose value is between -1 and 1.
                  This is the sine of the angle.

Description
ASIN returns the inverse (arc) of the sine of an angle as a floating point
number. The value of float-expression must be a signed decimal number ranging
from 1 to -1 (inclusive). A number outside of this range causes a runtime
error, generating an SQLCODE -400 (fatal error occurred). ASIN returns NULL if
passed a NULL value. ASIN treats nonnumeric strings, including the empty string
(''), as the numeric value 0.
ASIN returns a value of data type FLOAT with a precision of 19 and a scale of
18.
ASIN can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following examples show the effect of ASIN on two sines.

SELECT DISTINCT {fn ASIN(0.52)} AS ArcSine
FROM Sample.Person
returns 0.5468509506...

SELECT DISTINCT {fn ASIN(-1.00)} AS ArcSine
FROM Sample.Person
returns -1.5707963267...
See Also

  • SQL functions: ACOS ATAN COS COT SIN TAN
  • Caché ObjectScript function: $ZARCSIN


 #}}}
*ATAN*  #{{{

A scalar numeric function that returns the arc-tangent, in radians, of the
tangent of an angle.
Synopsis

{fn ATAN(float-expression)}

Arguments

float-expression  An expression of type float. This is the tangent of the
                  angle.

Description
ATAN takes any numeric value and returns the inverse (arc) of the tangent of an
angle as a floating point number. ATAN returns NULL if passed a NULL value. 
ATAN treats nonnumeric strings, including the empty string (''), as the numeric
value 0.
ATAN returns a value of data type FLOAT with a precision of 36 and a scale of
18.
ATAN can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example shows the effect of ATAN:

SELECT DISTINCT {fn ATAN(0.52)} AS ArcTangent
FROM Sample.Person
returns 0.47951929199...
See Also

  • SQL functions: ACOS ASIN COS COT SIN TAN
  • Caché ObjectScript function: $ZARCTAN


 #}}}
*AVG*  #{{{

An aggregate function that returns the average of the values of the specified
column.
Synopsis

AVG([ALL | DISTINCT] expression)

Arguments

ALL         Optional  Specifies that AVG return the average of all values for 
            expression. This is the default if no keyword is specified.

DISTINCT    Optional  Specifies that AVG calculate the average on only the
            unique instances of a value. If not specified, the default is ALL.

expression  Any valid expression. Usually the name of a column that contains
            the data values to be averaged.

Description
The AVG aggregate function returns the average of the values of expression.
Commonly, expression is the name of a field, (or an expression containing one
or more field names) in the multiple rows returned by a query.
AVG can be used in a SELECT query or subquery that references either a table or
a view. AVG can appear in a SELECT list or HAVING clause alongside ordinary
field values.
AVG cannot be used in a WHERE clause. AVG cannot be used in the ON clause of a 
JOIN, unless the SELECT is a subquery.
The DISTINCT keyword with AVG performs the aggregate operation on only those
fields having distinct (unique) values. The ALL keyword is optional. The
default is to average all values.
Data Values
AVG returns either NUMERIC data type values or DOUBLE data type values. If 
expression is data type DOUBLE, AVG returns DOUBLE; otherwise, it returns
NUMERIC.
For non-DOUBLE expression values, AVG returns a double-precision floating point
number. The precision of the value returned by AVG is 18. The scale of the
returned value depends upon the precision and scale of expression: the scale of
the value returned by AVG is equal to 18 minus the expression precision, plus
the expression scale (as=ap-ep+es).
For DOUBLE expression values, the scale is 0.
AVG is normally applied to a field or expression that has a numeric value, such
as a number field or a date field. By default, aggregate functions use Logical
(internal) data values, rather than Display values. Because no type checking is
performed, it is possible (though rarely meaningful) to invoke it for
nonnumeric fields; AVG evaluates nonnumeric values, including the empty string
(''), as zero (0).
NULL values in data fields are ignored when deriving an AVG aggregate function
value. If no rows are returned by the query, or the data field value for all
rows returned is NULL, AVG returns NULL.
Changes Made During the Current Transaction
Like all aggregate functions, AVG always returns the current state of the data,
including uncommitted changes, regardless of the current transaction’s
isolation level. For further details, refer to SET TRANSACTION and START
TRANSACTION.
Examples
The following query lists the average salary for all employees in the
Sample.Employee database. Because all rows returned by the query would have
identical values for this average, this query only returns a single row,
consisting of the average salary. For display purposes, this query concatenates
a dollar sign to the value (using the || operator), and uses the AS clause to
label the column:

SELECT '$' || AVG(Salary) AS AverageSalary
     FROM Sample.Employee
The following query lists the name, salary, and average salary for all
employees whose salary is greater than the average salary. The rows are listed
in ascending order by salary. The field value for average salary is the same
for all rows returned by the query:

SELECT Name,Salary,AVG(Salary) AS AverageSalary
FROM Sample.Employee
HAVING Salary>AVG(Salary)
ORDER BY Salary
The following Embedded SQL example compares the AVG values for a NUMERIC and
DOUBLE expression:

  SET pi=$ZPI
  SET dpi=$DOUBLE($ZPI)
  &sql(SELECT Name,AVG(:pi) INTO :n,:av FROM Sample.Person)
  WRITE av," numeric",!
   &sql(SELECT Name,AVG(:dpi) INTO :n,:dav FROM Sample.Person)
  WRITE dav," double",!
See Also

  • COUNT
  • SUM


 #}}}
*CALL*  #{{{

Invokes a stored procedure.
Synopsis

CALL procname(:arg1,:arg2,...)

Arguments

procname  The name of a stored procedure

          Optional  One or more stored procedure arguments, specified in order
arg1      as a comma-separated list. Usually, these are specified as host
          variables with the colon (:) prefix.

Description
A CALL statement invokes a stored procedure.
Caché ObjectScript embedded SQL can either issue a CALL statement, or use the 
DO command to invoke the underlying routine or method.
Caché fully supports CALL syntax as defined by the ODBC 2.x and JDBC 1.0
standards. In JDBC, you can invoked CALL through the CallableStatement class'
methods. In ODBC, there are APIs. The CALL syntax and semantics are exactly the
same for JDBC and ODBC. Further, they are processed in the same way: both
drivers parse the statement text and, if the statement is CALL, they directly
invoke the special methods on the server side, bypassing the SQL engine.
From an ODBC or JDBC Client
If class PERSON has a stored procedure called SP1, then you can call this from
an ODBC or JDBC client (such as Microsoft Query) as follows:

retcode = SQLExecDirect(hstmt, "{?=call PERSON_SP1(?,?)}", SQL_NTS);

Caché conforms to the ODBC standard in its structure for calling stored
procedures. See the relevant documentation for more information on that
standard.
With ODBC only, Caché allows relaxed syntax for calls, so there do not need to
be curly braces around CALL or parentheses around parameters. (Since this is
good programming form, the above example uses them.)
Again, with ODBC only, Caché allows modified syntax for using default
parameters, so that CALL SP is different from CALL SP(). The second form
implies passing of a default parameter  as does CALL SP (,,) or SP(,?,) or
other such syntax. In that sense, the parenthesized form of CALL is different
from non-parenthesized.
From Embedded SQL
You can call a stored procedure by creating an embedded SQL statement, as
follows:

   &sql(CALL MyProc(:a,:b,:c))

A CALL statement in Embedded SQL issues a NEW on the %sqlcontext variable, uses
it as the procedure context variable, and then deletes it. You can return a
value from a CALL statement by using a host variable:

   &sql(:rtnval=CALL MyProc())

You cannot return a result set from a CALL statement in Embedded SQL.
For further details, refer to the Host Variables section of the  Embedded SQL 
chapter of Using Caché SQL.
From Caché ObjectScript
Rather than calling stored procedures directly from embedded SQL, you can
invoke stored procedures through Caché ObjectScript calls to the class methods
that contain them. In this case, you have to manage the parameters, and with
query-based stored procedures, the separate methods have to be called and the
fetch loop managed.
For example, to call a method containing a stored procedure called
UpdateAllAvgScores that has no parameters, the code is:

   NEW phnd
   SET phnd=##class(%SQLProcContext).%New()
   DO ##class(students).UpdateAllAvgScores(phnd)
   IF phnd.SQLCode QUIT phnd.SQLCode
   USE 0
   WRITE !,phnd.RowCount," Rows Affected"

When specifying a procedure’s arguments in the call statement, you must not
specify the %Library.SQLProcContext parameter if the procedure has an
explicitly defined %Library.SQLProcContext parameter. The handling of this
parameter is done automatically.
To call a stored procedure that has been implemented as a query, you must call
all three methods:

   NEW qhnd
   DO ##class(students).GetAvgScoreExecute(.qhnd,x1)
   NEW avgrow,AtEnd
   SET avgrow=$lb("")
   SET AtEnd=0
   DO ##class(students).GetAvgScoreFetch(.qhnd,.avgrow,.AtEnd)
   SET x5=$lg(avgrow,1)
   DO ##class(students).GetAvgScoreClose(qhnd)

If a query-based stored procedure is to be nested within a number of other
stored procedures, it is useful to write a wrapper method to hide all of this.
See Also

  • SQL statements: CREATE PROCEDURE CREATE QUERY CREATE METHOD
  • Caché ObjectScript: DO command
  •  Defining and Using Stored Procedures chapter in Using Caché SQL.


 #}}}
*CASE*  #{{{

Returns one of a specified set of values depending on some condition.
Synopsis

CASE
  WHEN search_condition THEN value_expression
  [ WHEN search_condition THEN value_expression ... ]
  [ ELSE value_expression ]
END

CASE value_expression
  WHEN value_expression THEN value_expression
  [ WHEN value_expression THEN value_expression ... ]
  [ ELSE value_expression ]
END

Arguments

search_condition  An SQL boolean expression.

value_expression  An SQL expression (such as a literal value or field name.)

Description
The CASE expression allows you to make comparison tests on series of values,
returning when it encounters the first match.
The CASE expression comes in two forms: Simple and Searched.
The Simple CASE expression tests a series of value expressions (specified by a 
WHEN clause) to see if they are equal to a given value expression:

SELECT
CASE Field1
  WHEN 1 THEN 'ONE'
  WHEN 2 THEN 'TWO'
  ELSE NULL
END
FROM MyTable

The value associated with the first matching expression is returned as the
value of the CASE expression.
The Searched CASE expression tests a series of search conditions (specified by
a WHEN clause), finds the first condition that evaluates to true, and returns
the value associated with it:

SELECT
CASE
  WHEN Field1 = 1 THEN 'ONE'
  WHEN Field1 = 2 THEN 'TWO'
  ELSE NULL
END
FROM MyTable

With either form of CASE expression, you can use an ELSE clause to specify what
value to return if none of the WHEN clause conditions are true.
Note that NULL is not a data value (it represents the absence of a value). For
this reason, a CASE expression that compares NULL and any data value always
returns false. For example, NULL < 1 and NULL > 1 both return false.
The end of a CASE expression is marked by an END token.
Examples
The following query is an example of a Simple CASE expression, where specified
field values are replaced by supplied values:

SELECT
CASE Age
  WHEN 65 THEN 'Retire this year'
  WHEN 64 THEN 'Retire next year'
  ELSE Age
END, Name
FROM Sample.Person
ORDER BY Name
The following query is another example of a Simple CASE expression. This query
labels rows with certain Home_State values as either  Northern NE or  Southern
NE , and sets all other Home_State values in this column to NULL. It uses the
As clause to label this column as  NewEnglanders , and also displays Names and
the original Home_State values. The resulting rows are ordered first by the
NewEnglanders column (in descending order), and within this alphabetically by
Home_State, and then by Name.

SELECT Name,
CASE Home_State
  WHEN 'VT' THEN 'Northern NE'
  WHEN 'NH' THEN 'Northern NE'
  WHEN 'ME' THEN 'Northern NE'
  WHEN 'MA' THEN 'Southern NE'
  WHEN 'CT' THEN 'Southern NE'
  WHEN 'RI' THEN 'Southern NE'
  ELSE NULL
END As NewEnglanders, Home_State
FROM Sample.Person
ORDER BY NewEnglanders DESC,Home_State,Name
The following query is an example of a Searched CASE expression. It uses
logical operators (greater than (>), logical AND (&), logical OR (!)) to
specify a boolean statement for each WHEN clause. The first WHEN clause that
tests True sets the value expression that follows the THEN keyword. In this
example, the Age and Home_State field values are used to identify three types
of Yankees: Old Yankees, Yankees (residents of the six New England states), and
likely fans of the New York Yankees baseball team:

SELECT Name,
CASE
WHEN Age > 55 & Home_State = 'VT'
   ! Home_State='ME' ! Home_State='NH'
   ! Home_State='MA' ! Home_State='CT'
   ! Home_State='RI'
THEN 'Old Yankee'
WHEN Home_State = 'VT'
   ! Home_State='ME' ! Home_State='NH'
   ! Home_State='MA' ! Home_State='CT'
   ! Home_State='RI'
THEN 'Yankee'
WHEN Home_State='NY' THEN 'Yankees Fan'
   ELSE Home_State
END As Yankees
FROM Sample.Person
See Also

  • SQL functions: DECODE NULLIF COALESCE
  • Caché ObjectScript function: $CASE


 #}}}
*CAST*  #{{{

A function that converts a given expression to a specified data type.
Synopsis

CAST(expr AS CHAR | CHARACTER | VARCHAR | NCHAR | NVARCHAR)
CAST(expr AS CHAR(n) | CHARACTER(n) | VARCHAR(n))
CAST(expr AS CHAR VARYING | CHARACTER VARYING)
CAST(expr AS INT | INTEGER | BIGINT | SMALLINT | TINYINT)
CAST(expr AS DEC | DECIMAL | NUMERIC)
CAST(expr AS DEC(p[,s]) | DECIMAL(p[,s]) | NUMERIC(p[,s])
CAST(expr AS FLOAT | REAL)
CAST(expr AS DOUBLE)
CAST(expr AS MONEY | SMALLMONEY)
CAST(expr AS DATE)
CAST(expr AS TIME)
CAST(expr AS TIMESTAMP | DATETIME | SMALLDATETIME)

Arguments

expr  An SQL expression.

n     An integer, indicating the maximum number of characters to return.

      Optional  p=Precision (maximum number of total digits), expressed as an
p,s   integer. s=Scale (maximum number of decimal digits), expressed as an
      integer. If scale is not specified, it defaults to 15.

Description
The SQL CAST function converts the data type of an expression to another data
type.
You can cast an expression to any of the following types:

  • CHAR or CHARACTER: represent a numeric or a string by its initial
    character. VARCHAR with no n defaults to a length of 30 characters when
    specified to CAST or CONVERT. Otherwise, the VARCHAR data type (with no
    specified size) is mapped to a MAXLEN of 1 character, as shown in the Data
    Types table. NCHAR is equivalent to CHAR; NVARCHAR is equivalent to
    VARCHAR.
  • CHAR(n), CHARACTER(n), or VARCHAR(n): represent a numeric or a string by
    the number of characters specified by n.
  • CHAR VARYING or CHARACTER VARYING: represent a numeric or a string by the
    number of characters in the original value.
  • INT, INTEGER, BIGINT, SMALLINT, and TINYINT: represent a numeric by its
    integer portion. Decimal digits are truncated.
  • DEC, DECIMAL, and NUMERIC: represent a numeric by the number of digits in
    the original value. The p (precision), if specified, is retained as part of
    the defined data type, but does not affect the value returned by CAST. If
    you specify a s (scale) value of an positive integer, the decimal value is
    rounded to the specified number of digits. If you specify s=0, the numeric
    value is rounded to an integer. If you specify s=-1, the numeric value is
    truncated to an integer.
  • FLOAT and REAL: represent a numeric by the number of digits in the original
    value, with a precision of 18 and a scale of 9.
  • DOUBLE represents the IEEE floating point standard. For further details,
    refer to the Caché ObjectScript $DOUBLE function.
  • MONEY and SMALLMONEY are currency numeric data types.
  • DATE: represents a date. Dates can be represented in any of the following
    formats, depending on context: the display date format for your locale (for
    example, mm/dd/yyyy); the ODBC date format (yyyy-mm-dd); or the $HOROLOG
    integer date storage format (nnnnn).
  • TIME: represents a time. Times can be represented in any of the following
    formats, depending on context: the display time format for your locale (for
    example, hh:mm:ss); the ODBC date format (hh:mm:ss); or the $HOROLOG
    integer time storage format (nnnnn).
  • TIMESTAMP, DATETIME, and SMALLDATETIME: represents a date and time stamp
    with the format yyyy-mm-dd hh:mm:ss. This corresponds to the Caché
    ObjectScript $ZTIMESTAMP special variable.

For a list of the data types supported by Caché SQL, see Data Types. For other
data type conversions, refer to the CONVERT function. If a you specify a CAST
with an unsupported data type, Caché issues an SQLCODE -376.
Casting Numerics
A numeric value can be cast to a numeric data type or to a character data type.
When casting a numeric results in a shortened value, the numeric is truncated,
not rounded. For example, casting 98.765 to INT returns 98, to CHAR returns 9,
and to CHAR(4) returns 98.7. Note that casting a negative number to CHAR
returns just the negative sign, and casting a fractional number to CHAR returns
just the decimal point.
A numeric value can consist of the digits 0 through 9, a decimal point, one or
more leading signs (+ or  ), and the exponent sign (the letter E or e) followed
by, at most, one + or  sign. A numeric cannot contain group separator
characters (commas). For further details, see the literals section of  Language
Elements in Using Caché SQL.
Before a cast is performed, Caché SQL resolves a numeric to its canonical form:
Exponentiation is performed. Caché strips leading and trailing zeros, a leading
plus sign, and a trailing decimal point. Multiple signs are resolved before
casting a numeric. However, SQL treats double negative signs as a comment
indicator; encountering double negative signs in a number results in Caché
processing the remainder of that line of code as a comment.
A Caché floating point number can take a DEC, DECIMAL, NUMERIC, or FLOAT data
type. At Caché version 5.2 and subsequent, the DOUBLE data type represents
floating point numbers according to the IEEE floating point standard. The Caché
floating point data types have greater precision than the DOUBLE data type, and
are preferable for most applications. You cannot use CAST to cast a floating
point number to the DOUBLE data type; instead, use the Caché ObjectScript
$DOUBLE function.
When a numeric value is cast to a date or time data type, it displays in SQL as
the NULL value; however, when a numeric cast as a date or time is passed out of
embedded SQL to Caché ObjectScript, it displays as the corresponding $HOROLOG
value.
Casting Character Strings
You can cast a character string to another character data type, returning
either a single character, the first n characters, or the entire character
string.
Before a cast is performed, Caché SQL resolves embedded quote characters
('can''t'=can't) and string concatenation ('can'||'not'=cannot). Leading and
trailing blanks are retained.
When a character string is cast to a numeric type, it always returns the single
digit zero (0).
You can cast a character string to the DATE, TIME, or TIMESTAMP data type. The
following operations result in a valid value:

  • A string of the format 'nnnn-nn-nn' can be cast to DATE. (This string
    format corresponds to ODBC date format.) Value and range checking is
    performed; the input date value must be a valid date within the range of
    years 1841 through 9999. In SQL, this cast displays as the locale's date
    display format. For example, '2004 11 23' might display as '11/23/2004'. In
    embedded SQL, this cast is returned as the corresponding $HOROLOG date
    integer.
  • A string of the format 'nn:nn:nn' or 'nn:nn:nn.nn' can be cast to TIME
    (where nn is a one-digit or two-digit integer within the range of valid
    time values). This string format corresponds to ODBC time format. In SQL,
    this cast displays as the locale's time display format (with leading zeros
    added and fractional seconds truncated); for example, '2:33:25.99' would
    display as '02:33:25'. In embedded SQL, this cast is returned as the
    corresponding $HOROLOG time integer; fractional seconds are not truncated.
  • Normally, a DATE or TIME data type is cast to TIMESTAMP. A character string
    cast to TIMESTAMP displays as specified; no value or range checking is
    performed, leading zeros are not added and fractional seconds are not
    truncated.
  • A string of the format 'nnnnn' can be cast to DATE. (This integer string
    corresponds to $HOROLOG date format.) In SQL this cast displays as a null
    string. In embedded SQL, this cast is returned as the corresponding
    $HOROLOG date integer.
  • A string of the format 'nnnnn' can be cast to TIME. (This integer string
    corresponds to $HOROLOG time format.) In SQL this cast displays as a null
    string. In embedded SQL, this cast is returned as the corresponding
    $HOROLOG time integer.

Input values not described above return a null value.
Casting NULL
NULL can be cast to any data type and returns NULL.
Casting Dates
You can cast a date to a date data type, to a numeric data type, or to a
character data type.
Casting a date to the TIMESTAMP, DATETIME, or SMALLDATETIME data type returns a
timestamp with the format yyyy-mm-dd hh:mm:ss. Since a date does not have a
time portion, the time portion of the resulting timestamp is always 00:00:00.
If the expr value is not a valid date in the locale's date display format, CAST
returns NULL.
Casting a date to a numeric data type returns the $HOROLOG value for the date.
This is an integer value representing the number of days since Dec. 31, 1840.
Casting a date to a character data type returns either the complete date, or as
much of the date as the length of the data type permits. However, the display
format is not the same for all character data types. The CHAR VARYING and
CHARACTER VARYING data types return the complete date in display format. For
example, if a date displays as mm/dd/yyyy, these data types return the date as
a character string with the same format. The other character data types return
the date (or a part thereof) as a character string in ODBC date format. For
example, if a date displays as mm/dd/yyyy, these data types return the date as
a character string with the format.yyyy-mm-dd. Thus for the date 04/24/2004,
the CHAR data type returns '2' (the first character of the year), and a CHAR(8)
returns '2004 04 '.
Examples
The following example uses the CAST function to present an average as an
integer, not a floating point. Note that the CAST truncates the number, rather
than rounding it:

SELECT DISTINCT AVG(Age) AS AvgAge,
   CAST(AVG(Age) AS INTEGER) AS IntAvgAge
      FROM Sample.Person
The following example shows how the CAST function converts pi (a floating point
number) to different numeric data types:

SELECT DISTINCT
   CAST({fn PI()} As INTEGER) As IntegerPi,
   CAST({fn PI()} As SMALLINT) As SmallIntPi,
   CAST({fn PI()} As DECIMAL) As DecimalPi,
   CAST({fn PI()} As NUMERIC) As NumericPi,
   CAST({fn PI()} As FLOAT) As FloatPi,
   CAST({fn PI()} As DOUBLE) As DoublePi
      FROM Sample.Person
Note in the following example that the precision and scale values are parsed,
but do not change the value returned by CAST:

SELECT DISTINCT
   CAST({fn PI()} As DECIMAL) As DecimalPi,
   CAST({fn PI()} As DECIMAL(6,3)) As DecimalPSPi
      FROM Sample.Person
The following example shows how the CAST function converts pi (a floating point
number) to different character data types:

SELECT DISTINCT
   CAST({fn PI()} As CHAR) As CharPi,
   CAST({fn PI()} As CHAR(4)) As CharNPi,
   CAST({fn PI()} As CHAR VARYING) As CharVaryingPi,
   CAST({fn PI()} As VARCHAR(4)) As VarCharNPi
      FROM Sample.Person
The following example shows how the CAST function converts Name (a character
string) to different character data types:

SELECT DISTINCT
   CAST(Name As CHAR) As CharName,
   CAST(Name As CHAR(4)) As CharNName,
   CAST(Name As CHAR VARYING) As CharVaryingName,
   CAST(Name As VARCHAR(4)) As VarCharNName
      FROM Sample.Person
The following example shows what happens when you use the CAST function to
converts Name (a character string) to different numeric data types. In every
case, the value returned is 0 (zero):

SELECT DISTINCT
   CAST(Name As INT) As IntName,
   CAST(Name As SMALLINT) As SmallIntName,
   CAST(Name As DEC) As DecName,
   CAST(Name As NUMERIC) As NumericName,
   CAST(Name As FLOAT) As FloatName
      FROM Sample.Person
The following example casts a date field (DOB) to a numeric data type and
several character data types. Casting a date to a numeric returns the $HOROLOG
integer equivalent. Casting a date to a character data type returns either a
date string in input format (CHAR VARYING or CHARACTER VARYING) or the date
(partial or full) in ODBC date string format:

SELECT DISTINCT DOB,
   CAST(DOB As INT) AS IntDate,
   CAST(DOB As CHAR) AS CharDate,
   CAST(DOB As CHAR(6)) AS CharNDate,
   CAST(DOB As CHAR VARYING) AS CharVaryDate,
   CAST(DOB As VARCHAR(10)) AS VarCharNDate
      FROM Sample.Person
The following example casts character strings to the DATE and TIME data types:

SELECT DISTINCT
   CAST('1936-11-26' As DATE) AS StringToDate,
   CAST('14:33:45.78' AS TIME) AS StringToTime
      FROM Sample.Person
Only a string with the format yyyy-mm-dd can be converted to a date. Note that
fractional seconds are truncated (not rounded) when converting a string to the
TIME data type.
The following example casts a date to the TIMESTAMP data type:

SELECT DISTINCT DOB,
   CAST(DOB As TIMESTAMP) AS DateToTstamp
      FROM Sample.Person
The resulting timestamp is in the format: yyyy-mm-dd hh:mm:ss.
The following example casts a character string to the TIME data type, then
casts the resulting time to the TIMESTAMP data type:

SELECT DISTINCT
   CAST(CAST('14:33:45.78' AS TIME) As TIMESTAMP) AS TimeToTstamp
      FROM Sample.Person
The resulting timestamp is in the format: yyyy-mm-dd hh:mm:ss. The time portion
is supplied by the nested CAST; the date portion is the current system date.
See Also

  • Data type CONVERT
  • TO_CHAR TO_DATE TO_NUMBER


 #}}}
*CEILING*  #{{{

A numeric function that returns the smallest integer greater than or equal to a
given numeric expression.
Synopsis

CEILING(numeric-expression)
{fn CEILING(numeric-expression)}

Arguments

numeric-expression  A number whose ceiling is to be calculated.

Description
CEILING returns the same data type as numeric-expression. When 
numeric-expression is a NULL value, an empty string (''), or any nonnumeric
string, CEILING returns NULL.
Note that CEILING can be invoked as an ODBC scalar function (with the curly
brace syntax) or as an SQL general function.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.CEILING(numeric-expression)
Examples
The following examples show the effect of CEILING:

SELECT DISTINCT CEILING(167.45) AS CeilingNum
FROM Sample.Person
returns 168.

SELECT DISTINCT {fn CEILING(167.00)} AS CeilingNum
FROM Sample.Person
returns 167.

SELECT DISTINCT CEILING(-167.45) AS CeilingNum
FROM Sample.Person
returns -167.

SELECT DISTINCT CEILING(-167.00) AS CeilingNum
FROM Sample.Person
returns -167.
See Also
FLOOR

 #}}}
*CHARACTER_LENGTH*  #{{{

A function that returns the number of characters in an expression.
Synopsis

CHARACTER_LENGTH(expression)

Arguments

            An expression, which can be the name of a column, a string literal,
expression  or the result of another scalar function. The underlying data type
            can be a character type (such as CHAR or VARCHAR), a numeric, or a
            data stream.

Description
CHARACTER_LENGTH returns an integer value representing the number of
characters, not the number of bytes, in the specified expression. The 
expression can be a string, or any other data type such as a numeric or a data
stream. This integer count returned including leading and trailing blanks and
the string-termination character. CHARACTER_LENGTH returns NULL if passed a
NULL value, and 0 if passed an empty string ('') value.
Numbers are parsed before counting the characters; quoted number strings are
not parsed. In the following example, the first CHARACTER_LENGTH returns 1
(because number parsing removes leading and trailing blanks), the second 
CHARACTER_LENGTH returns 7.

SELECT DISTINCT CHARACTER_LENGTH(007.000) AS NumLen,
     CHARACTER_LENGTH('007.000') AS NumStringLen
     FROM Sample.Employee
Note:
The CHARACTER_LENGTH, CHAR_LENGTH, and DATALENGTH functions are identical. All
of them accept a data stream argument. The LENGTH function differs from these
functions by stripping trailing blanks and the string-termination character
before counting characters. LENGTH does not accept a data stream argument.
Examples
The following example returns the number of characters in the state
abbreviation field (Home_State) in the Sample.Employee table. (All U.S. states
have a two-letter postal abbreviation):

SELECT DISTINCT CHARACTER_LENGTH(Home_State) AS StateLength
     FROM Sample.Employee
The following example returns the names of the employees and the number of
characters in each employee name, ordered by ascending number of characters:

SELECT Name,
     CHARACTER_LENGTH(Name) AS NameLength
     FROM Sample.Employee
     ORDER BY NameLength
The following embedded SQL example demonstrates how CHARACTER_LENGTH handles
Unicode characters. CHARACTER_LENGTH counts the number of characters,
regardless of their byte length.

   SET a=$CHAR(960)_"FACE"
   WRITE !,a
   &sql(SELECT CHARACTER_LENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The CHARACTER length is ",b }
returns 5.
See Also

  • SQL functions: CHAR CHAR_LENGTH DATALENGTH LENGTH
  • Caché ObjectScript function: $LENGTH


 #}}}
*CHAR*  #{{{

A string function that returns the character that has the ASCII code value
specified in a string expression.
Synopsis

CHAR(code-value)
{fn CHAR(code-value)}

Arguments

code-value  An integer code that corresponds to a character.

Description
CHAR returns the character that corresponds to the specified integer code
value. On Unicode systems, you can specify the integer code for any Unicode
character, 0 through 65535. CHAR returns NULL if code-value is a integer that
exceeds the permissible range of values.
CHAR returns an empty string ('') if code-value is a nonnumeric string. CHAR
returns NULL if passed a NULL value.
Note that CHAR can be used as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
Examples
The following examples both return the character Z:

SELECT DISTINCT CHAR(90) AS CharCode
FROM Sample.Person

SELECT DISTINCT {fn CHAR(90)} AS CharCode
FROM Sample.Person
The following example returns the Greek letter lambda:

SELECT DISTINCT {fn CHAR(955)} AS CharCode
FROM Sample.Person
See Also

  • SQL functions: ASCII CHAR_LENGTH CHARACTER_LENGTH
  • Caché ObjectScript functions: $CHAR $ZLCHAR $ZWCHAR


 #}}}
*CHARINDEX*  #{{{

A string function that finds a substring by value and returns its start
position.
Synopsis

CHARINDEX(substring,string[,start])

Arguments

substring  A substring to match within string.

string     A string expression that is the target for the substring search.

           Optional  The starting point for substring search, specified as a
           positive integer. A character count from the beginning of string,
start      counting from 1. To search from the beginning of string, omit this
           argument or specify a start of 0 or 1. A negative number, the empty
           string, NULL, or a nonnumeric value is treated as 0.

Description
CHARINDEX searches a string for a substring. If a match is found, it returns
the starting position of the first matching substring, counting from 1.
Matching is case-sensitive. If the substring cannot be found, CHARINDEX returns
0.
The empty string is a string value. You can, therefore, use the empty string
for either string argument value. The start argument treats an empty string
value as 0. However, note that the Caché ObjectScript empty string is passed to
Caché SQL as NULL.
NULL is not a string value in Caché SQL. For this reason, specifying NULL for
either CHARINDEX string argument returns NULL.
This function provides compatibility with Transact-SQL implementations.
CHARINDEX and $FIND
Both CHARINDEX and $FIND search a string for a specified substring and return
the first match. CHARINDEX returns the integer position of the first character
of the matching substring. $FIND returns the integer position of the first
character after the end of the matching substring.
For a list of functions that search for a substring, refer to String
Manipulation.
Examples
The following example searches for the substring KONG. It returns 6, the
character position of this substring within the string:

SELECT DISTINCT CHARINDEX('KONG','KING KONG')
FROM Sample.Person
The following example searches for all Name field values that contain the
substring 'Fred':

SELECT Name
FROM Sample.Person
WHERE CHARINDEX('Fred',Name)>0
The following example matches a substring after the first 10 characters:

SELECT DISTINCT
CHARINDEX('Re','Repair, Reuse, Recycle',10)
FROM Sample.Person
it returns 16.
The following example specifies a start location beyond the length of the
string:

SELECT DISTINCT
CHARINDEX('Re','Repair, Reuse, Recycle',99)
FROM Sample.Person
it returns 0.
The following example shows that CHARINDEX handles the empty string ('') just
like any other string value:

SELECT DISTINCT
  CHARINDEX('','King Kong'),
  CHARINDEX('K',''),
  CHARINDEX('','')
FROM Sample.Person
In the above example, the first and second CHARINDEX functions return 0 (no
match). The third returns 1, because the empty string matches the empty string
at position 1.
The following example shows that CHARINDEX does not treat NULL as a string
value. Specifying NULL for either string always returns NULL:

SELECT DISTINCT
  CHARINDEX(NULL,'King Kong'),
  CHARINDEX('K',NULL),
  CHARINDEX(NULL,NULL)
FROM Sample.Person
See Also

  • $FIND function
  • STUFF function
  • REPLACE function
  • String Manipulation


 #}}}
*CHAR_LENGTH*  #{{{

A function that returns the number of characters in an expression.
Synopsis

CHAR_LENGTH(expression)

Arguments

            An expression, which can be the name of a column, a string literal,
expression  or the result of another scalar function. The underlying data type
            can be a character type (such as CHAR or VARCHAR), a numeric, or a
            data stream.

Description
CHAR_LENGTH returns an integer value representing the number of characters, not
the number of bytes, in the specified expression. The expression can be a
string, or any other data type such as a numeric or a data stream. This integer
count returned including leading and trailing blanks and the string-termination
character. CHARACTER_LENGTH returns NULL if passed a NULL value, and 0 if
passed an empty string ('') value.
Numbers are parsed before counting the characters; quoted number strings are
not parsed. In the following example, the first CHAR_LENGTH returns 1 (because
number parsing removes leading and trailing blanks), the second CHAR_LENGTH
returns 7.

SELECT DISTINCT CHAR_LENGTH(007.000) AS NumLen,
     CHAR_LENGTH('007.000') AS NumStringLen
     FROM Sample.Employee
Note:
The CHAR_LENGTH, CHARACTER_LENGTH, and DATALENGTH functions are identical. All
of them accept a data stream argument. The LENGTH function differs from these
functions by stripping trailing blanks and the string-termination character
before counting characters. LENGTH does not accept a data stream argument.
Examples
The following example returns the number of characters in the state
abbreviation field (Home_State) in the Sample.Employee table. (All U.S. states
have a two-letter postal abbreviation):

SELECT DISTINCT CHAR_LENGTH(Home_State) AS StateLength
     FROM Sample.Employee
The following example returns the names of the employees and the number of
characters in each employee name, ordered by ascending number of characters:

SELECT Name,
     CHAR_LENGTH(Name) AS NameLength
     FROM Sample.Employee
     ORDER BY NameLength
The following embedded SQL example shows how CHAR_LENGTH handles Unicode
characters. CHAR_LENGTH counts the number of characters, regardless of their
byte length.

   SET a=$CHAR(960)_"FACE"
   WRITE !,a
   &sql(SELECT CHAR_LENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The CHAR length is ",b }
returns 5.
See Also

  • SQL functions: CHAR CHARACTER_LENGTH DATALENGTH LENGTH
  • Caché ObjectScript function: $LENGTH


 #}}}
*CLOSE_sql*  #{{{

Closes a cursor.
Synopsis

CLOSE cursor-name

Arguments

cursor-name  The name of the cursor to be closed. The cursor name was specified
             in the DECLARE statement. Cursor names are case-sensitive.

Description
A CLOSE statement shuts down an open cursor. It releases the current result set
and frees any cursor locks held on the rows on which the cursor is positioned. 
CLOSE leaves the data structures accessible for reopening, but fetches and
positioned updates are not allowed until the cursor is reopened. CLOSE must be
issued on an open cursor; it is not allowed on cursors that have only been
declared or are already closed.
Note that, as an SQL statement, this is only supported from embedded SQL.
Equivalent operations are supported through ODBC using the ODBC API.
Example
The following embedded SQL example shows a cursor (named EmpCursor) being
opened and closed:

   SET name="LastName,FirstName",state="##"
   &sql(DECLARE EmpCursor CURSOR FOR
        SELECT Name, Home_State
        INTO :name,:state FROM Sample.Person
        WHERE Home_State %STARTSWITH 'A')
   WRITE !,"BEFORE: Name=",name," State=",state
   &sql(OPEN EmpCursor)
   NEW SQLCODE,%ROWCOUNT,%ROWID
   FOR { &sql(FETCH EmpCursor)
        QUIT:SQLCODE
        WRITE !,"DURING: Name=",name," State=",state }
   WRITE !,"After FETCH error code: ",SQLCODE
   WRITE !,"After FETCH row count: ",%ROWCOUNT
   &sql(CLOSE EmpCursor)
   WRITE !,"After CLOSE error code: ",SQLCODE
   WRITE !,"After CLOSE row count: ",%ROWCOUNT
   WRITE !,"AFTER: Name=",name," State=",state
Note that after closing the cursor, the host variables remain set to the last
fetched data values, and %ROWCOUNT remains set to the number of rows retrieved.
However, the SQLCODE value at the end of the fetch (SQLCODE=100) is overwritten
by the SQLCODE value for the CLOSE (SQLCODE=0).
See Also

  • DECLARE FETCH OPEN
  • SQL Cursors in the  Using Embedded SQL chapter of Using Caché SQL


 #}}}
*COALESCE*  #{{{

A function that returns the value of the first expression that is not NULL.
Synopsis

COALESCE(expression,expression)

Arguments

            A series of expressions to be evaluated. Multiple expressions are
expression  specified as a comma-separated list. This expression list has a
            limit of 140 expressions.

Description
The COALESCE function evaluates a list of expressions in left-to-right order
and returns the value of the first non-NULL expression. If all expressions
evaluate to NULL, NULL is returned.
Non-numeric expressions (such as strings or dates) must all be of the same data
type, and return a value of that data type. Specifying expressions with
different data types results in an SQLCODE -378.
Numeric expressions must be of compatible data types. The data type of the
returned value is the expression data type with the highest ODBC precedence.
The following data types are compatible and are specified in order of
precedence (highest to lowest): DOUBLE, NUMERIC, BIGINT, INTEGER, SMALLINT,
TINYINT. Specifying expressions with incompatible data types results in an
SQLCODE -378.
You can use the CAST function to convert an expression to the desired data
type.
A string is returned unchanged; leading and trailing blanks are retained. A
number is returned in canonical form, with leading and trailing zeros removed.
For further details on NULL handling, refer to the NULL and the Empty String
section of  Language Elements in Using Caché SQL.
Examples
The following embedded SQL example takes a series of host variable values and
returns the first (value d) that is not a null value. Note that the Caché
ObjectScript empty string ("") is translated as NULL in Caché SQL.

  SET (a,b,c,e)=""
  SET d="firstdata"
  SET f="nextdata"
  &sql(SELECT COALESCE(:a,:b,:c,:d,:e,:f)
    INTO :x
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The first non-null value is: ",x }
See Also

  • CAST function
  • IFNULL function
  • ISNULL function
  • Data types reference list


 #}}}
*CONCAT*  #{{{

A scalar string function that returns a character string as a result of
concatenating two character expressions.
Synopsis

{fn CONCAT(string-expression1,string-expression2)}

Arguments

                    The string expressions to be concatenated. The expressions
string-expression1  can be the name of a column, a string literal, a numeric,
,                   or the result of another scalar function, where the
string-expression2  underlying data type can be represented as any character
                    type (such as CHAR or VARCHAR).

Description
CONCAT concatenates two strings to return a concatenated string. You can
perform exactly the same operation using the concatenate operator (||).
You can concatenate any combination of numerics or numeric strings; the
concatenation result is a numeric string. Caché SQL converts numerics to
canonical form (exponents are expanded and leading and trailing zeros are
removed) before concatenation. Numeric strings are not converted to canonical
form before concatenation.
You can concatenate leading or trailing blanks to a string. Concatenating a
NULL value to a string results in a NULL; this is the industry-wide SQL
standard.
The STRING function can also be used to concatenate two or more expressions
into a single string.
Examples
The following example concatenates the Home_State and Home_City columns to
create a location value. The concatenation is shown twice, using the CONCAT
function and the concatenate operator:

SELECT {fn CONCAT(Home_State,Home_City)} AS LocationFunc,
Home_State||Home_City AS LocationOp
FROM Sample.Person
The following example shows what happens when you attempt to concatenate a
string and a NULL:

SELECT {fn CONCAT(Home_State,NULL)} AS StrNull
FROM Sample.Person
The following example shows that numbers are converted to canonical form before
concatenation. To avoid this, you can specify the number as a string, as shown:

SELECT {fn CONCAT(Home_State,0012.00E2)} AS StrNum,
{fn CONCAT(Home_State,'0012.00E2')} AS StrStrNum
FROM Sample.Person
The following example shows that trailing blank spaces are retained:

SELECT CHAR_LENGTH({fn CONCAT(Home_State,'          ')}) AS StrSpace
FROM Sample.Person
See Also
ASCII CHAR STRING SUBSTRING

 #}}}
*CONVERT*  #{{{

A function that converts a given expression to a specified data type.
Synopsis

{fn CONVERT(expression,datatype)}

CONVERT(datatype,expression[,format-code])

Arguments

expression   The expression to be converted.

datatype     The data type to which expression is to be converted.

             Optional  An integer code that specifies date and time formats,
format-code  used to convert between date/time/timestamp data types and
             character data types. This argument is only used with the second
             syntax form.

Description
Two different implementations of the CONVERT function are described here. Both
convert an expression in one data type to a corresponding value in another data
type. Both perform date and time conversions.
Note:
The arguments in these two implementations of CONVERT are presented in a
different order. The first is a Caché ODBC scalar function with two arguments.
The second is a general function compatible with MS SQL Server, which takes
three arguments. These two forms of CONVERT are handled separately in the text
that follows.
If an expression does not have a defined data type (for example a host variable
supplied by Caché ObjectScript) its data type defaults to the string data type.
Specifying an invalid value to either version of CONVERT results in an SQLCODE
-141.
For a list of the data types supported by Caché SQL, see Data Type. For other
data type conversions, refer to the CAST function.
{fn CONVERT(expression,datatype)}
This is the ODBC scalar function. It supports the following ODBC explicit data
type conversions. You must use the  SQL_ keywords for specifying data types
with this form of CONVERT:

           From                                    To

SQL_TIMESTAMP (%TimeStamp)  SQL_TIME, SQL_DATE, SQL_VARCHAR, SQL_TIMESTAMP

SQL_VARCHAR (%String)       SQL_TIME, SQL_DATE, SQL_TIMESTAMP

SQL_TIME (%Time)            SQL_VARCHAR, SQL_INTEGER, SQL_TIMESTAMP, SQL_TIME

SQL_DATE (%Date)            SQL_VARCHAR, SQL_INTEGER, SQL_TIMESTAMP, SQL_DATE

Any non-BLOB data type      SQL_INTEGER

Any non-BLOB data type      SQL_DOUBLE

Character stream data       SQL_VARCHAR

Any numeric data type       SQL_VARCHAR

SQL_VARCHAR is the standard ODBC representation. When converting to
SQL_VARCHAR, dates and times are converted to their appropriate ODBC
representations; numeric datatype values are converted to a string
representation. When converting from SQL_VARCHAR, the value must be a valid
ODBC Time, Timestamp, or Date representation.
When converting to SQL_INTEGER or SQL_DOUBLE, data values, including dates and
times, are converted to a numeric representation. For SQL_DATE, this is the
number of days since January 1, 1841. For SQL_TIME, this is the number of
seconds since midnight. Input strings are truncated when a nonnumeric character
is encountered. SQL_INTEGER also truncates decimal digits.
A NULL converted to any data type remains NULL.
An empty string (''), or any nonnumeric string value converts as follows:

  • SQL_VARCHAR and SQL_TIMESTAMP return the supplied value.
  • SQL_INTEGER converts to 0 (zero).
  • SQL_DATE and SQL_TIME convert to NULL.

For other data type conversions, refer to the CAST function.
CONVERT(datatype,expression,format-code)
This is the MS SQL Server compatible function. It takes as datatype any valid
Caché SQL data type. For a list of the data types supported by Caché SQL, see
Data Type.
You can truncate a string by performing a VARCHAR-to-VARCHAR conversion,
specifying an output string length shorter than the expression string length.
When using CONVERT (or CAST), if a character data type (such as CHAR or
VARCHAR) has no specified length, the default maximum length is 30 characters.
If a binary data type (such as BINARY or VARBINARY) has no specified length,
the default maximum length is 30 characters. Otherwise, these data types with
no specified length are mapped to a MAXLEN of 1 character, as shown in the Data
Types table.
You can perform a BIT data type conversion. The permitted values are 1, 0, or
NULL. If you specify any other value, Caché issues an SQLCODE -141 error. In
the following embedded SQL example, both are BIT conversions of a NULL:

  SET a=""
  &sql(SELECT CONVERT(BIT,:a),
       CONVERT(BIT,NULL)
       INTO :x,:y
       FROM Sample.Person)
  WRITE !,"SQLCODE=",SQLCODE
  WRITE !,"the host variable is:",x
  WRITE !,"the NULL keyword is:",y

The optional format-code argument specifies a date, datetime, or time format.
This format can either be used to define the output when converting from a date
/time/timestamp data type to a character string, or to define the input when
converting from a character string to a date/time/timestamp data type. The
following format codes are supported; format codes that output a two-digit year
are listed in the first column; formats that either output a four-digit year or
do not output a year at all are listed in the second column:

  Two-digit year      Four-digit year                    Format
      codes                codes

                    0 or 100             Mon dd yyyy hh:mmAM (or PM)

1                   101                  mm/dd/yy

2                   102                  yy.dd.mm

3                   103                  dd/mm/yy

4                   104                  dd.mm.yy

5                   105                  dd-mm-yy

6                   106                  dd Mon yy

7                   107                  Mon dd, yy (no leading zero when dd <
                                         10)

                    8 or 108             hh:mm:ss

                    9 or 109             Mon dd yyyy hh:mm:ss.nnnAM (or PM)

10                  110                  mm-dd-yy

11                  111                  yy.mm.dd

12                  112                  yymmdd

                    13 or 113            dd Mon yyyy hh:mm:ss:nnn (24 hour)

                    14 or 114            hh:mm:ss.nnn (24 hour)

                    20 or 120            yyyy-mm-dd hh:mm:ss (24 hour)

                    21 or 121            yyyy-mm-dd hh:mm:ss.nnn (24 hour)

                    126                  yyyy-mm-ddThh:mm:ss:nnn (24 hour)

                    130                  dd Mon yyyy hh:mm:ss:nnnAM (or PM)

                    131                  dd/mm/yyyy hh:mm:ss:nnnAM (or PM)

The following are features of date and time conversions:

  • Range of Values: The range of permitted dates is 1840-12-31 through
    9999-12-31.
  • Default Values: When performing a DATETIME or SMALLDATETIME conversion, the
    date defaults to 1900-01-01. The time defaults to 00:00:00.
  • Default Format: If format-code is not specified, CONVERT attempts to
    determine the format from the specified value. If it cannot, it defaults to
    format-code 100.
  • Two-digit Years: Two-digit years from 00 through 49 are converted to 21st
    century dates (2000 through 2049); two-digit years from 50 through 99 are
    converted to 20th century dates (1950 through 1999).
  • Fractional Seconds: Fractional seconds can be preceded by either a period
    (.) or a colon (:). The symbols have different meanings. A period indicates
    a standard fraction; thus 12:00:00.4 indicates four-tenths of a second, and
    12:00:00.004 indicates four-thousandth of a second. A colon indicates that
    what follows is in thousandths of a second; thus 12:00:00:4 indicates
    four-thousandth of a second.

CONVERT Class Method
You can also perform data type conversions using the CONVERT method call:
$SYSTEM.SQL.CONVERT(expression,convert-to-type,convert-from-type)
as shown in the following example:

  WRITE $SYSTEM.SQL.CONVERT(60945,"SQL_VARCHAR","SQL_DATE")
Examples
The following embedded SQL example converts a mixed string to an integer. Caché
truncates the string at the first nonnumeric character and then converts the
resulting numeric to canonical form:

  SET a="007 James Bond"
  &sql(SELECT {fn CONVERT(:a,SQL_INTEGER)}
       INTO :x
       FROM Sample.Person)
  WRITE !,"SQLCODE=",SQLCODE
  WRITE !,"the host variable is:",x
returns the integer 7.
The following example converts dates in the "DOB" (Date Of Birth) column to the
SQL_TIMESTAMP data type.

SELECT DOB,{fn CONVERT(DOB,SQL_TIMESTAMP)} AS DOBtoTstamp
     FROM Sample.Person
The resulting timestamp is in the format: yyyy-mm-dd hh:mm:ss.
The following example converts dates in the "DOB" (Date Of Birth) column to the
SQL_INTEGER data type.

SELECT DOB,{fn CONVERT(DOB,SQL_INTEGER)} AS DOBtoInt
     FROM Sample.Person
The resulting integer is the $HOROLOG count of days since December 31, 1840.
The following example converts dates in the "DOB" (Date Of Birth) column to the
SQL_VARCHAR data type.

SELECT DOB,{fn CONVERT(DOB,SQL_VARCHAR)} AS DOBtoVChar
     FROM Sample.Person
The resulting string is in the format: yyyy-mm-dd.
The following example uses the second syntactical form of CONVERT. It shows
several conversions of the date-of-birth field (DOB) to a formatted character
string:

SELECT DOB,
CONVERT(VARCHAR(20),DOB) AS DOBDefault,
CONVERT(VARCHAR(20),DOB,100) AS DOB100,
CONVERT(VARCHAR(20),DOB,107) AS DOB107,
CONVERT(VARCHAR(20),DOB,114) AS DOB114,
CONVERT(VARCHAR(20),DOB,126) AS DOB126
     FROM Sample.Person
The default format and the code 100 format are the same. Because the DOB field
does not contain a time value, formats that display time (here including the
default, 100, 114, and 126) supply a zero value, which represents 12:00AM
(midnight). The code 126 format provides a date and time string that contains
no spaces.
See Also
Data Type CAST

 #}}}
*COS*  #{{{

A scalar numeric function that returns the cosine, in radians, of an angle.
Synopsis

{fn COS(float-expression)}

Arguments

float-expression  An expression of type FLOAT. This is an angle expressed in
                  radians.

Description
COS takes any numeric value and returns the cosine as a floating point number.
The returned value is within the range -1 to 1, inclusive. COS returns NULL if
passed a NULL value. COS treats nonnumeric strings as the numeric value 0.
COS returns a value of data type FLOAT with a precision of 19 and a scale of
18.
COS can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
These examples show the effect of COS on two sines.

SELECT DISTINCT {fn COS(0.52)} AS Cosine
FROM Sample.Person
returns 0.86781.

SELECT DISTINCT {fn COS(-.31)} AS Cosine
FROM Sample.Person
returns 0.95233.
See Also

  • SQL functions: ACOS ASIN ATAN COT SIN TAN
  • Caché ObjectScript function: $ZCOS


 #}}}
*COT*  #{{{

A scalar numeric function that returns the cotangent, in radians, of an angle.
Synopsis

{fn COT(float-expression)}

Arguments

float-expression  An expression of type FLOAT. This is an angle expressed in
                  radians.

Description
COT takes any nonzero number and returns its cotangent as a floating point
number. COT returns NULL if passed a NULL value. A numeric value of 0 (zero)
causes a runtime error, generating an SQLCODE -400 (fatal error occurred). COT
treats nonnumeric strings as the numeric value 0.
COT returns a value of data type FLOAT with a precision of 36 and a scale of
18.
COT can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following examples show the effect of COT:

SELECT DISTINCT {fn COT(0.52)} AS Cotangent
FROM Sample.Person
returns 1.74653.

SELECT DISTINCT {fn COT(124.1332)} AS Cotangent
FROM Sample.Person
returns -0.040312.
See Also

  • SQL functions: ACOS ASIN ATAN COS SIN TAN
  • Caché ObjectScript function: $ZCOT


 #}}}
*COUNT*  #{{{

An aggregate function that returns the number of rows in a table or a specified
column.
Synopsis

COUNT(*)

COUNT([ALL | DISTINCT] expression)

Arguments

            Specifies that all rows should be counted to return the total
            number of rows in the specified table. COUNT(*) takes no parameters
            and cannot be used with the ALL or DISTINCT keywords. COUNT(*) does
*           not take an expression parameter, and does not use information
            about any particular column. COUNT(*) returns the number of rows in
            a specified table or view without eliminating duplicates. It counts
            each row separately, including rows that contain NULL values.

ALL         Optional  Specifies that COUNT return the count of all values for 
            expression. This is the default if no keyword is specified.

            Optional  Specifies that COUNT return the count of the distinct
DISTINCT    (unique) values for expression. If not specified, the default is
            ALL.

expression  Any valid expression. Usually the name of a column that contains
            the data values to be counted.

Description
The COUNT aggregate function has two forms:

  • COUNT(expression) returns the count of the number of values in expression
    as an integer. Commonly, expression is the name of a field, (or an
    expression containing one or more field names) in the multiple rows
    returned by a query. COUNT(expression) does not count NULL values. It can
    optionally count or not count duplicate field values.
  • COUNT(*) returns the count of the number of rows in the table as an
    integer. COUNT(*) counts all rows, regardless of the presence of duplicate
    field values or NULL values.

COUNT can be used in a SELECT query or subquery that references either a table
or a view. COUNT can appear in a SELECT list or HAVING clause alongside
ordinary field values.
COUNT cannot be used in a WHERE clause. COUNT cannot be used in the ON clause
of a JOIN, unless the SELECT is a subquery.
COUNT(expression) can take a DISTINCT keyword or an ALL keyword. The DISTINCT
keyword counts only those fields having distinct (unique) values; a field with
duplicate values is only counted once. The ALL keyword counts all non-NULL
values, including all duplicates. ALL is the default behavior.
Data Values
COUNT always returns type INTEGER with length 4, precision 10, and scale 0.
Privileges
To use COUNT(*) you must have table-level SELECT privilege for the specified
table. To use COUNT(column-name) you must have column-level SELECT privilege
for the specified column, or table-level SELECT privilege for the specified
table. For further details, refer to the GRANT statement.
Changes Made During the Current Transaction
Like all aggregate functions, COUNT always returns the current state of the
data, including uncommitted changes, regardless of the current transaction's
isolation level. For further details, refer to SET TRANSACTION and START
TRANSACTION.
Examples
The following query returns the total number of rows in the Sample.Person
database:

SELECT COUNT(*) AS TotalPersons
     FROM Sample.Person
The following query returns the total number of rows for each distinct
Home_State value in the Sample.Person database.

SELECT Home_State, COUNT(*) AS TotalPersons
     FROM Sample.Person
     GROUP BY Home_State
     ORDER BY Home_State
The following query returns three values: the total number of rows, the total
number of non-NULL values in the FavoriteColors field, and the total number of
distinct non-NULL values in the FavoriteColors field:

SELECT COUNT(*) As TotalPersons,
       COUNT(FavoriteColors) AS WithColorPref,
       COUNT(DISTINCT FavoriteColors) AS ColorPrefs
       FROM Sample.Person
The following query shows COUNT with a concatenation expression. It returns the
total number of non-NULL values in the FavoriteColors field, and the total
number of non-NULL values in FavoriteColors concatenated with two other fields,
using the concatenate operator (||):

SELECT COUNT(FavoriteColors) AS Color,
       COUNT(FavoriteColors||Home_State) AS ColorState,
       COUNT(FavoriteColors||Spouse) AS ColorSpouse
       FROM Sample.Person
When two fields are concatenated, COUNT counts only those rows in which neither
field has a NULL value. Because every row in Sample.Person has a non-NULL
Home_State value, the concatenation FavoriteColors||Home_State returns the same
count as FavoriteColors. Because some rows in Sample.Person have a NULL value
for Spouse, the concatenation FavoriteColors||Spouse returns the count of rows
which have non-NULL values for both FavoriteColors and Spouse.
See Also

  • AVG
  • SUM


 #}}}
*CURDATE*  #{{{

A scalar date/time function that returns the current date.
Synopsis

{fn CURDATE()}
{fn CURDATE}

Description
CURDATE takes no arguments and returns the date as type DATE. Note that the
argument parentheses are optional.
By default, CURDATE returns a date with the format:

mm/dd/yyyy

To specify a different date format, use the TO_DATE function. To change the
default date format, use the SET OPTION command with the DATE_FORMAT,
YEAR_OPTION, or DATE_SEPARATOR options.
To return just the current date, use CURDATE or CURRENT_DATE. These functions
return their values in DATE data type. The CURRENT_TIMESTAMP, GETDATE and NOW
functions can also be used to return the current date and time as a TIMESTAMP
data type.
These data types perform differently when using embedded SQL. The DATE data
type stores values as integers in $HOROLOG format; when displayed in SQL they
are converted to date display format; when returned from embedded SQL they are
returned as integers. A TIMESTAMP data type stores and displays its value in
the same format. You can use the CONVERT function to change the datatype of
dates and times.
Examples
The following examples both return the current date:

SELECT DISTINCT {fn CURDATE()} AS Today
FROM Sample.Person

SELECT DISTINCT {fn CURDATE} AS Today
FROM Sample.Person
The following embedded SQL example returns the current date. Because this date
is stored in $HOROLOG format, it is returned as an integer:

  &sql(SELECT {fn CURDATE()}
  INTO :a
  FROM Sample.Person)
  WRITE !,"Current date is: ",a
The following example shows how CURDATE can be used in a SELECT statement to
return all records that have a shipment date that is the same or later than
today's date:

SELECT * FROM Orders
     WHERE ShipDate >= {fn CURDATE()}

See Also

  • SQL functions: CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURTIME NOW
  • Caché ObjectScript function: $ZDATE


 #}}}
*CURRENT_DATE*  #{{{

A date/time function that returns the current date.
Synopsis

CURRENT_DATE

Description
CURRENT_DATE takes no arguments and returns the date as type DATE. Argument
parentheses are not permitted.
By default, CURRENT_DATE returns a date with the format:

mm/dd/yyyy

To specify a different date format, use the TO_DATE function. To change the
default date format, use the SET OPTION command with the DATE_FORMAT,
YEAR_OPTION, or DATE_SEPARATOR options.
To return just the current date, use CURRENT_DATE or CURDATE. These functions
return their values in DATE data type. The CURRENT_TIMESTAMP, GETDATE and NOW
functions can also be used to return the current date and time as a TIMESTAMP
data type.
These data types perform differently when using embedded SQL. The DATE data
type stores values as integers in $HOROLOG format; when displayed in SQL they
are converted to date display format; when returned from embedded SQL they are
returned as integers. A TIMESTAMP data type stores and displays its value in
the same format. You can use the CONVERT function to change the datatype of
dates and times.
CURRENT_DATE can be used as a default specification keyword in CREATE TABLE or
ALTER TABLE.
Examples
The following example returns the current date:

SELECT DISTINCT CURRENT_DATE AS Today
FROM sample.person
The following embedded SQL example returns the current date. Because this date
is stored in $HOROLOG format, it is returned as an integer:

  &sql(SELECT CURRENT_DATE
  INTO :a
  FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Current date is: ",a }
The following example shows how CURRENT_DATE can be used in a SELECT statement
to return all records of employees who have a birthday today:

SELECT * FROM Employees
     WHERE dob = CURRENT_DATE

See Also
CURDATE CURRENT_TIME CURRENT_TIMESTAMP CURTIME NOW

 #}}}
*CURRENT_TIME*  #{{{

A date/time function that returns the current local time.
Synopsis

CURRENT_TIME

Description
CURRENT_TIME takes no arguments and returns the time as a TIME data type.
Argument parentheses are not permitted.
By default, CURRENT_TIME returns a time with the format:

hh:mm:ss

To change the default time format, use the SET OPTION command with the
TIME_FORMAT and TIME_PRECISION options. You can configure fractional seconds of
precision, as described below.
To return just the current time, use CURRENT_TIME or CURTIME. These functions
return their values in TIME data type. The CURRENT_TIMESTAMP, GETDATE and NOW
functions can also be used to return the current date and time as a TIMESTAMP
data type.
These data types perform differently when using embedded SQL. The TIME data
type stores values as integers in $HOROLOG format (as the number of seconds
since midnight); when displayed in SQL they are converted to time display
format; when returned from embedded SQL they are returned as integers. A
TIMESTAMP data type stores and displays its value in the same format. You can
use the CAST or CONVERT function to change the datatype of times and dates.
CURRENT_TIME can be used as a default specification keyword in CREATE TABLE or
ALTER TABLE.
Fractional Seconds Precision
CURRENT_TIME can return up to nine digits of fractional seconds of precision.
The default for the number of digits of precision can be configured using the
following:

  • SET OPTION with the TIME_PRECISION option.
  • The $SYSTEM.SQL.SetDefaultTimePrecision() method call.
  • Go to the System Management Portal, select [Home] > [Configuration] > [SQL
    Settings] > [General SQL Settings]. View and edit the current setting of 
    Default time precision for GETDATE(), CURRENT_TIME, and CURRENT_TIMESTAMP.

Specify an integer 0 through 9 (inclusive) for the default number of decimal
digits to return. The default is 0. The actual precision returned is platform
dependent; digits of precision in excess of the precision available on your
system are returned as zeroes.
Examples
The following example returns the current system time:

SELECT DISTINCT CURRENT_TIME
FROM Sample.Person
The following embedded SQL example returns the current time. Because this time
is stored in $HOROLOG format, it is returned as an integer:

  &sql(SELECT CURRENT_TIME
  INTO :a
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"Current time is: ",a }
The following example sets the LastCall field in the selected row of the
Contacts table to the current system time:

UPDATE Contacts SET LastCall = CURRENT_TIME
  WHERE Contacts.ItemNumber=:item

See Also

  • SQL concepts: Data Type Date and Time Constructs
  • SQL time functions: CAST CONVERT CURTIME HOUR MINUTE SECOND
  • SQL timestamp functions: CURRENT_TIMESTAMP GETDATE NOW TIMESTAMPADD
    TIMESTAMPDIFF
  • Caché ObjectScript: $ZTIME function $HOROLOG special variable $ZTIMESTAMP
    special variable


 #}}}
*CURTIME*  #{{{

A scalar date/time function that returns the current local time.
Synopsis

{fn CURTIME()}
{fn CURTIME}

Description
CURTIME takes no arguments and returns the time as a TIME data type. Note that
the argument parentheses are optional.
By default, CURTIME returns a time with the format:

hh:mm:ss

Hours are represented in 24 hour format.
To change the default time format, use the SET OPTION command with the
TIME_FORMAT and TIME_PRECISION options.
To return just the current time, use CURTIME or CURRENT_TIME. These functions
return their values in TIME data type. The CURRENT_TIMESTAMP, GETDATE and NOW
functions can also be used to return the current date and time as a TIMESTAMP
data type.
These data types perform differently when using embedded SQL. The TIME data
type stores values as integers in $HOROLOG format (as the number of seconds
since midnight); when displayed in SQL they are converted to time display
format; when returned from embedded SQL they are returned as integers. A
TIMESTAMP data type stores and displays its value in the same format. You can
use the CAST or CONVERT function to change the datatype of times and dates.
Examples
The following examples both return the current system time:

SELECT DISTINCT {fn CURTIME()} AS TimeNow
FROM Sample.Person

SELECT DISTINCT {fn CURTIME} AS TimeNow
FROM Sample.Person
The following embedded SQL example returns the current time. Because this time
is stored in $HOROLOG format, it is returned as an integer:

  &sql(SELECT {fn CURTIME}
  INTO :a
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"Current time is: ",a }
The following example sets the LastCall field in the selected row of the
Contacts table to the current system time:

UPDATE Contacts Set LastCall = {fn CURTIME()}
  WHERE Contacts.ItemNumber=:item

See Also

  • SQL concepts: Data Type Date and Time Constructs
  • SQL time functions: CAST CONVERT CURRENT_TIME HOUR MINUTE SECOND
  • SQL timestamp functions: CURRENT_TIMESTAMP GETDATE NOW TIMESTAMPADD
    TIMESTAMPDIFF
  • Caché ObjectScript: $ZTIME function $HOROLOG special variable $ZTIMESTAMP
    special variable


 #}}}
*DATABASE*  #{{{

A scalar string function that returns the database name qualifier.
Synopsis

{fn DATABASE()}

Description
DATABASE returns the current qualifier for the name of the database
corresponding to the connection handle. In Caché, DATABASE always returns the
empty string ('').

 #}}}
*DATALENGTH*  #{{{

A function that returns the number of characters in an expression.
Synopsis

DATALENGTH(expression)

Arguments

            An expression, which can be the name of a column, a string literal,
expression  or the result of another scalar function. The underlying data type
            can be a character type (such as CHAR or VARCHAR), a numeric, or a
            data stream.

Description
Note:
The DATALENGTH, CHAR_LENGTH, and CHARACTER_LENGTH functions are identical. Use
of the CHAR_LENGTH function is recommended for new code. DATALENGTH is provided
for TSQL compatibility. Refer to CHAR_LENGTH for further details.
See Also

  • CHAR_LENGTH CHARACTER_LENGTH


where delimiter is a slash (/), hyphen (-), or period (.).
Sybase/SQL-Server-time represents one of these three formats:

HH:MM[:SS:SSS][{AM|PM}]
HH:MM[:SS.S]
HH['']{AM|PM}

If the year is given as two digits, Caché checks the sliding window to
interpret the date. The system default for the sliding window can be set via
the %DATE utility, which is documented only in the  Legacy Documentation 
chapter in Using InterSystems Documentation. For information on setting the
sliding window for the current process, see the documentation for the Caché
ObjectScript $ZDATE, $ZDATEH, $ZDATETIME and $ZDATETIMEH functions.
Note that DATEADD is provided for Sybase and Microsoft SQL Server
compatibility.
Range and Value Checking
DATEADD performs the following checks on input values. If a value fails a
check, the null string is returned.

  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. Years must be specified as four digits.
  • Date values must be within a valid range. Years: 1841 through 9999. Months:
    1 through 12. Days: 1 though 31. Hours: 0 through 23. Minutes: 0 through
    59. Seconds: 0 through 59.
  • The incremented year value returned must be within the range 1841 through
    9999. Incrementing beyond this range returns <null>.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Date values less than 10 may include or omit a leading zero. Other
    non-canonical integer values are not permitted. Therefore, a Day value of
    '07' or '7' is valid, but '007', '7.0' or '7a' are not valid.

Examples
The following example adds 1 week to the specified date:

SELECT DISTINCT DATEADD('week',1,'1999-12-20') AS NewDate
FROM Sample.Person
it returns 1999-12-27 00:00:00, because adding 1 week adds 7 days. Note that 
DATEADD supplies the omitted time portion.
The following example adds 5 months to the original timestamp:

SELECT DISTINCT DATEADD('mm',5,'1999-12-20 12:00:00') AS NewDate
FROM Sample.Person
it returns 2000-05-20 12:00:00 because adding 5 months also increments the
year.
The following example also adds 5 months to the original timestamp:

SELECT DISTINCT DATEADD('mm',5,'1999-01-31 12:00:00') AS NewDate
FROM Sample.Person
it returns 1999-06-30 12:00:00. Here DATEADD modified the day value as well as
the month, because simply incrementing the month would result in June 31, which
is an invalid date.
The following example adds 45 minutes to the original timestamp:

SELECT DISTINCT DATEADD('mi',45,'1999-12-20 12:00:00') AS NewTime
FROM Sample.Person
it returns 1999-12-20 12:45:00.
The following example also adds 45 minutes to the original timestamp, but in
this case the addition increments the date:

SELECT DISTINCT DATEADD('mi',45,'1999-12-20 23:30:00') AS NewTime
FROM Sample.Person
it returns 1999-12-21 00:15:00.
The following example decrements the original timestamp by 45 minutes:

SELECT DISTINCT DATEADD('mi',-45,'1999-12-20 12:00:00') AS NewTime
FROM Sample.Person
it returns 1999-12-20 11:15:00.
The following example adds 60 days to the current date, adjusting for the
varying lengths of months:

SELECT DISTINCT DATEADD('dd',60,CURRENT_DATE) AS NewDate
FROM Sample.Person
The first of the following examples add 92 days to the specified date, and the
second example adds 1 quarter to the specified date:

SELECT DISTINCT DATEADD('dd',92,'1999-12-20') AS NewDate
FROM Sample.Person

SELECT DISTINCT DATEADD('qq',1,'1999-12-20') AS NewDate
FROM Sample.Person
The first returns 2000-03-21 00:00:00; the second returns 2000-03-20 00:00:00.
Incrementing by a quarter increments the month field by 3, and, when needed,
increments the year field. It also corrects for the maximum number of days for
a given month.
The above examples all use date part abbreviations. However, you can also
specify the date part by its full name, as in this example:

SELECT DISTINCT DATEADD('day',92,'1999-12-20') AS NewDate
FROM Sample.Person
it returns 2000-03-21 00:00:00.
See Also
DATEDIFF DATENAME DATEPART TIMESTAMPADD TIMESTAMPDIFF

where delimiter is a slash (/), hyphen (-), or period (.).
Sybase/SQL-Server-time represents one of these three formats:

HH:MM[:SS:SSS][{AM|PM}]
HH:MM[:SS.S]
HH['']{AM|PM}

If the year is given as two digits, Caché checks the sliding window to
interpret the date. The system default for the sliding window can be set via
the %DATE utility, which is documented only in the  Legacy Documentation 
chapter in Using InterSystems Documentation. For information on setting the
sliding window for the current process, see the documentation for the Caché
ObjectScript $ZDATE, $ZDATEH, $ZDATETIME and $ZDATETIMEH functions.
Range and Value Checking
DATEDIFF performs the following checks on input values. If a value fails a
check, the null string is returned.

  • A valid startdate or enddate may consist of a date string (yyyy-mm-dd), a
    time string (hh:mm:ss), or a date and time string (yyyy-mm-dd hh:mm:ss). If
    both date and time are specified, both must be valid. For example, you can
    return a Year value if no time string is specified, but you cannot return a
    Year value if an invalid time string is specified.
  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. For example, you cannot return a Year value if the Day
    value is omitted. Years must be specified as four digits. If you omit the
    date portion of an input value, DATEDIFF defaults to '1900 01 01'.
  • A time string must be properly formatted with the appropriate separator
    character. Because a time value can be zero, you can omit one or more time
    elements (either retaining or omitting the separator characters) and these
    elements will be returned with a value of zero. Thus, 'hh:mm:ss', 'hh:mm:',
    'hh:mm', 'hh::ss', 'hh::', 'hh', and ':::' are all valid. To omit the Hour
    element, the date expression must not have a date portion of the string,
    and you must retain at least one separator character (:).
  • Date and time values must be within a valid range. Years: 1841 through
    9999. Months: 1 through 12. Days: 1 though 31. Hours: 0 through 23.
    Minutes: 0 through 59. Seconds: 0 through 59.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Most date and time values less than 10 may include or omit a leading zero.
    However, an Hour value of less than 10 must include the leading zero if it
    is part of a datetime string. Other non-canonical integer values are not
    permitted. Therefore, a Day value of '07' or '7' is valid, but '007', '7.0'
    or '7a' are not valid.

Examples
The following example returns 353 because there are 353 days ('dd') between the
two timestamps:

SELECT DISTINCT DATEDIFF('dd','1999-01-01 00:00:00','1999-12-20 12:00:00')
FROM Sample.Person
The following example returns 31 because there are 31 years ('yy') between the
two timestamps:

SELECT DISTINCT DATEDIFF('yy','1968-12-21 13:19:00','1999-12-20 00:00:00')
FROM Sample.Person
Note that the above examples use an abbreviation for the date part. However,
you can specify the full name, as in this example:

SELECT DISTINCT DATEDIFF('year','1968-09-10 13:19:00','1999-12-20 00:00:00')
FROM Sample.Person
See Also
DATEADD DATENAME DATEPART TIMESTAMPADD TIMESTAMPDIFF

where delimiter is a slash (/), hyphen (-), or period (.).
If the year is given as two digits, Caché checks the sliding window to
interpret the date. The system default for the sliding window can be set via
the %DATE utility, which is documented only in the  Legacy Documentation 
chapter in Using InterSystems Documentation. For information on setting the
sliding window for the current process, see the documentation for the Caché
ObjectScript $ZDATE, $ZDATEH, $ZDATETIME and $ZDATETIMEH functions.
Sybase/SQL-Server-time represents one of these three formats:

HH:MM[:SS:SSS][{AM|PM}]
HH:MM[:SS.S]
HH['']{AM|PM}

Range validation is not performed for time components. Fractional seconds are
truncated.
Range and Value Checking
DATENAME performs the following checks on input values. If a value fails a
check, the null string is returned.

  • A valid date-expression may consist of a date string (yyyy-mm-dd), a time
    string (hh:mm:ss), or a date and time string (yyyy-mm-dd hh:mm:ss). If both
    date and time are specified, both must be valid. For example, you can
    return a Year value if no time string is specified, but you cannot return a
    Year value if an invalid time string is specified.
  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. For example, you cannot return a Year value if the Day
    value is omitted. Years must be specified as four digits.
  • A time string must be properly formatted with the appropriate separator
    character. Because a time value can be zero, you can omit one or more time
    elements (either retaining or omitting the separator characters) and these
    elements will be returned with a value of zero. Thus, 'hh:mm:ss', 'hh:mm:',
    'hh:mm', 'hh::ss', 'hh::', 'hh', and ':::' are all valid. To omit the Hour
    element, date-expression must not have a date portion of the string, and
    you must retain at least one separator character (:).
  • Date and time values must be within a valid range. Years: 1841 through
    9999. Months: 1 through 12. Days: 1 though 31. Hours: 0 through 23.
    Minutes: 0 through 59. Seconds: 0 through 59.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Most date and time values less than 10 may include or omit a leading zero.
    However, an Hour value of less than 10 must include the leading zero if it
    is part of a datetime string. Other non-canonical integer values are not
    permitted. Therefore, a Day value of '07' or '7' is valid, but '007', '7.0'
    or '7a' are not valid.

Examples
The following examples all return 'Wednesday' because that is the day of week
('dw') of the specified date:

SELECT DISTINCT DATENAME('dw','2004-02-25') AS DayName
FROM Sample.Person

SELECT DISTINCT DATENAME('dw','02/25/2004') AS DayName
FROM Sample.Person

SELECT DISTINCT DATENAME('dw',59590) AS DayName
FROM Sample.Person
The following example returns 'December' because that is the month name ('mm')
of the specified date:

SELECT DISTINCT DATENAME('mm','1999-12-20 12:00:00') AS MonthName
FROM Sample.Person
The following example returns '1999' (as a string) because that is the year
('yy') of the specified date:

SELECT DISTINCT DATENAME('yy','1999-12-20 12:00:00') AS Year
FROM Sample.Person
Note that the above examples use the abbreviations of the date parts. However,
you can specify the full name, as in this example:

SELECT DISTINCT DATENAME('year','1999-12-20 12:00:00') AS Year
FROM Sample.Person
The following embedded SQL example passes in the datepart as a host variable:

  SET a="year"
  &sql(SELECT DISTINCT DATENAME(:a,'1999-12-20 12:00:00')
       INTO :b
       FROM Sample.Person)
  WRITE a," is:",b
See Also

  • SQL functions: DATEADD DATEDIFF DATEPART TO_DATE TIMESTAMPADD TIMESTAMPDIFF
  • Caché ObjectScript function: $ZDATETIME


where delimiter is a slash (/), hyphen (-), or period (.).
If the year is given as two digits, Caché checks the sliding window to
interpret the date. The system default for the sliding window can be set via
the %DATE utility, which is documented only in the  Legacy Documentation 
chapter in Using InterSystems Documentation. For information on setting the
sliding window for the current process, see the documentation for the Caché
ObjectScript $ZDATE, $ZDATEH, $ZDATETIME and $ZDATETIMEH functions.
Sybase/SQL-Server-time represents one of these three formats:

HH:MM[:SS:SSS][{AM|PM}]
HH:MM[:SS.S]
HH['']{AM|PM}

For sqltimestamp, time is returned as a 24-hour clock. Range validation is not
performed for time components. Fractional seconds are truncated.
Range and Value Checking
DATEPART performs the following checks on input values. If a value fails a
check, the null string is returned.

  • A valid date-expression may consist of a date string (yyyy-mm-dd), a time
    string (hh:mm:ss), or a date and time string (yyyy-mm-dd hh:mm:ss). If both
    date and time are specified, both must be valid. For example, you can
    return a Year value if no time string is specified, but you cannot return a
    Year value if an invalid time string is specified.
  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. For example, you cannot return a Year value if the Day
    value is omitted. Years must be specified as four digits.
  • A time string must be properly formatted with the appropriate separator
    character. Because a time value can be zero, you can omit one or more time
    elements (either retaining or omitting the separator characters) and these
    elements will be returned with a value of zero. Thus, 'hh:mm:ss', 'hh:mm:',
    'hh:mm', 'hh::ss', 'hh::', 'hh', and ':::' are all valid. To omit the Hour
    element, date-expression must not have a date portion of the string, and
    you must retain at least one separator character (:).
  • Date and time values must be within a valid range. Years: 1841 through
    9999. Months: 1 through 12. Days: 1 though 31. Hours: 0 through 23.
    Minutes: 0 through 59. Seconds: 0 through 59.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Most date and time values less than 10 may include or omit a leading zero.
    However, an Hour value of less than 10 must include the leading zero if it
    is part of a datetime string. Other non-canonical integer values are not
    permitted. Therefore, a Day value of '07' or '7' is valid, but '007', '7.0'
    or '7a' are not valid.

Examples
The following five examples all return the year portion of the datetime string
(in this case, 2004) as an integer. Note that date-expression can be in various
formats, and datepart can be specified as either the datepart name or datepart
abbreviation:

SELECT DISTINCT DATEPART('yy','2004-12-20 12:00:00') AS Year
FROM Sample.Person

SELECT DISTINCT DATEPART('year','2004-02-25') AS Year
FROM Sample.Person

SELECT DISTINCT DATEPART('YY','02/25/2004') AS Year
FROM Sample.Person

SELECT DISTINCT DATEPART('YEAR',59590) AS Year
FROM Sample.Person

SELECT DISTINCT DATEPART('Year','59590,23456') AS Year
FROM Sample.Person
The following example returns the quarter of the year:

SELECT DISTINCT DATEPART('qq','2003-07-20') AS Quarter
FROM Sample.Person
The following examples all return 20 as the minutes portion of the datetime
string.

SELECT DISTINCT DATEPART('mi','1999-1-20 12:20:07') AS Minutes
FROM Sample.Person

SELECT DISTINCT DATEPART('mi','1999-02-20 10:20:') AS Minutes
FROM Sample.Person

SELECT DISTINCT DATEPART('mi','1999-02-20 10:20') AS Minutes
FROM Sample.Person
The following examples all return 0 as the seconds portion of the datetime
string.

SELECT DISTINCT DATEPART('ss','1999-02-20 03:20:') AS Seconds
FROM Sample.Person

SELECT DISTINCT DATEPART('ss','1999-02-20 03:20') AS Seconds
FROM Sample.Person

SELECT DISTINCT DATEPART('ss','1999-02-20') AS Seconds
FROM Sample.Person
The following examples return the full SQL timestamp as a character string of
data type TIMESTAMP. In the first of these examples, DATEPART fills in the
missing time information to return a timestamp of '2004-02-25 00:00:00':

SELECT DISTINCT DATEPART('sts','2/25/2004') AS DTStamp
FROM Sample.Person
The following example supplies a date and time in $HOROLOG format, and returns
a timestamp of '2004-02-25 06:30:56':

SELECT DISTINCT DATEPART('sts','59590,23456') AS DTStamp
FROM Sample.Person
The following example returns the day number of the DOB field.

SELECT DOB,DATEPART('dd',DOB) AS DatePt
FROM Sample.Person
For example, if DOB is 05/12/1950 the DATEPART is 12.
See Also
DATEDIFF DATENAME TIMESTAMPADD TIMESTAMPDIFF TO_DATE

 #}}}
*DAY*  #{{{

A date/time function that returns an integer from 1 to 31 that corresponds to
the day of the month in a given date expression.
Synopsis

DAY(date-expression)
{fn DAY(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
Note:
The DAY function is an alias for the DAYOFMONTH function. DAY is provided for
TSQL compatibility. Refer to DAYOFMONTH for further details.
See Also

  • DAYOFMONTH


 #}}}
*DAYNAME*  #{{{

A date function that returns a string containing the name of the day for a
given date.
Synopsis

{fn DAYNAME(date-expression)}

Arguments

                 An expression that evaluates to either a Caché date integer,
date-expression  an ODBC date, or a timestamp. This expression can be the name
                 of a column, the result of another scalar function, or a date
                 or timestamp literal.

Description
DAYNAME returns the name of the day that corresponds to a specified date. The
returned value is a character string. The default day names returned are:
Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday.
To change these default day name values, use the SET OPTION command with the
WEEKDAY_NAME option.
The day name is calculated for a Caché date integer, an ODBC format date
string, or a timestamp string with the format:

yyyy-mm-dd hh:mm:ss

The time portion of the timestamp is not evaluated and can be omitted.
DAYNAME checks that the date supplied is a valid date. The year must be between
1841 and 9999 (inclusive), the month 01 through 12, and the day appropriate for
that month (for example, 02/29 is only valid on leap years). If the date is not
valid, DAYNAME sets SQLCODE = -400 (fatal error occurred).
The same day of week information can be returned by using the DATENAME
function. You can use TO_DATE to retrieve a day name or day name abbreviation
with other date elements. To return an integer corresponding to the day of the
week, use DAYOFWEEK DATEPART or TO_DATE.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.DAYNAME(date-expression)
Examples
The following examples both return the character string Wednesday because the
day of the date (February 25, 2004) is a Wednesday. The first example takes a
timestamp string:

SELECT DISTINCT {fn DAYNAME('2004-02-25 12:35:46')} AS Weekday
FROM Sample.Person
The second example takes a Caché date integer:

SELECT DISTINCT {fn DAYNAME(59590)} AS Weekday
FROM sample.person
The following examples return the name of the current day of the week:

SELECT DISTINCT {fn DAYNAME({fn NOW()})} AS Weekday_Now
FROM Sample.Person

SELECT DISTINCT {fn DAYNAME(CURRENT_DATE)} AS Weekday_Now
FROM Sample.Person

SELECT DISTINCT {fn DAYNAME(CURRENT_TIMESTAMP)} AS Weekday_Now
FROM Sample.Person
The following embedded SQL example shows how DAYNAME responds to an invalid
date (the year 2001 was not a leap year):

   SET testdate="2001-02-29"
   &sql(SELECT {fn DAYNAME(:testdate)} AS NameOfMonth
   INTO :a
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"returns: ",a }
   QUIT
The following embedded SQL example shows how DAYNAME responds to an invalid
date (the year 1835 is too early for Caché SQL):

   SET testdate="1835-02-19"
   &sql(SELECT {fn DAYNAME(:testdate)} AS NameOfMonth
   INTO :a
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"returns: ",a }
   QUIT
See Also

  • SQL functions: DATENAME DATEPART DAYOFMONTH DAYOFWEEK DAYOFYEAR TO_DATE
  • Caché ObjectScript function: $ZDATE


 #}}}
*DAYOFMONTH*  #{{{

A scalar date/time function that returns an integer from 1 to 31 that
corresponds to the day of the month in a given date expression.
Synopsis

{fn DAYOFMONTH(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
DAYOFMONTH takes a date integer or datetime string. A datetime string is of the
format:

yyyy-mm-dd hh:mm:ss

DAYOFMONTH returns the day of the month as an integer.
The day (dd) portion of a datetime string should be an integer in the range
from 1 through 31. There is, however, no range checking for user-supplied
values. Numbers greater than 31 and fractions are returned as specified.
Because ( ) is used as a separator character, negative numbers are not
supported. Leading zeros are optional on input; leading zeros are suppressed on
output.
DAYOFMONTH returns NULL when the day portion is '0', '00', or a nonnumeric
value. NULL is also returned if the day portion of the date string is omitted
entirely ('yyyy mm hh:mm:ss'), or if no date expression is supplied.
Note:
The DAYOFMONTH and DAY functions are functionally identical.
The LAST_DAY function returns the date of the last day of the specified month.
The elements of a datetime string can be returned using the following SQL
scalar functions: YEAR, MONTH, DAYOFMONTH (or DAY), HOUR, MINUTE, SECOND. The
same elements can be returned by using the DATEPART or DATENAME function. 
DATEPART and DATENAME performs value and range checking on day values.
This function can also be invoked from Caché ObjectScript using the following
method call:

  WRITE $SYSTEM.SQL.DAYOFMONTH("2004-02-25")
Examples
The following examples return the number 25 because the date specified is the
twenty-fifth day of the month:

SELECT DISTINCT {fn DAYOFMONTH('2004-02-25')} AS DayNum
FROM Sample.Person

SELECT DISTINCT {fn DAYOFMONTH(59590)} AS DayNum
FROM Sample.Person
The following example also returns the number 25 for the day of the month. The
year is omitted, but the separator character ( ) serves as a placeholder:

SELECT DISTINCT {fn DAYOFMONTH('-02-25 11:45:32')} AS DayNum
FROM Sample.Person
The following examples return <null>:

SELECT DISTINCT {fn DAYOFMONTH('2000-02-00 11:45:32')} AS DayNum
FROM sample.person

SELECT DISTINCT {fn DAYOFMONTH('2000-02 11:45:32')} AS DayNum
FROM sample.person

SELECT DISTINCT {fn DAYOFMONTH('11:45:32')} AS DayNum
FROM sample.person
The following DAYOFMONTH examples returns the current day:

SELECT DISTINCT {fn DAYOFMONTH({fn NOW()})} AS Day_Now1,
                {fn DAYOFMONTH(CURRENT_DATE)} AS Day_Now2,
                {fn DAYOFMONTH(CURRENT_TIMESTAMP)} AS Day_Now3
FROM Sample.Person
The following example shows that leading zeros are suppressed. It returns a
length of either 1 or 2, depending on the day of the month value:

SELECT DISTINCT LENGTH({fn DAYOFMONTH('2004-02-05')}),
                LENGTH({fn DAYOFMONTH('2004-02-15')})
FROM Sample.Person
See Also

  • SQL functions: DATENAME DATEPART DAY DAYNAME DAYOFWEEK DAYOFYEAR LAST_DAY
    MONTH TO_DATE
  • Caché ObjectScript function: $ZDATE


 #}}}
*DAYOFWEEK*  #{{{

A scalar date/time function that returns an integer from 1 to 7 that
corresponds to the day of the week in a given date expression.
Synopsis

{fn DAYOFWEEK(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
DAYOFWEEK takes a date integer or a datetime string and returns an integer
corresponding to the day of the week for that date. The returned values
represent these days:

  • 1  Sunday
  • 2  Monday
  • 3  Tuesday
  • 4  Wednesday
  • 5  Thursday
  • 6  Friday
  • 7  Saturday

A datetime string is of the format:

yyyy-mm-dd hh:mm:ss

The same day of week information can be returned by using the DATEPART or
TO_DATE function. To return the name of the day of the week, use DAYNAME,
DATENAME, or TO_DATE.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.DAYOFWEEK(date-expression)
Date Validation
DAYOFWEEK performs the following checks on input values. If a value fails a
check, the null string is returned.

  • A valid date-expression may consist of a date string (yyyy-mm-dd) or a date
    and time string (yyyy-mm-dd hh:mm:ss). DAYOFWEEK evaluates only the date
    portion of the string.
  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. Years must be specified as four digits.
  • Date values must be within a valid range. Years: 1841 through 9999. Months:
    1 through 12. Days: 1 though 31.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Date values less than 10 may include or omit a leading zero. Other
    non-canonical integer values are not permitted. Therefore, a Day value of
    '07' or '7' is valid, but '007', '7.0' or '7a' are not valid.

Examples
The following examples both return the number 4 because the day in the date
expression (February 25, 2004) is a Wednesday:

SELECT DISTINCT {fn DAYOFWEEK('2004-02-25')} AS Weekday
FROM Sample.Person

SELECT DISTINCT {fn DAYOFWEEK(59590)} AS Weekday
FROM Sample.Person
The following examples return the integer corresponding to the current day of
the week:

SELECT DISTINCT {fn DAYOFWEEK({fn NOW()})} AS Weekday_Now
FROM Sample.Person

SELECT DISTINCT {fn DAYOFWEEK(CURRENT_DATE)} AS Weekday_Now
FROM Sample.Person

SELECT DISTINCT {fn DAYOFWEEK(CURRENT_TIMESTAMP)} AS Weekday_Now
FROM Sample.Person
See Also

  • SQL functions: DATENAME DATEPART DAYNAME DAYOFMONTH DAYOFYEAR TO_DATE
  • Caché ObjectScript function: $ZDATE


 #}}}
*DAYOFYEAR*  #{{{

A scalar date/time function that returns an integer that corresponds to the day
of the year in a given date expression.
Synopsis

{fn DAYOFYEAR(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
DAYOFYEAR returns an integer from 1 to 366 that corresponds to the day of the
year for a given date expression. DAYOFYEAR calculates leap year dates.
A date expression can be a date integer or a datetime string. A datetime string
is of the format:

yyyy-mm-dd hh:mm:ss

For Caché compatibility, the year (yyyy) portion should be a four-digit integer
in the range 1840 through 9999. DAYOFYEAR does not perform range checking for
user-supplied values. Two-digit years are permissible here. If the year is
omitted, DAYOFYEAR makes a leap year assumption (see Examples) and calculates
the day accordingly. If the day is omitted, DAYOFYEAR counts the day as zero (1
less than the first day of the month).
The same day count can be returned by using the DATEPART or DATENAME function. 
DATEPART and DATENAME performs value and range checking on date expressions.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.DAYOFYEAR(date-expression)
Examples
The following examples both return the number 64 because the day in the date
expression (March 4, 2004) is the 64th day of the year (the leap year day is
automatically counted):

SELECT DISTINCT {fn DAYOFYEAR('2004-03-04 12:45:37')} AS DayCount
FROM Sample.Person

SELECT DISTINCT {fn DAYOFYEAR(59598)} AS DayCount
FROM Sample.Person
The following examples both omit the year field value. However, note that they
return different values. The first example has a date separator to indicate the
missing year value. It returns the number 63 because the missing year is
assumed to not be a leap year:

SELECT DISTINCT {fn DAYOFYEAR('-03-04')} AS DayCount
FROM Sample.Person
The second example has a nonnumeric placeholder before the date separator to
indicate the missing year value. It returns the number 64 because this
nonnumeric placeholder is assumed to indicate a leap year:

SELECT DISTINCT {fn DAYOFYEAR('*-03-04')} AS DayCount
FROM Sample.Person
The following example returns the number 304 because the day field is omitted,
and is assumed to be day 0 of the specified month, as shown by the example
following it:

SELECT DISTINCT {fn DAYOFYEAR('2003-11')} AS DayCount
FROM Sample.Person

SELECT DISTINCT {fn DAYOFYEAR('2003-11-00')} AS DayCount
FROM Sample.Person
The following examples return the count for the current day:

SELECT DISTINCT {fn DAYOFYEAR({fn NOW()})} AS DayCount_Now
FROM Sample.Person

SELECT DISTINCT {fn DAYOFYEAR(CURRENT_DATE)} AS DayCount_Now
FROM Sample.Person

SELECT DISTINCT {fn DAYOFYEAR(CURRENT_TIMESTAMP)} AS DayCount_Now
FROM Sample.Person
See Also
DATEPART DATENAME DAYNAME DAYOFMONTH DAYOFWEEK

 #}}}
*DECLARE*  #{{{

Declares a cursor.
Synopsis

DECLARE cursor-name CURSOR FOR query
      FOR READ ONLY

DECLARE cursor-name CURSOR FOR query
      FOR UPDATE

Arguments

             The name of the cursor, which must begin with a letter and contain
cursor-name  only letters and numbers. (Cursor names do not follow SQL
             identifier conventions). Cursor names are case-sensitive. They are
             subject to additional naming restrictions, as described below.

query        A standard SELECT statement that defines the result set of the
             cursor.

FOR READ     Optional  Prevents updates from being made through this cursor.
ONLY         The cursor cannot be referenced in a WHERE CURRENT OF clause in an
             UPDATE or DELETE statement.

             Optional  The default behavior is to allow updates to be made
FOR UPDATE   through the cursor. Specifying this explicitly with FOR UPDATE is
             provided for compatibility only. It performs no operation.

Description
A DECLARE statement specifies information about a cursor that is to be used in
a subsequent OPEN statement.
By default, updates can be performed through the cursor. Updating through the
cursor cannot be performed if you specify FOR READ ONLY, if the query specifies
ordering with an ORDER BY statement, or the query is otherwise not subject to
updating.
As an SQL statement, DECLARE is only supported from embedded SQL. For Dynamic
SQL, use instead either a simple SELECT statement (with no INTO clause), or a
combination of Dynamic SQL and embedded SQL. Equivalent operations are
supported through ODBC using the ODBC API.
Because DECLARE is a declaration, not an executed statement, it does not set or
kill the SQLCODE variable.
Cursor Names
A cursor name must be unique within the routine and the corresponding class. A
cursor name may be of any length, but must be unique within the first 29
characters. Cursor names are case-sensitive. Attempting to declare two cursors
with the same name results in an error code -52 during compilation.
The first character of a cursor name must be a letter. The second and
subsequent characters of a cursor name must be either a letter or a number.
Unlike SQL identifiers, punctuation characters are not permitted in cursor
names.
You can use a delimiter characters (double quotes) to specify an SQL reserved
word as a cursor name. A delimited cursor name is not an SQL delimited
identifier; delimited cursor names are still case-sensitive and cannot contain
punctuation characters. In most cases, an SQL reserved word should not be used
as a cursor name.
Examples
The following embedded SQL example shows a cursor (named EmpCursor) being
declared, then opened, fetched, and closed:

   SET name="John Doe",state="##"
   &sql(DECLARE EmpCursor CURSOR FOR
        SELECT Name, Home_State
        INTO :name,:state FROM Sample.Person
        WHERE Home_State %STARTSWITH 'A'
        FOR READ ONLY)
     WRITE !,"BEFORE: Name=",name," State=",state
   &sql(OPEN EmpCursor)
   NEW SQLCODE,%ROWCOUNT,%ROWID
   FOR { &sql(FETCH EmpCursor)
        QUIT:SQLCODE
        WRITE !,"DURING: Name=",name," State=",state }
   WRITE !,"FETCH status SQLCODE=",SQLCODE
   WRITE !,"Number of rows fetched=",%ROWCOUNT
   &sql(CLOSE EmpCursor)
   WRITE !,"AFTER: Name=",name," State=",state
The following embedded SQL example uses DECLARE to set the CURSOR EmpCursor to
include the first and last names of all employees who have a zip code equal to
the value of the EmpZipCode variable.

   NEW EmpLast,EmpFirst,EmpZipCode
   NEW SQLCODE,%ROWCOUNT,%ROWID
    &sql(DECLARE EmpCursor CURSOR FOR
     SELECT LastName,FirstName
     INTO :EmpLast,:EmpFirst
     FROM EmpTable where ZipCode = :EmpZipCode)
     SET EmpZipCode="02142"
      &sql(OPEN EmpCursor)
   IF (SQLCODE) {
     WRITE SQLCODE,!
     QUIT
     }
  SET SQLCODE = 0
  WHILE (SQLCODE = 0) {
   &sql(FETCH EmpCursor)
   WRITE !,EmpLast," ",EmpFirst
  }
  &sql(CLOSE EmpCursor)
  QUIT

See Also

  • CLOSE FETCH OPEN WHERE CURRENT OF
  • SQL Cursors in the  Using Embedded SQL chapter of Using Caché SQL


 #}}}
*DECODE*  #{{{

A function that evaluates a given expression and returns a specified value.
Synopsis

DECODE(expr {,search,result}[,default])

Arguments

expr     The expression to be decoded.

search   The value to which expr is compared.

result   The value which is returned if expr matches search.

default  Optional  The default value which is returned if expr does not match
         any search.

Description
You can specify multiple search,result pairs, separated by commas. You can
specify one default. The maximum number of parameters in the DECODE expression
(including expr, search, result, and default) is about 100. The search, result,
and default values can be derived from expressions.
To evaluate a DECODE expression, Caché compares expr to each search value, one
by one:

  • If expr is equal to a search value, the corresponding result is returned.
  • If expr is not equal to any search value, the default value is returned,
    or, if default is omitted, null is returned.

Caché evaluates each search value only before comparing it to expr, rather than
evaluating all search values before comparing any of them to expr. Therefore,
Caché never evaluates a search if a previous search is equal to expr.
DECODE returns the data type of the first result argument. If the data type of
the first result argument cannot be determined, DECODE returns VARCHAR.
In a DECODE expression, Caché considers two nulls to be equivalent. If expr is
null, Caché returns the result of the first search that is also null.
Note that DECODE is supported for Oracle compatibility.
Examples
The following example  decodes ages from 13 through 19 as 'Teen'; the default
is 'Adult':

SELECT Age,Name,DECODE(Age,
       13,'Teen',14,'Teen',15,'Teen',16,'Teen',
       17,'Teen',18,'Teen',19,'Teen',
       'Adult') AS AgeBracket
FROM Sample.Person
ORDER BY Age
The following example decodes the numeric code in the Company code field in
Employee records and returns the corresponding department name. If an
employee’s Company code is not 1 through 10, DECODE returns the default of  
Admin (non-tech) :

SELECT Name,
DECODE (Company,
   1, 'TECH MARKETING', 2, 'TECH SALES', 3, 'DOCUMENTATION',
   4, 'BASIC RESEARCH', 5, 'SOFTWARE DEVELOPMENT', 6, 'HARDWARE DEVELOPMENT',
   7, 'QUALITY TESTING', 8, 'FIELD SUPPORT', 9, 'PHONE SUPPORT',
   10, 'TECH TRAINING',
       'Admin (non-tech)') AS TechJobs
FROM Sample.Employee
The expression has Company as the expr parameter and uses ten pairs of search
and result parameters. "Admin (non-tech)" is the default parameter.
See Also
CASE

 #}}}
*$EXTRACT_sql*  #{{{

A string function that extracts characters from a string by position.
Synopsis

$EXTRACT(string[,from[,to]])

Arguments

string  The target string from which the substring is to be extracted.

        Optional  The position within the target string for a single character,
from    or the beginning of a range of characters (inclusive), to be extracted.
        Specified as a positive integer counting from 1.

to      Optional  The end position (inclusive) for a range of characters to be
        extracted. Specified as a positive integer counting from 1.

Description
$EXTRACT returns a substring from a specified position in string. The nature of
the substring returned depends on the arguments used.

  • $EXTRACT(string) extracts the first character in the string.
  • $EXTRACT(string,from) extracts the character in the position specified by 
    from. For example, if variable var1 contains the string  ABCD , the
    following command extracts  B (the second character):
   
    SELECT DISTINCT $EXTRACT('ABCD',2) AS Extracted
        FROM Sample.Person
  • $EXTRACT(string,from,to) extracts the range of characters starting with the
    from position and ending with the to position. For example, the following
    command extracts the string  Alabama (that is, all characters from position
    5 to position 11, inclusive) from the string  1234Alabama567 :
   
    SELECT DISTINCT $EXTRACT('1234Alabama567',5,11) AS Extracted
        FROM Sample.Person

This function returns data of type VARCHAR.
Arguments
string
The string value can be a variable name, a numeric value, a string literal, or
any valid expression.
from
The from value must be a positive integer (however, see Note). If a fractional
number, the fraction is truncated and only the integer portion is used.
If the from value is greater than the number of characters in the string, 
$EXTRACT returns a null string.
If from is specified without the to argument, it extracts the single specified
character.
If used with the to argument, it identifies the start of the range to be
extracted and must be less than the value of to. If from equals to, $EXTRACT
returns the single character at the specified position. If from is greater than
to, $EXTRACT returns a null string.
to
The to argument must be used with the from argument. It must be a positive
integer. If a fractional number, the fraction is truncated and only the integer
portion is used.
If the to value is greater than or equal to the from value, $EXTRACT returns
the specified substring. If to is greater than the length of the string, 
$EXTRACT returns the substring from the from position to the end of the string.
If to is less than from, $EXTRACT returns a null string.
Examples
The following example returns  S , the fourth character in the string:

SELECT DISTINCT $EXTRACT('THIS IS A TEST',4) AS Extracted
    FROM Sample.Person
The following example returns a substring  THIS IS which is composed of the
first through seventh characters.

SELECT DISTINCT $EXTRACT('THIS IS A TEST',1,7) AS Extracted
    FROM Sample.Person
The following embedded SQL example extracts the second character ( B ) from a
and assigns this value to variable y.

   SET a="ABCD"
   &sql(SELECT $EXTRACT(:a,2)
   INTO :y
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The extract returns ",y }
The following embedded SQL example shows that the one-argument format is
equivalent to the two-argument format when the from value is  1 . Both $EXTRACT
functions return  H .

   SET a="HELLO"
   &sql(SELECT $EXTRACT(:a),$EXTRACT(:a,1)
   INTO :b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The one-arg form returns ",b
     WRITE !,"The two-arg form returns ",c }
Notes
$EXTRACT Compared with $PIECE and $LIST
$EXTRACT returns a substring of characters by integer position from a string. 
$PIECE and $LIST both work on specially formatted strings.
$PIECE returns a substring from a standard character string using delimiter
characters within the string.
$LIST returns a sublist of elements from an encoded list by the integer
position of elements (not characters). $LIST cannot be used on ordinary
strings, and $EXTRACT cannot be used on encoded lists.
The $EXTRACT, $FIND, $LENGTH, and $PIECE functions operate on standard
character strings. The various $LIST functions operate on encoded character
strings, which are incompatible with standard character strings. The only
exceptions are the $LISTGET function and the one-argument and two-argument
forms of $LIST, which take an encoded character string as input, but output a
single element value as a standard character string.
$EXTRACT and Unicode
The $EXTRACT function operates on characters, not bytes. Therefore, Unicode
strings are handled the same as ASCII strings, as shown in the following
embedded SQL example using the Unicode character for  pi ($CHAR(960)):

   SET a="QT PIE"
   SET b=("QT "_$CHAR(960))
   &sql(SELECT
   $EXTRACT(:a,-33,4),
   $EXTRACT(:a,4,4),
   $EXTRACT(:a,4,99),
   $EXTRACT(:b,-33,4),
   $EXTRACT(:b,4,4),
   $EXTRACT(:b,4,99)
   INTO :a1,:a2,:a3,:b1,:b2,:b3
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"ASCII form returns ",!,a1,!,a2,!,a3
     WRITE !,"Unicode form returns ",!,b1,!,b2,!,b3 }
Null and Invalid Arguments

  • When string is a null string, a null string is returned.
  • When from is a number larger than the string length, a null string is
    returned.
  • When from is zero or a negative number, and no to is specified, a null
    string is returned.
  • When to is zero, a negative number, or a number smaller than from, a null
    string is returned.
  • When to is a valid value, from can be zero or a negative number. $EXTRACT
    treats such from values as 1.

No SQLCODE error is returned for invalid argument values.
In following example, the negative from value is evaluated as 1; $EXTRACT
returns the substring  THIS IS composed of the first through seventh
characters.

SELECT DISTINCT $EXTRACT('THIS IS A TEST',-7,7)
    FROM Sample.Person
In following embedded SQL example, all $EXTRACT function calls return the null
string:

   SET a="THIS IS A TEST"
   SET b=""
   &sql(SELECT
   $EXTRACT(:a,33),
   $EXTRACT(:a,-7),
   $EXTRACT(:a,3,2),
   $EXTRACT(:a,-7,0),
   $EXTRACT(:a,-7,-10),
   $EXTRACT(:b,-33,4),
   $EXTRACT(:b,4,4),
   $EXTRACT(:b,4,99),
   $EXTRACT(NULL,-33,4),
   $EXTRACT(NULL,4,4),
   $EXTRACT(NULL,4,99)
   INTO :a1,:a2,:a3,:a4,:a5,:b1,:b2,:b3,:c1,:c2,:c3
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"FROM too big: ",a1
     WRITE !,"FROM negative, no TO: ",a2
     WRITE !,"TO smaller than FROM: ",a3
     WRITE !,"TO not a positive integer: ",a4,a5
     WRITE !,"LIST is null string: ",b1,b2,b3,c1,c2,c3 }
See Also

  • SQL functions: $FIND $LENGTH $LIST $LISTGET $PIECE
  • Caché ObjectScript functions: $EXTRACT $FIND $LENGTH $LIST $LISTBUILD
    $LISTGET $PIECE


 #}}}
*$FIND_sql*  #{{{

A string function that finds a substring by value and returns its end position.
Synopsis

$FIND(string,substring[,start])

Arguments

string     The target string that is to be searched. It can be a variable name,
           a numeric value, a string literal, or any valid expression.

substring  The substring that is to be searched for. It can be a variable name,
           a numeric value, a string literal, or any valid expression.

start      Optional  A position within the target string at which to start the
           search. It must be a positive integer.

Description
$FIND returns an integer specifying the end position of a substring within a
string. $FIND searches string for substring. If substring is found, $FIND
returns the integer position of the first character following substring. If 
substring is not found, $FIND returns a value of 0.
You can include the start option to specify a starting position for the search.
If start is greater than the number of characters in string, $FIND returns a
value of 0. If start is omitted, string position 1 is the default. If start is
zero, a negative number, or a nonnumeric string, position 1 is the default.
This function returns data of type SMALLINT.
CHARINDEX and $FIND
Both CHARINDEX and $FIND search a string for a specified substring and return
the first match. CHARINDEX returns the integer position of the first character
of the matching substring. $FIND returns the integer position of the first
character after the end of the matching substring.
For a list of functions that search for a substring, refer to String
Manipulation in the Concepts section of this manual.
Examples
In the following example, string contains the string  ABCDEFG and substring
contains the string  BCD . The $FIND function returns the value 5, indicating
the position of the character ( E ) that follows  BCD :

SELECT DISTINCT $FIND('ABCDEG','BCD') AS SubPoint
FROM Sample.Person
The following example searches the numeric 987654321 for the number 7. It
returns 4, the position following the substring:

SELECT DISTINCT $FIND(987654321,7) AS SubPoint
FROM Sample.Person
The following example returns 3, the position of the character that follow the
first instance of the substring  AA :

SELECT DISTINCT $FIND('AAAAAA','AA') AS SubPoint
FROM Sample.Person
In the following example, $FIND searches for a substring that is not in the
string. It returns zero (0):

SELECT DISTINCT $FIND('AABBCCDD','AC') AS SubPoint
FROM Sample.Person
In the following example, $FIND begins its search with the seventh character.
This example returns 14, the position of the character that follows the next
occurrence of  R :

SELECT DISTINCT $FIND('EVERGREEN FOREST','R',7) AS SubPoint
FROM Sample.Person
In the following example, $FIND begins its search after the last character in
string. It returns zero (0):

SELECT DISTINCT $FIND('ABCDEFG','G',10) AS SubPoint
FROM Sample.Person
The following embedded SQL example shows that a start less than 1 is treated as
1:

   SET a="ABCDEFG"
   SET b="F"
   &sql(SELECT
    $FIND(:a,:b),
    $FIND(:a,:b,1),
    $FIND(:a,:b,0),
    $FIND(:a,:b,-35)
   INTO :a1,:a2,:a3,:a4
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The input string: ",a
     WRITE !,"Two-arg: ",a1
     WRITE !,"3rd arg 1: ",a2
     WRITE !,"3rd arg 0: ",a3
     WRITE !,"3rd arg negative: ",a4 }
The following embedded SQL example uses $FIND to search a string containing the
Unicode character for pi, $CHAR(960). The first $FIND returns 5, the character
following pi. The second $FIND also returns 5; it begins its search at
character 4, which happens to be pi, the character sought. The third $FIND
begins its search at character 5; it returns 13, the position following the
next occurrence of pi. Note that position 13 is returned, even though position
12 is the last character in the string:

   SET a="QT "_$CHAR(960)_" HONEY "_$CHAR(960)
   SET b=$CHAR(960)
   &sql(SELECT
    $FIND(:a,:b),
    $FIND(:a,:b,4),
    $FIND(:a,:b,5)
   INTO :a1,:a2,:a3
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The input string: ",a
     WRITE !,"From beginning: ",a1
     WRITE !,"From position 4: ",a2
     WRITE !,"From position 5: ",a3 }
See Also

  • SQL functions: CHARINDEX $EXTRACT $LENGTH $LIST $LISTGET $PIECE
  • String Manipulation
  • Caché ObjectScript functions: $EXTRACT $FIND $LENGTH $LIST $LISTBUILD
    $LISTGET $PIECE


 #}}}
*$LENGTH_sql*  #{{{

A string function that returns the number of characters or the number of
delimited substrings in a string.
Synopsis

$LENGTH(expression[,delimiter])

Arguments

expression  The target string. It can be a numeric value, a string literal, the
            name of any variable, or any valid expression.

            Optional  A string that demarcates separate substrings in the
delimiter   target string. It must be a string literal, but can be of any
            length. The enclosing quotation marks are required.

Description
$LENGTH returns the number of characters in a specified string or the number of
substrings in a specified string, depending on the arguments used.

  • $LENGTH(expression) returns the number of characters in the string. If the
    expression is a null string, $LENGTH returns a 0.
  • $LENGTH(expression,delimiter) returns the number of substrings within the
    string. $LENGTH returns the number of substrings separated from one another
    by the indicated delimiter. This number is always equal to the number of
    delimiters in the string, plus one.
    If the delimiter is the null string, $LENGTH returns a 0. If the delimiter
    is any other valid string literal and the string is a null string, $LENGTH
    returns a 1.

This function returns data of type SMALLINT.
Examples
The following example returns 6, the length of the string:

SELECT DISTINCT $LENGTH('ABCDEG') AS StringLength
FROM Sample.Person
The following example returns 3, the number of substrings within the string, as
delimited by the dollar sign ($) character.

SELECT DISTINCT $LENGTH('ABC$DEF$EFG','$') AS SubStrings
FROM Sample.Person
If the specified delimiter is not found in the string $LENGTH returns 1,
because the only substring is the string itself:

SELECT DISTINCT $LENGTH('ABCDEG','$') AS SubStrings
FROM Sample.Person
In the following embedded SQL example, the first $LENGTH function returns 11,
the number of characters in a (including, of course, the space character). The
second $LENGTH function returns 2, the number of substrings in a using b, the
space character, as the substring delimiter.

   SET a="HELLO WORLD"
   SET b=" "
   &sql(SELECT
   $LENGTH(:a),
   $LENGTH(:a,:b)
   INTO :a1,:a2
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The input string: ",a
     WRITE !,"Number of characters: ",a1
     WRITE !,"Number of substrings: ",a2 }
The following example returns 0 because the string tested is the null string:

SELECT DISTINCT $LENGTH(NULL) AS StringLength
FROM Sample.Person
The following example returns 1 because a delimiter is specified and not found.
There is one substring, which is the null string:

SELECT DISTINCT $LENGTH(NULL,'$') AS SubStrings
FROM Sample.Person
The following example returns 0 because the delimiter is the null string:

SELECT DISTINCT $LENGTH('ABCDEFG',NULL) AS SubStrings
FROM Sample.Person
Notes
$LENGTH, $PIECE, and $LIST

  • $LENGTH with one argument returns the number of characters in a string.
    This function can be used with the $EXTRACT function, which locates a
    substring by position and returns the substring value.
  • $LENGTH with two arguments returns the number of substrings in a string,
    based on a delimiter. This function can be used with the $PIECE function,
    which locates a substring by a delimiter and returns the substring value.
  • $LENGTH should not be used on encoded lists created using $LISTBUILD or 
    $LIST. Use $LISTLENGTH to determine the number of substrings (list
    elements) in an encoded list string.

The $LENGTH, $FIND, $EXTRACT, and $PIECE functions operate on standard
character strings. The various $LIST functions operate on encoded character
strings, which are incompatible with standard character strings. The only
exceptions are the $LISTGET function and the one-argument and two-argument
forms of $LIST, which take an encoded character string as input, but output a
single element value as a standard character string.
See Also

  • SQL functions: $EXTRACT $FIND $LIST $LISTGET $PIECE
  • Caché ObjectScript functions: $EXTRACT $FIND $LENGTH $LIST $LISTBUILD
    $LISTGET $PIECE


 #}}}
*$LISTBUILD_sql*  #{{{

A list function that builds a list from strings.
Synopsis

$LISTBUILD(element,...)

Parameter

element  Any expression, or comma-separated list of expressions.

Description
$LISTBUILD takes one or more expressions and returns a list with one element
for each expression.
The following functions can be used to create a list:

  • $LISTBUILD, which creates a list from multiple strings, one string per
    element.
  • $LISTFROMSTRING, which creates a list from a single string containing
    multiple delimited elements.
  • $LIST, which extracts a sublist from an existing list.

$LISTBUILD is used with the other Caché SQL list functions: $LIST, $LISTDATA, 
$LISTFIND, $LISTFROMSTRING, $LISTGET, $LISTLENGTH, and $LISTTOSTRING.
Note:
$LISTBUILD and the other $LIST functions use an optimized binary representation
to store data elements. For this reason, equivalency tests may not work as
expected with some $LIST data. Data that might, in other contexts, be
considered equivalent, may have a different internal representation. For
example, $LISTBUILD(1) is not equal to $LISTBUILD("1").
For the same reason, a list string value returned by $LISTBUILD should not be
used in character search and parse functions that use a delimiter character,
such as $PIECE and the two-argument form of $LENGTH. Elements in a list created
by $LISTBUILD are not marked by a character delimiter, and thus can contain any
character.
Examples
The following Embedded SQL example takes three strings and produces a
three-element list:

  SET x="Red"
  SET y="White"
  SET z="Blue"
  &sql(SELECT $LISTBUILD(:x,:y,:z)
       INTO :listout
       FROM Sample.Person)
  IF SQLCODE=0 {WRITE listout}
  ELSE {WRITE "Error code:",SQLCODE}
Notes
Omitting Parameters
Omitting an element expression yields an element whose value is NULL. For
example, the following Embedded SQL contains two $LISTBUILD statements that
both produce a three-element list whose second element has an undefined (NULL)
value:

  SET x="Red"
  SET y="White"
  SET z="Blue"
  &sql(SELECT $LISTBUILD(:x,,:z),
              $LISTBUILD(:x,'',:z)
       INTO :list1,list2
       FROM Sample.Person)
  IF SQLCODE=0 {WRITE list1,!,list2}
  ELSE {WRITE "Error code:",SQLCODE}
Additionally, if a $LISTBUILD expression is undefined, the corresponding list
element has an undefined value. The following Embedded SQL example produces a
two-element list whose first element is "Red" and whose second element has an
undefined value:

  &sql(SELECT $LISTBUILD('Red',:z)
       INTO :list1
       FROM Sample.Person)
  IF SQLCODE=0 {WRITE list1}
  ELSE {WRITE "Error code:",SQLCODE}
However, the following Embedded SQL example produces a one-element list. The
trailing comma is not taken to indicate a NULL expression:

  &sql(SELECT $LISTBUILD('Red',)
       INTO :list1
       FROM Sample.Person)
  IF SQLCODE=0 {WRITE list1}
  ELSE {WRITE "Error code:",SQLCODE}
Providing No Parameters
Invoking the $LISTBUILD function with no parameters returns a list with one
element whose data value is undefined. This is not the same as NULL. The
following are valid $LISTBUILD statements that create  empty lists:

  &sql(SELECT $LISTBUILD(),
              $LISTBUILD(NULL)
       INTO :list1,:list2
       FROM Sample.Person)
  IF SQLCODE=0 {
     ZZDUMP list1
     ZZDUMP list2
  }
  ELSE {WRITE "Error code:",SQLCODE}
The following are valid $LISTBUILD statements that create a list element that
contains an empty string:

  &sql(SELECT $LISTBUILD(''),
              $LISTBUILD(CHAR(0))
       INTO :list1,:list2
       FROM Sample.Person)
  IF SQLCODE=0 {
     ZZDUMP list1
     ZZDUMP list2
  }
  ELSE {WRITE "Error code:",SQLCODE}
Nesting Lists
An element of a list may itself be a list. For example, the following statement
produces a three-element list whose third element is the two-element list,
"Walnut,Pecan":

SELECT DISTINCT
$LISTBUILD('Apple','Pear',$LISTBUILD('Walnut','Pecan'))
FROM Sample.Person
Concatenating Lists
The result of concatenating two lists with the SQL Concatenate operator (||) is
another list. For example, the following SELECT items produce the same list,
"A,B,C":

SELECT DISTINCT
  $LISTBUILD('A','B','C') AS List,
  $LISTBUILD('A','B')||$LISTBUILD('C') AS CatList
FROM Sample.Person
In the following example, the first two select items result in the same
two-element list; the third select item results in NULL (because concatenating
NULL to anything results in NULL); the fourth and fifth select items result in
the same three-element list:

SELECT DISTINCT
  $LISTBUILD('A','B') AS List,
  $LISTBUILD('A','B')||'' AS CatEStr,
  $LISTBUILD('A','B')||NULL AS CatNull,
  $LISTBUILD('A','B')||$LISTBUILD('') AS CatEList,
  $LISTBUILD('A','B')||$LISTBUILD(NULL) AS CatNList
FROM Sample.Person
Unicode
If one or more characters in a list element is a wide (Unicode) character, all
characters in that element are represented as wide characters. To ensure
compatibility across systems, $LISTBUILD always stores these bytes in
little-endian order, regardless of the hardware platform. Wide characters are
represented as byte strings. For further details, refer to the Caché
ObjectScript $LISTBUILD function in the Caché ObjectScript Reference.
See Also

  • SQL functions: $LIST $LISTDATA $LISTFIND $LISTFROMSTRING $LISTGET
    $LISTLENGTH $LISTTOSTRING $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$LISTDATA_sql*  #{{{

A list function that indicates whether the specified element exists and has a
data value.
Synopsis

$LISTDATA(list[,position])

Arguments

list      An expression that evaluates to a valid list.

position  Optional  An integer expression specifying an element in list.

Description
$LISTDATA checks for data in the requested element in a list. $LISTDATA returns
a value of 1 if the element indicated by the position argument is in the list
and has a data value. $LISTDATA returns a value of a 0 if the element is not in
the list or does not have a data value.
This function returns data of type SMALLINT.
Arguments
list
A list is an encoded character string, created using the Caché ObjectScript 
$LISTBUILD function, or extracted from an existing list using the SQL or Caché
ObjectScript $LIST functions.
position
If you omit the position argument, $LISTDATA evaluates the first element. If
the value of the position argument is -1, it is equivalent to specifying the
final element of the list. If the value of the position argument refers to a
nonexistent list member, $LISTDATA returns 0.
Examples
The following embedded SQL examples show the results of the various values of
the position argument.
All of the following $LISTDATA statements return a value of 1:

  KILL Y
  SET a=$LISTBUILD("Red",,Y,"","Green")
  &sql(SELECT $LISTDATA(:a), $LISTDATA(:a,1),
       $LISTDATA(:a,4), $LISTDATA(:a,5), $LISTDATA(:a,-1)
  INTO :b,:c, :d, :e, :f
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"1st element status  ",b  ; 1st element default
    WRITE !,"1st element status  ",c  ; 1st element specified
    WRITE !,"4th element status  ",d  ; 4th element null string
    WRITE !,"5th element status  ",e  ; 5th element in 5-element list
    WRITE !,"last element status ",f  ; last element in 5-element list
  }
The following $LISTDATA statements return a value of 0 for the same
five-element list:

  KILL Y
  SET a=$LISTBUILD("Red",,Y,"","Green")
  &sql(SELECT $LISTDATA(:a,2), $LISTDATA(:a,3),
       $LISTDATA(:a,0), $LISTDATA(:a,6)
  INTO :b,:c, :d, :e
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"2nd element status ",b  ; 2nd element is undefined
    WRITE !,"3rd element status ",c  ; 3rd element is killed variable
    WRITE !,"0th element status ",d  ; zero position nonexistent
    WRITE !,"6th element status ",e  ; 6th element in 5-element list
  }
Notes
Invalid Parameter Values
If the expression in the list argument does not evaluate to a valid list, an
SQLCODE -400 fatal error occurs:

   &sql(SELECT $LISTDATA('fred')
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
   WRITE !,"The the element is ",b }
If the value of the position argument is less than -1, an SQLCODE -400 fatal
error occurs:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTDATA(:a,-3)
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
   WRITE !,"A neg-num position status ",c }
This does not occur when position is a nonnumeric value:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTDATA(:a,'g')
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Error code ",SQLCODE
     WRITE !,"A nonnumeric position status ",c }
See Also

  • SQL functions: $LIST $LISTBUILD $LISTFIND $LISTFROMSTRING $LISTGET
    $LISTLENGTH $LISTTOSTRING $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$LISTFIND_sql*  #{{{

A list function that searches a specified list for the requested value.
Synopsis

$LISTFIND(list,value[,startafter])

Arguments

            An expression that evaluates to a valid list. Because lists contain
list        encoding, list must be created using the Caché ObjectScript
            $LISTBUILD function, or extracted from another list using $LIST.

value       An expression containing the search element. A character string.

            Optional  An integer expression interpreted as a list position. The
startafter  search starts with the element after this position. Zero and  1 are
            valid values;  1 never returns an element. Zero is the default.

Description
$LISTFIND searches the specified list for the first instance of the requested 
value. The search begins with the element after the position indicated by the 
startafter argument. If you omit the startafter argument, $LISTFIND assumes a 
startafter value of 0 and starts the search with the first element (element 1).
If the value is found, $LISTFIND returns the position of the matching element.
If the value is not found, $LISTFIND returns a 0. The $LISTFIND function will
also return a 0 if the value of the startafter argument refers to a nonexistent
list member.
This function returns data of type SMALLINT.
Examples
The following embedded SQL example returns 2, the position of the first
occurrence of the requested string:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTFIND(:a,'Blue')
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
The following embedded SQL example returns 0, indicating the requested string
was not found:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTFIND(:a,'Orange')
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
The following three embedded SQL examples show the effect of using the 
startafter argument. The first example does not find the requested string and
returns 0 because the requested string occurs at the startafter position:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTFIND(:a,'Blue',2)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
The second example finds the requested string at the first position by setting 
startafter to zero (the default value):

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTFIND(:a,'Red',0)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
The third example finds the second occurrence of the requested string and
returns 5, because the first occurs before the startafter position:

   SET a=$LISTBUILD("Red","Blue","Green","Yellow","Blue")
   &sql(SELECT $LISTFIND(:a,'Blue',3)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
The $LISTFIND function only matches complete elements. Thus, the following
example returns 0 because no element of the list is equal to the string  B ,
though all of the elements contain  B :

   SET a=$LISTBUILD("ABC","BCD","BBB")
   &sql(SELECT $LISTFIND(:a,'B')
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
Notes
Invalid Argument Values
If the expression in the list argument does not evaluate to a valid list, the 
$LISTFIND function generates an SQLCODE -400 fatal error.

   SET a="Blue"
   &sql(SELECT $LISTFIND(:a,'Blue')
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
    WRITE !,"The position is ",b }
If the value of the startafter argument is -1, $LISTFIND always returns zero
(0).

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTFIND(:a,'Blue',-1)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
If the value of the startafter argument is less than -1, invoking the $LISTFIND
function generates an SQLCODE -400 fatal error.

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTFIND(:a,'Blue',-3)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The position is ",b }
See Also

  • SQL functions: $LIST $LISTBUILD $LISTDATA $LISTFROMSTRING $LISTGET
    $LISTLENGTH $LISTTOSTRING $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$LISTFROMSTRING_sql*  #{{{

A list function that creates a list from a string.
Synopsis

$LISTFROMSTRING(string,delimiter)

Parameters

           A string to be converted into a Caché list. This string contains one
string     or more elements, separated by a delimiter. The delimiter does not
           become part of the resulting Caché list.

           Optional  The delimiter used to separate substrings (elements) in 
delimiter  string. Specify delimiter as a quoted string. If no delimiter is
           specified, the default is the comma (,) character.

Description
$LISTFROMSTRING takes a quoted string containing delimited elements and returns
a list. A list represents data in an encoded format which does not use
delimiter characters. Thus a list can contain all possible characters, and is
ideally suited for bitstring data. Lists are handled using the Caché
ObjectScript and Caché SQL $LIST functions.
Parameters
string
A string literal (enclosed in single quotation marks), a numeric, or a variable
or expression that evaluates to a string. This string can contain one or more
substrings (elements), separated by a delimiter. The string data elements must
not contain the delimiter character (or string), because the delimiter
character is not included in the output list.
delimiter
A character (or string of characters) used to delimit substrings within the
input string. It can be a numeric or string literal (enclosed in single
quotation marks), the name of a variable, or an expression that evaluates to a
string.
Commonly, a delimiter is a designated character which is never used within
string data, but is set aside solely for use as a delimiter separating
substrings. A delimiter can also be a multi-character string, the individual
characters of which can be used within string data. If you specify no
delimiter, the default delimiter is the comma (,) character.
Examples
The following Embedded SQL example takes a string of names which are separated
by a blank space, and creates a list:

   SET names="Deborah Noah Martha Bowie"
   &sql(SELECT $LISTFROMSTRING(:names,' ')
        INTO :namelist
        FROM Sample.Person)
   IF SQLCODE=0 {
     WRITE !,"1st element: ",$LIST(namelist,1)
     WRITE !,"2nd element: ",$LIST(namelist,2)
     WRITE !,"3rd element: ",$LIST(namelist,3)}
   ELSE {WRITE !,"Error code;",SQLCODE }
The following Embedded SQL example uses the default delimiter (the comma
character), and creates a list:

   SET names="Deborah,Noah,Martha,Bowie"
   &sql(SELECT $LISTFROMSTRING(:names)
        INTO :namelist
        FROM Sample.Person)
   IF SQLCODE=0 {
     WRITE !,"1st element: ",$LIST(namelist,1)
     WRITE !,"2nd element: ",$LIST(namelist,2)
     WRITE !,"3rd element: ",$LIST(namelist,3)}
   ELSE {WRITE !,"Error code;",SQLCODE }
See Also

  • SQL functions: $LIST $LISTBUILD $LISTDATA $LISTFIND $LISTGET $LISTLENGTH
    $LISTTOSTRING $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$LISTGET_sql*  #{{{

A list function that returns an element in a list or a specified default value.
Synopsis

$LISTGET(list[,position[,default]])

Arguments

list      An expression that evaluates to a valid list.

position  Optional  An expression interpreted as a position in the specified
          list.

default   Optional  An expression that provides the value to return if the list
          element has an undefined value.

Description
$LISTGET returns the requested element in the specified list as a standard
character string. If the value of the position argument refers to a nonexistent
member or identifies an element with an undefined value, the specified default
value is returned.
The $LISTGET function is identical to the one- and two-argument forms of the 
$LIST function except that, under conditions that would cause $LIST to return a
null string, $LISTGET returns a default value.
This function returns data of type VARCHAR.
Arguments
list
An encoded character string containing one or more elements. Lists are created
using the Caché ObjectScript $LISTBUILD function. A list can be extracted from
another list by using the $LIST function.
position
The position argument must evaluate to an integer. If it is omitted, by
default, the function examines the first element of the list. If the value of
the position argument is -1, it is equivalent to specifying the last element of
the list.
default
A character string. If you omit the default argument, a zero-length string is
assumed for the default value.
Examples
The $LISTGET functions in the following embedded SQL example both return  Red ,
the first element in the list:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTGET(:a),$LISTGET(:a,1)
   INTO :b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The one-arg element returned is ",b
     WRITE !,"The two-arg element returned is ",c }
The $LISTGET functions in the following embedded SQL example both return  Green
 , the third and last element in the list:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTGET(:a,3),$LISTGET(:a,-1)
   INTO :b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The third element is ",b
     WRITE !,"The last element is ",c }
The $LISTGET functions in the following embedded SQL example both return a
value upon encountering the undefined 2nd element in the list. The first
returns a question mark (?), which the user defined as the default value. The
second returns a null string because a default value is not specified:

   SET a=$LISTBUILD("Red",,"Green")
   &sql(SELECT $LISTGET(:a,2,'?'),$LISTGET(:a,2)
   INTO :b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The default value is ",b
     WRITE !,"The no-default value is ",c }
The $LISTGET functions in the following embedded SQL example both specify a
position greater than the last element in the three-element list. The first
returns a null string because the default value is not specified. The second
returns the user-specified default value,  ERR :

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTGET(:a,4),$LISTGET(:a,4,'ERR')
   INTO :b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The no-default 4th element is ",b
     WRITE !,"The default for 4th element is ",c }
The $LISTGET functions in the following embedded SQL example both return a null
string:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTGET(:a,0),$LISTGET(NULL)
   INTO :b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The zero element is ",b
     WRITE !,"The NULL element is ",c }
Notes
Invalid Parameter Values
If the expression in the list argument does not evaluate to a valid list, an
SQLCODE -400 fatal error occurs because the $LISTGET return variable remains
undefined. This occurs even when a default value is supplied, as in the
following embedded SQL example:

   &sql(SELECT $LISTGET('fred',1,'failsafe')
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The non-list element is ",b  ; Variable not set
   }
If the value of the position argument is less than -1, an SQLCODE -400 fatal
error occurs because the $LISTGET return variable remains undefined. This
occurs even when a default value is supplied, as in the following embedded SQL
example:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTGET(:a,-3,'failsafe')
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"A neg-num position returns ",c  ; Variable not set
   }
This does not occur when position is a nonnumeric value:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTGET(:a,'g','failsafe')
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"A nonnumeric position returns ",c }
See Also

  • SQL functions: $LIST $LISTBUILD $LISTDATA $LISTFIND $LISTFROMSTRING
    $LISTLENGTH $LISTTOSTRING $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$LIST_sql*  #{{{

A list function that returns elements in a list.
Synopsis

$LIST(list[,position[,end]])

Arguments

          An expression that evaluates to a valid list. Because lists contain
list      encoding, list must be created using the Caché ObjectScript
          $LISTBUILD function, or extracted from another list using $LIST.

position  Optional  The starting position in the specified list. An expression
          that evaluates to an integer.

end       Optional  The ending position in the specified list. An expression
          that evaluates to an integer.

Description
$LIST returns elements from a list. The elements returned depend on the
arguments used.

  • $LIST(list) returns the first element in the list as a text string.
  • $LIST(list,position) returns the element indicated by the specified
    position as a text string. The position argument must evaluate to an
    integer.
  • $LIST(list,position,end) returns a  sublist (an encoded list string)
    containing the elements of the list from the specified start position
    through the specified end position.

This function returns data of type VARCHAR.
Arguments
list
An encoded list string containing one or more elements. Lists are created using
the Caché ObjectScript $LISTBUILD function. A list can be supplied to the SQL 
$LIST function using a host variable, as shown in the following embedded SQL
example:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,2)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The element returned is ",b }
A list can be extracted from another list by using the $LIST function:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,2,3)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
   &sql(SELECT $LIST(:b,1)
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The element returned is ",c }
   }
In the following embedded SQL example, subList is not a valid list argument,
because it is a single element returned as an ordinary string, not an encoded
list string. Only the three-argument form of $LIST returns an encoded list
string. In this case, an SQLCODE -400 fatal error is generated:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,2)
   INTO :sublist
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
   &sql(SELECT $LIST(:sublist,1)
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The sublist is"
     ZZDUMP c   ; Variable not set
     }
   }
position
The position of a list element to return. List elements are counted from 1. If 
position is omitted, the first element is returned. If the value of position is
0 or greater than the number of elements in the list, Caché SQL does not return
a value. If the value of position is negative one ( 1), $LIST returns the final
element in the list.

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,-1)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The last element is ",b }
If the end argument is specified, position specifies the first element in a
range of elements. Even when only one element is returned (when position and 
end are the same number) this element is returned as an encoded list string.
Thus, $LIST(x,2) (which returns the element as an ordinary string) is not
identical to $LIST(x,2,2) (which returns the element as an encoded list
string).
end
The position of the last element in a range of elements. You must specify 
position to specify end. When end is specified, the value returned is an
encoded list string. Because of this encoding, such strings should only be
processed by other $LIST functions.
If the value of end is:

  • greater than position, an encoded string containing a list of elements is
    returned.
  • equal to position, an encoded string containing the one element is
    returned.
  • less than position, no value is returned.
  • greater than the number of elements in list, it is equivalent to specifying
    the final element in the list.
  • negative one ( 1), it is equivalent to specifying the final element in the
    list.

When specifying end, you can specify a position value of zero (0). In this
case, 0 is equivalent to 1.
Examples
In the following embedded SQL example, the two WRITE statements both return  
Red , the first element in the list. The first writes the first element by
default, the second writes the first element because the position argument is
set to 1:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a),$LIST(:a,1)
   INTO :b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The one-arg sublist is ",b
     WRITE !,"The two-arg sublist is ",c }
The following embedded SQL example returns  Blue , the second element in the
list:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,2)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The second element is ",b }
The following embedded SQL example returns  Red Blue , a two-element list
string beginning with the first element and ending with the second element in
the list. ZZDUMP is used rather than WRITE, because a list string contains
special (non-printing) encoding characters:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,1,2)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The encoded sublist is"
     ZZDUMP b   ; Prints "Red Blue "
     }
The following embedded SQL example returns the last element in a list of
unknown length. Here, the last element is returned first as an ordinary string,
then as an encoded list string:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTLENGTH(:a),$LIST(:a,-1)
   INTO :b,:plain
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
   &sql(SELECT $LIST(:a,:b,-1)
   INTO :encoded
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The final element as a string: ",plain
     WRITE !,"The final element as an encoded string: "
     ZZDUMP encoded }
   }
Notes
Invalid Parameter Values
If the expression in the list argument does not evaluate to a valid list, an
SQLCODE -400 fatal error is generated:

   SET a="the quick brown fox"
   &sql(SELECT $LIST(:a,1)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The sublist is"
     ZZDUMP b   ; Variable not set
     }
If the value of the position argument or the end argument is less than -1, an
SQLCODE -400 fatal error is generated:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,-2,3)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The sublist is"
     ZZDUMP b   ; Variable not set
     }
If the value of the position argument refers to a nonexistent list member and
no end argument is used, an SQLCODE -400 fatal error is generated:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,7)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The sublist is"
     ZZDUMP b   ; Variable not set
     }
However, if an end argument is used, no error occurs, and the null string is
returned.

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LIST(:a,7,-1)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Error code ",SQLCODE
     WRITE !,"The sublist is"
     ZZDUMP b   ; Prints a null string
     }
If the value of the position argument identifies an element with an undefined
value, an SQLCODE  400 fatal error is generated:

   SET a=$LISTBUILD("Red",,"Green")
   &sql(SELECT $LIST(:a,2)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The sublist is"
     ZZDUMP b   ; Variable not set
     }
Two-Parameter and Three-Parameter $LIST
$LIST(list,1) is not equivalent to $LIST(list,1,1) because the former returns a
string, while the latter returns a single-element list string. If there are no
elements to return, the two-argument form does not return a value; the
three-argument form returns a null string.
Unicode
If one Unicode character appears in a list element, that entire list element is
represented as Unicode (wide) characters. Other elements in the list are not
affected.
The following embedded SQL example shows two lists. The a list consists of two
elements which contain only ASCII characters. The b list consists of two
elements: the first element contains a Unicode character ($CHAR(960) = the pi
symbol); the second element contains only ASCII characters.

   SET a=$LISTBUILD("ABC"_$CHAR(68),"XYZ")
   SET b=$LISTBUILD("ABC"_$CHAR(960),"XYZ")
   &sql(SELECT $LIST(:a,1),$LIST(:a,2),$LIST(:b,1),$LIST(:b,2)
   INTO :a1,:a2,:b1,:b2
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The ASCII list a elements: "
     ZZDUMP a1
     ZZDUMP a2
     WRITE !,"The Unicode list b elements: "
     ZZDUMP b1
     ZZDUMP b2 }
Note that Caché encodes the first element of b entirely in wide Unicode
characters. The second element of b contains no Unicode characters, and thus
Caché encodes it using narrow ASCII characters.
See Also

  • SQL functions: $LISTBUILD $LISTDATA $LISTFIND $LISTFROMSTRING $LISTGET
    $LISTLENGTH $LISTTOSTRING $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$LISTLENGTH_sql*  #{{{

A list function that returns the number of elements in a specified list.
Synopsis

$LISTLENGTH(list)

Argument

      Any expression that evaluates to a list. Because lists contain encoding, 
list  list must be created using the Caché ObjectScript $LISTBUILD function, or
      extracted from another list using $LIST.

Description
$LISTLENGTH returns the number of elements in list.
This function returns data of type SMALLINT.
Examples
The following embedded SQL example returns 3, because there are 3 elements in
the list:

   SET a=$LISTBUILD("Red","Blue","Green")
   &sql(SELECT $LISTLENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The number of elements is ",b }
Notes
Invalid Lists
If list is not a valid list, an SQLCODE -400 fatal error is generated:

   SET a="fred"
   &sql(SELECT $LISTLENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The number of elements is ",b ; Variable not set
   }
If the Caché ObjectScript $LISTBUILD function is used to build a list that
contains only the null string, this is a valid list, containing one element:

   SET a=$LISTBUILD("")
   &sql(SELECT $LISTLENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
   WRITE !,"The number of elements is ",b }
Null Lists
The following three embedded SQL examples show how the $LISTLENGTH SQL function
handles a null list. In the first two examples, list is the null string, and a
null string is returned:

   SET a=""
   &sql(SELECT $LISTLENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The number of elements is ",b }

   &sql(SELECT $LISTLENGTH(NULL)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The number of elements is ",b }
In the third example, list is the value $CHAR(0), which is an invalid list; an
SQLCODE -400 fatal error is generated:

   &sql(SELECT $LISTLENGTH('')
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The number of elements is ",b }
Note that this differs from how the Caché ObjectScript $LISTLENGTH function
handles a null list; the Caché ObjectScript function returns a 0, because a
zero-length string is a valid (zero-element) list:

   WRITE $LISTLENGTH("")
$LISTLENGTH and Nested Lists
The following embedded SQL example returns 3, because $LISTLENGTH does not
recognize the individual elements in nested lists:

   SET a=$LISTBUILD("Apple","Pear",$LISTBUILD("Walnut","Pecan"))
   &sql(SELECT $LISTLENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The number of elements is ",b }
See Also

  • SQL functions: $LIST $LISTBUILD $LISTDATA $LISTFIND $LISTFROMSTRING
    $LISTGET $LISTTOSTRING $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$LISTTOSTRING_sql*  #{{{

A list function that creates a string from a list.
Synopsis

$LISTTOSTRING(list,delimiter)

Parameters

list       A Caché list, created using $LISTBUILD or $LISTFROMSTRING, or
           extracted from another list using $LIST.

           Optional  A delimiter inserted to separate substrings. A delimiter
           can be one or more characters, specified as a quoted string. To
delimiter  concatenate the substrings with no delimiter, specify the empty
           string (''). If you specify no delimiter, the default is the comma
           (,) character.

Description
$LISTTOSTRING takes a Caché list and converts it to a string. In the resulting
string, the elements of the list are separated by the delimiter.
A list represents data in an encoded format which does not use delimiter
characters. Thus a list can contain all possible characters, and is ideally
suited for bitstring data. $LISTTOSTRING converts this list to a string with
delimited elements. It sets aside a specified character (or character string)
to serve as a delimiter. These delimited elements can be handled using the 
$PIECE function.
Note:
The delimiter specified here must not occur in the source data. Caché makes no
distinction between a character serving as a delimiter and the same character
as a data character.
Parameters
list
A Caché list, which contains one or more elements. A list is created using 
$LISTBUILD, made by converting a string using $LISTFROMSTRING, or extracted
from another list using $LIST.
If the expression in the list parameter does not evaluate to a valid list, an
SQLCODE -400 error occurs.
delimiter
A character (or string of characters) used to delimit substrings within the
output string. It can be a numeric or string literal (enclosed in single
quotation marks), a host variable, or an expression that evaluates to a string.
Commonly, a delimiter is a designated character which is never used within
string data, but is set aside solely for use as a delimiter separating
substrings. A delimiter can also be a multi-character string, the individual
characters of which can be used within string data.
If you specify no delimiter, the default delimiter is the comma (,) character.
You can specify a null string ('') as a delimiter; in this case, substrings are
concatenated with no delimiter. To specify the single quote character as the
delimiter, duplicate the quote character thus: ''''  four single quote
characters.
Example
The following example converts the values of a list field to a string with the
elements delimited by the colon (:) character:

SELECT
Name,
FavoriteColors AS ColorList,
$LISTTOSTRING(FavoriteColors,':') AS ColorStrings
FROM Sample.Person
WHERE FavoriteColors IS NOT NULL
See Also

  • SQL functions: $LIST $LISTBUILD $LISTDATA $LISTFIND $LISTFROMSTRING
    $LISTGET $LISTLENGTH $PIECE
  • Caché ObjectScript functions: $LIST $LISTBUILD $LISTDATA $LISTFIND
    $LISTFROMSTRING $LISTGET $LISTLENGTH $LISTNEXT $LISTSAME $LISTTOSTRING
    $LISTVALID


 #}}}
*$PIECE_sql*  #{{{

A string function that returns a substring identified by a delimiter.
Synopsis

$PIECE(plist,delimiter[,from[,to]])

Arguments

plist      The target string from which a substring is to be returned.

delimiter  A delimiter used to identify substrings.

           Optional  An integer that specifies the substring, or beginning of a
from       range of substrings, to return from the target string. Substrings
           are separated by a delimiter, and counted from 1. If omitted, the
           first substring is returned.

           Optional  An integer that specifies the ending substring for a range
to         of substrings to return from the target string. Must be used with 
           from.

Description
$PIECE returns the specified substring (piece) from plist. The substring
returned depends on the parameters used:

  • $PIECE(plist,delimiter) returns the first substring in plist. If delimiter
    occurs in plist, this is the substring that precedes the first occurrence
    of delimiter. If delimiter does not occur in plist, the returned substring
    is plist.
  • $PIECE(plist,delimiter,from) returns the substring which is the nth piece
    of plist, where the integer n is specified by the from parameter, and
    pieces are separated by a delimiter. The delimiter is not returned.
  • $PIECE(plist,delimiter,from,to) returns a range of substrings including the
    substring specified in from through the substring specified in to. This
    four-argument form of $PIECE returns a string that includes any
    intermediate occurrences of delimiter that occur between the from and to
    substrings. If to is greater than the number of substrings, the returned
    substring includes all substrings to the end of the plist string.

Arguments
plist
The target string from which the substring is to be returned. It can be a
string literal, a variable name, or any valid expression that evaluates to a
string.
A target string usually contains instances of a character (or character string)
which are used as delimiters. This character or string cannot also be used as a
data value within plist.
If you specify the null string (NULL) as the target string, $PIECE returns
<null>, the null string.
delimiter
The search string to be used to delimit substrings within plist. It can be a
numeric or string literal (enclosed in quotation marks), the name of a
variable, or an expression that evaluates to a string.
Commonly, a delimiter is a designated character which is never used within
string data, but is set aside solely for use as a delimiter separating
substrings. A delimiter can also be a multi-character search string, the
individual characters of which can be used within string data.
If you specify the null string (NULL) as the delimiter, $PIECE returns <null>,
the null string.
from
The number of a substring within plist, counting from 1. It must be a positive
integer, the name of an integer variable, or an expression that evaluates to a
positive integer. Substrings are separated by delimiters.

  • If the from parameter is omitted or set to 1, $PIECE returns the first
    substring of plist. If plist does not contain the specified delimiter, a 
    from value of 1 returns plist.
  • If the from parameter identifies by count the last substring in plist, this
    substring is returned, regardless of whether it is followed by a delimiter.
  • If the value of from is NULL, zero, a negative number, or greater than the
    number of substrings in plist, $PIECE returns a null string.

If the from parameter is used with the to parameter, it identifies the start of
a range of substrings to be returned as a string, and should be less than the
value of to.
to
The number of the substring within plist that ends the range initiated by the 
from parameter. The returned string includes both the from and to substrings,
as well as any intermediate substrings and the delimiters separating them. The 
to argument must be a positive integer, the name of an integer variable, or an
expression that evaluates to a positive integer. The to parameter must be used
with from and should be greater than the value of from.

  • If from is less than to, $PIECE returns a string consisting of all of the
    delimited substrings within this range, including the from and to
    substrings. This returned string contains the substrings and the delimiters
    within this range.
  • If to is greater than the number of delimited substrings, the returned
    string contains all the string data (substrings and delimiters) beginning
    with the from substring and continuing to the end of the plist string.
  • If from is equal to to, the from substring is returned.
  • If from is greater than to, $PIECE returns a null string.
  • If to is the null string (NULL), $PIECE returns a null string.

Examples
The following example returns 'Red', the first substring as identified by the
"," delimiter:

SELECT DISTINCT $PIECE('Red,Green,Blue,Yellow,Orange,Black',',')
FROM Sample.Person
The following example returns 'Blue', the third substring as identified by the
"," delimiters:

SELECT DISTINCT $PIECE('Red,Green,Blue,Yellow,Orange,Black',',',3)
FROM Sample.Person
The following example returns 'Blue,Yellow,Orange', the third through fifth
elements in colorlist, as delimited by ",":

SELECT DISTINCT
$PIECE('Red,Green,Blue,Yellow,Orange,Black',',',3,5)
FROM Sample.Person
The following $PIECE functions both return '123', showing that the two-argument
form is equivalent to the three-argument form when from is 1:

SELECT DISTINCT $PIECE('123#456#789','#') AS TwoArg
FROM Sample.Person

SELECT DISTINCT $PIECE('123#456#789','#',1) AS ThreeArg
FROM Sample.Person
The following example uses the multi-character delimiter string '#-#' to return
the third substring '789'. Here, the component characters of the delimiter
string, '#' and '-', can be used as data values; only the specified sequence of
characters (#-#) is set aside:

SELECT DISTINCT
$PIECE('1#2-3#-#45##6#-#789','#-#',3)
FROM Sample.Person
The following example returns 'MARCH;APR;MAY'. These comprise the third through
the fifth substrings, as identified by the ';' delimiter:

SELECT DISTINCT
$PIECE('JAN;FEB;MARCH;APR;MAY;JUN',';',3,5)
FROM Sample.Person
The following example returns "A,B"; it shows that you can nest $PIECE. It
finds the second piece of nestlist marked with the caret (^) delimiter, then
the first and second pieces of the substring "A,B,C" marked by the comma (,)
delimiter:
Notes
Using $PIECE to Unpack Data Values
$PIECE is typically used to "unpack" data values that contain multiple fields
delimited by a separator character. Typical delimiter characters include the
slash (/), the comma (,), the space ( ), and the semicolon (;). The following
sample values are good candidates for use with $PIECE:

'John Jones/29 River St./Boston MA, 02095'
'Mumps;Measles;Chicken Pox;Diptheria'
'45.23,52.76,89.05,48.27'

$PIECE and $LENGTH
The two-argument form of $LENGTH returns the number of substrings in a string,
based on a delimiter. Use $LENGTH to determine the number of substrings in a
string, and then use $PIECE to extract individual substrings.
$PIECE and $LIST
The data storage methods used by $PIECE and the $LIST functions are
incompatible and should not be combined. For example, attempted to use $PIECE
on a list created using $LISTBUILD yields unpredictable results and should be
avoided. This is true for both SQL functions and the corresponding Caché
ObjectScript functions.
The $LIST functions specify substrings without using a designated delimiter. If
setting aside a delimiter character or character sequence is not appropriate to
the type of data (for example, bitstring data), you should use the $LISTBUILD
and $LIST SQL functions to store and retrieve substrings.
Null Values
$PIECE does not distinguish between a delimited substring with a null string
value (NULL), and a nonexistent substring. Both return <null>, the null string
value. For example, the following examples both return the null string for a 
from value of 7:

SELECT DISTINCT $PIECE('Red,Green,Blue,Yellow,Orange,Black',',',7)
FROM Sample.Person

SELECT DISTINCT $PIECE('Red,Green,Blue,Yellow,Orange,Black,',',',7)
FROM Sample.Person
In the first case, there is no seventh substring; a null string is returned. In
the second case there is a seventh substring, as indicted by the delimiter at
the end of the plist string; the value of this seventh substring is the null
string.
The following example shows null values within a plist. It extracts substrings
3. This substring exists, but contains a null string:

SELECT DISTINCT $PIECE('Red,Green,,Blue,Yellow,Orange,Black,',',',3)
FROM Sample.Person
The following examples also returns a null string, because the specified
substrings do not exist:

SELECT DISTINCT $PIECE('Red,Green,,Blue,Yellow,Orange,Black,',',',0)
FROM Sample.Person

SELECT DISTINCT $PIECE('Red,Green,,Blue,Yellow,Orange,Black,',',',8,20)
FROM Sample.Person
In the following example, the $PIECE function returns the entire plist string,
because there are no occurrences of delimiter in the plist string:

SELECT DISTINCT $PIECE('Red,Green,Blue,Yellow,Orange,Black,','#')
FROM Sample.Person
Nested $PIECE Operations
To perform complex extractions, you can nest $PIECE references within each
other. The inner $PIECE returns a substring that is operated on by the outer 
$PIECE. Each $PIECE uses its own delimiter. For example, the following returns
the state abbreviation 'MA':

SELECT DISTINCT
$PIECE($PIECE('John Jones/29 River St./Boston MA 02095','/',3),' ',2)
FROM Sample.Person
The following is another example of nested $PIECE operations, using a hierarchy
of delimiters. First, the inner $PIECE uses the caret (^) delimiter to find the
second piece, 'A,B,C', of the string. Then the outer $PIECE uses the comma (,)
delimiter to return the first and second pieces ('A,B') of the substring
'A,B,C':

SELECT DISTINCT
$PIECE($PIECE('1,2,3^A,B,C^@#!','^',2),',',1,2)
FROM Sample.Person
See Also

  • SQL functions: $EXTRACT $FIND $LENGTH $LIST
  • Caché ObjectScript functions: $EXTRACT $FIND $LENGTH $LIST $PIECE


 #}}}
*%EXACT*  #{{{

A case-transformation function that converts characters to the EXACT collation
format.
Synopsis

%EXACT(expression)

%EXACT expression

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

Description
%EXACT returns expression in the EXACT collation sequence. This collation
sequence orders pure numeric values (values for which x=+x) in numeric order
first, followed by all other characters in string order.
The EXACT collation sequence for strings is the same as the ANSI-standard ASCII
collation sequence: digits are collated before uppercase alphabetic characters
and uppercase alphabetic characters are collated before lowercase alphabetic
characters. Punctuation characters occur at several places in the sequence.
%EXACT passes through NULLs unchanged. The otherwise-identical %MVR collation
function converts NULLs.
%EXACT is a Caché SQL extension and is intended for SQL lookup queries.
You can perform the same collation conversion in Caché ObjectScript using the
$ZUTIL(28) function.
Examples
The following examples uses %EXACT to return all Name values that are higher in
the collating sequence than 'Smith'. The first example uses parentheses syntax,
the second omits the parentheses.

SELECT Name
FROM Sample.Person
WHERE %EXACT(Name) > 'Smith'

SELECT Name
FROM Sample.Person
WHERE %EXACT Name > 'Smith'
See Also
ASCII %ALPHAUP %MVR %STRING %UPPER

 #}}}
*EXP*  #{{{

A scalar numeric function that returns the log exponential (base e ) value of a
given numeric expression.
Synopsis

{fn EXP(float-expression)}

Arguments

float-expression  The logarithmic exponent, which is an expression of type
                  FLOAT.

Description
EXP returns the exponential value (base e) of a natural logarithm. EXP returns
NULL if passed a NULL value.
EXP returns a value of data type FLOAT with a precision of 36 and a scale of
18.
EXP can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example returns the exponential value for the integer 15:

SELECT DISTINCT {fn EXP(15)} AS LogExp
FROM Sample.Person
returns 3269017.372...
The following embedded SQL example returns the base e exponential values for
the integers 0 through 10:

   SET a=0
   WHILE a<11 {
   &sql(SELECT {fn EXP(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE
     QUIT }
   ELSE {
     WRITE !,"Exponential of ",a," = ",b
     SET a=a+1 }
   }
The following embedded SQL example shows the relationship between the LOG and 
EXP functions for the integers 1 through 10:

   SET a=1
   WHILE a<11 {
   &sql(SELECT {fn LOG(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE
     QUIT }
   ELSE {
     WRITE !,"Logarithm of ",a," = ",b }
   &sql(SELECT ROUND({fn EXP(:b)},12)
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Exponential of log ",b," = ",c
   SET a=a+1 }
   }
Note that the ROUND function is needed here to correct for very small
discrepancies caused by system calculation limitations. In the above example, 
ROUND is set arbitrarily to 12 decimal digits for this purpose.
See Also

  • SQL functions: LOG LOG10 POWER ROUND
  • Caché ObjectScript function: $ZEXP


 #}}}
*%EXTERNAL*  #{{{

A format-transformation function that returns an expression in DISPLAY format.
Synopsis

%EXTERNAL(expression)

%EXTERNAL expression

Arguments

expression  The expression to be converted.

Description
%EXTERNAL converts expression to the DISPLAY format, which is the VARCHAR data
type with whatever data conversion the field or datatype’s LogicalToDisplay
method performs. The DISPLAY format is the format in which data can be input
and displayed.
%EXTERNAL is a Caché SQL extension.
When %EXTERNAL converts a list to DISPLAY format, the displayed list items
appear to be separated by a blank space. This  space is actually the two
non-display characters CHAR(13) and CHAR(10).
Examples
The following examples shows the internal and external formats of the same
fields. Note that the %EXTERNAL format is the same as the default display
format.
In this example, the internal format is an encoded list:

SELECT FavoriteColors,%INTERNAL(FavoriteColors) AS InternalVal,
%EXTERNAL(FavoriteColors) AS ExternalVal
FROM Sample.Person
In this example, the internal format for Date of Birth (DOB) is the Caché
$HOROLOG counter:

SELECT DOB,%INTERNAL(DOB) AS InternalVal,
%EXTERNAL(DOB) AS ExternalVal
FROM Sample.Person
See Also
%INTERNAL %ODBCIN %ODBCOUT

 #}}}
*FLOOR*  #{{{

A numeric function that returns the largest integer less than or equal to a
given numeric expression.
Synopsis

FLOOR(numeric-expression)
{fn FLOOR(numeric-expression)}

Arguments

numeric-expression  A number whose floor is to be calculated.

Description
FLOOR returns the same data type as numeric-expression. When numeric-expression
is a NULL value, an empty string (' '), or a nonnumeric string, FLOOR returns
NULL.
Note that FLOOR can be invoked as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.FLOOR(numeric-expression)
Examples
The following examples show the effect of FLOOR:

SELECT DISTINCT FLOOR(167.45) AS FloorNum
FROM Sample.Person
returns 167.

SELECT DISTINCT {fn FLOOR(167.00)} AS FloorNum
FROM Sample.Person
returns 167.

SELECT DISTINCT FLOOR(-167.45) AS FloorNum
FROM Sample.Person
returns -168.

SELECT DISTINCT {fn FLOOR(-167.00)} AS FloorNum
FROM Sample.Person
returns -167.
See Also
CEILING

 #}}}
*GETDATE*  #{{{

A date/time function that returns the current date and time.
Synopsis

GETDATE([precision])

Arguments

           Optional  Specifies the time precision as the number of digits of
precision  fractional seconds. Valid values are the integers 0 through 9. The
           default is 0 (no fractional seconds); this default is configurable.

Description
GETDATE can be issued with no arguments, or with the optional precision
argument. It returns the time in %TimeStamp format. Its ODBC type is TIMESTAMP,
LENGTH is 16, and PRECISION is 19.
The datetime string returned is of the format:

yyyy-mm-dd hh:mm:ss.ffff

Where  f represents fractional seconds of precision. GETDATE values are
displayed in this format in Display mode, ODBC mode, or Logical mode.
To change the default datetime string format, use the SET OPTION command with
the various date and time options.
Typical uses for GETDATE are in the SELECT statement select list or in the 
WHERE clause of a query. In designing a report, GETDATE can be used to print
the current date and time each time the report is produced. GETDATE is also
useful for tracking activity, such as logging the time that a transaction
occurred.
GETDATE can be used for a field’s default value. GETDATE is a synonym for
CURRENT_TIMESTAMP and is provided for compatibility with Sybase and Microsoft
SQL Server.
The CURRENT_TIMESTAMP and NOW functions can also be used to return the current
date and time as data type TIMESTAMP. CURRENT_TIMESTAMP supports precision, NOW
does not support precision.
To return just the current date, use CURDATE or CURRENT_DATE. To return just
the current time, use CURRENT_TIME or CURTIME. The functions use the DATE or
TIME data type. None of these functions support precision.
These data types perform differently when using embedded SQL. A TIMESTAMP data
type stores and displays its value in the same format. The TIME and DATE data
types store their values as integers in $HOROLOG format; when displayed in SQL
they are converted to date or time display format; when returned from embedded
SQL they are returned as integers. You can use the CAST or CONVERT function to
change the datatype of dates and times.
All Caché SQL timestamp functions are specific to the local time zone setting.
To get a current timestamp that is universal (independent of time zone) use the
Caché ObjectScript $ZTIMESTAMP special variable.
Fractional Seconds Precision
GETDATE can return up to nine digits of precision. The number of digits of
precision returned is set using the precision argument. The default for the 
precision argument can be configured using the following:

  • SET OPTION with the TIME_PRECISION option.
  • The $SYSTEM.SQL.SetDefaultTimePrecision() method call.
  • Go to the System Management Portal, select [Home] > [Configuration] > [SQL
    Settings] > [General SQL Settings]. View and edit the current setting of 
    Default time precision for GETDATE(), CURRENT_TIME, and CURRENT_TIMESTAMP.

Specify an integer 0 through 9 (inclusive) for the default number of decimal
digits to return. The default is 0. The actual precision returned is platform
dependent; precision digits in excess of the precision available on your system
are returned as zeroes.
Examples
The following example returns the current date and time:

SELECT DISTINCT GETDATE() AS DateTime
FROM Sample.Person
The following example returns the current date and time with two digits of
precision:

SELECT DISTINCT GETDATE(2) AS DateTime
FROM Sample.Person
The following embedded SQL example compares local (time zone specific) and
universal (time zone independent) time stamps:

  SET b=$ZDATETIME($ZTIMESTAMP,3)
  &sql(SELECT GETDATE()
  INTO :a
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"GetDate is:    ",a
    WRITE !,"ZTimestamp is: ",b }
The following example:

UPDATE Orders SET LastUpdate = GETDATE()
  WHERE Orders.OrderNumber=:ord

sets the LastUpdate field in the selected row of the Orders table to the
current system date and time.
In the following example, the CREATE TABLE statement uses GETDATE to set a
default value for the StartDate field:

CREATE TABLE Employees(
     EmpId       INT NOT NULL,
     LastName    CHAR(40) NOT NULL,
     FirstName   CHAR(20) NOT NULL,
     StartDate   TIMESTAMP DEFAULT GETDATE())

See Also

  • SQL concepts: Data Type Date and Time Constructs
  • SQL timestamp functions: CAST CONVERT CURRENT_TIMESTAMP NOW TIMESTAMPADD
    TIMESTAMPDIFF
  • SQL current date and time functions: CURDATE CURRENT_DATE CURRENT_TIME
    CURTIME
  • Caché ObjectScript: $ZDATETIME function $HOROLOG special variable
    $ZTIMESTAMP special variable


 #}}}
*HOUR*  #{{{

A scalar date/time function that returns an integer from 0 to 23 that
corresponds to the hour component in a given date-time expression.
Synopsis

{fn HOUR(time-expression)}

Arguments

                 An expression that is the name of a column, the result of
                 another scalar function, or a string or numeric literal. It
time-expression  must resolve either to a datetime string or a time integer,
                 where the underlying data type can be represented as TIME or
                 TIMESTAMP.

Description
HOUR returns the hours portion of a time integer or a datetime string. A
datetime string is of the format:

yyyy-mm-dd hh:mm:ss

To change this default time format, use the SET OPTION command.
Note that you can supply a time integer (number of elapsed seconds), but not a
time string (hh:mm:ss). You must supply a datetime string (yyyy-mm-dd
hh:mm:ss). You can omit the seconds (:ss) or minutes and seconds (mm:ss)
portion of a datetime string and still return the hour portion.
Hours are expressed in 24-hour time. The hours (hh) portion should be an
integer in the range from 0 through 23. There is, however, no range checking
for user-supplied values. Numbers greater than 23, negative numbers, and
fractions are returned as specified. Leading zeros are optional on input;
leading zeros are suppressed on output.
HOUR returns a value of 0 hours when the hours portion is '0', '00', or a
nonnumeric value. Zero hours is also returned if no time expression is
supplied, or if the hours portion of the time expression is omitted (':mm:ss'
or '::ss').
The same time information can be returned using DATEPART or DATENAME.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.HOUR(time-expression)
Examples
The following examples both return the number 18 because the time-expression
value is 18:45:38:

SELECT DISTINCT {fn HOUR('2000-02-16 18:45:38')} AS Hour_Given
FROM Sample.Person

SELECT DISTINCT {fn HOUR(67538)} AS Hour_Given
FROM Sample.Person
The following example also returns 18. The seconds (or minutes and seconds)
portion of the time value can be omitted.

SELECT DISTINCT {fn HOUR('2000-02-16 18:45')} AS Hour_Given
FROM Sample.Person
The following example returns 0 hours, because the time portion of the datetime
string has been omitted:

SELECT DISTINCT {fn HOUR('2000-02-16')} AS Hour_Given
FROM Sample.Person
The following examples all return the hours portion of the current time. 
CURRENT_TIME and CURTIME supply a time string; NOW supplies a datetime string:

SELECT DISTINCT {fn HOUR(CURRENT_TIME)} AS Hour_Now1,
                {fn HOUR({fn CURTIME()})} AS Hour_Now2,
                {fn HOUR({fn NOW()})} AS Hour_Now3
FROM Sample.Person
The following example shows that leading zeros are suppressed. The first HOUR
function returns a length 2, the others return a length of 1. An omitted time
is considered to be 0 hours, which has a length of 1:

SELECT DISTINCT LENGTH({fn HOUR('2004-02-05 11:45')}),
                LENGTH({fn HOUR('2004-02-15 03:45')}),
                LENGTH({fn HOUR('2004-02-15 3:45')}),
                LENGTH({fn HOUR('2004-02-15')})
FROM Sample.Person
The following Embedded SQL example shows that the HOUR function recognizes the
TimeSeparator character specified for the locale:

  DO ##class(%SYS.NLS.Format).SetFormatItem("TimeSeparator",".")
  &sql(SELECT DISTINCT {fn HOUR('2000-02-16 18.45.38')}
  INTO :a
  FROM Sample.Person)
  WRITE "hour=",a
See Also

  • SQL concepts: Data Type Date and Time Constructs
  • SQL functions: MINUTE SECOND CURRENT_TIME CURTIME NOW DATEPART DATENAME
  • Caché ObjectScript: $ZTIME function $HOROLOG special variable $ZTIMESTAMP
    special variable


 #}}}
*IFNULL*  #{{{

A function that tests for NULL and returns the appropriate expression.
Synopsis

IFNULL(expression-1,expression-2,expression-3)
{fn IFNULL(expression-1,expression-2)}

Arguments

expression-1  The expression to be evaluated to determine if it is NULL or not.

expression-2  An expression that is returned if expression-1 is NULL.

              Optional  An expression that is returned if expression-1 is not
expression-3  NULL. If expression-3 is not specified, a NULL value is returned
              when expression-1 is not NULL.

Description
Caché supports IFNULL as both an SQL general function and an ODBC scalar
function. Note that while these two perform very similar operations, they are
functionally different. The SQL general function supports three arguments. The
ODBC scalar function supports two arguments.
The SQL general function evaluates expression-1 and returns one of three
values:

  • If expression-1 is NULL, expression-2 is returned.
  • If expression-1 is not NULL, expression-3 is returned.
  • If expression-1 is not NULL, and there is no expression-3, NULL is
    returned.

The ODBC scalar function evaluates expression-1 and returns one of two values:

  • If expression-1 is NULL, expression-2 is returned.
  • If expression-1 is not NULL, expression-1 is returned.

The possible data type(s) of expression-2 and expression-3 must be compatible
with the data type of expression-1. The data type returned in DISPLAY mode or
ODBC mode is determined by the data type of expression-2.
Note:
The two-argument forms of the general function and the ODBC scalar function are
not functionally the same. They return different values, as shown in the
examples.
The following table shows the various SQL comparison functions. Each function
returns one value if the comparison tests True (A equals B) and another value
if the comparison tests False (A not equal to B):

      SQL Function             Comparison Test          Return Value

NULLIF                    expression1 = expression2  True = NULL
                                                     False = expression1

IFNULL (2 argument form)  expression1 = NULL         True = expression2
                                                     False = NULL

ISNULL                    expression1 = NULL         True = expression2
                                                     False = expression1

NVL                       expression1 = NULL         True = expression2
                                                     False = expression1

IFNULL (3 argument form)  expression1 = NULL         True = expression2
                                                     False = expression3

Refer to NULL section of the  Language Elements chapter of Using Caché SQL for
further details on NULL handling.
Examples
The following example returns the string 'No Preference' if FavoriteColors is
NULL; otherwise, it returns NULL:

SELECT Name,
IFNULL(FavoriteColors,'No Preference') AS ColorPref
FROM Sample.Person
The following example returns the string 'No Preference' if FavoriteColors is
NULL; otherwise, it returns the value of FavoriteColors:

SELECT Name,
IFNULL(FavoriteColors,'No Preference',FavoriteColors) AS ColorPref
FROM Sample.Person
The following example returns the string 'No Preference' if FavoriteColors is
NULL; otherwise, it returns the string 'Preference':

SELECT Name,
IFNULL(FavoriteColors,'No Preference','Preference') AS ColorPref
FROM Sample.Person
The following ODBC example returns the string 'No Preference' if FavoriteColors
is NULL, otherwise it returns the data value:

SELECT Name,
{fn IFNULL(FavoriteColors,'No Preference')} AS Colors
FROM Sample.Person
The following general function and ODBC scalar function examples both returns
the second expression (99) because the first expression is NULL:

SELECT DISTINCT {fn IFNULL(NULL,99)}AS NullTest
FROM Sample.Person

SELECT DISTINCT IFNULL(NULL,99) AS NullTest
FROM Sample.Person
The following general function and ODBC scalar function examples return
different values. The ODBC example returns the first expression (33) because
the first expression is not NULL:

SELECT DISTINCT {fn IFNULL(33,99)}AS NullTest
FROM Sample.Person
Compare this with the general function, which returns <null> because the first
expression is not NULL:

SELECT DISTINCT IFNULL(33,99) AS NullTest
FROM Sample.Person
See Also
ISNULL NVL

 #}}}
*INSERT*  #{{{

Adds a new row (or rows) to a table.
Synopsis

INSERT [restriction] [INTO] table
           [(columnlist)] VALUES (valuelist) |
           [(columnlist)] VALUES host-variable |
           [(columnlist)] query |
           SET column1=value1 {,column2=value2, . . . } |
           DEFAULT VALUES

Arguments

restriction    Optional  One or more of the following keywords, separated by
               spaces: %NOLOCK, %NOCHECK, %NOINDEX, %NOTRIGGER.

table          The name of the table or view on which to perform the insert
               operation. The INTO keyword is optional.

               Optional  A comma-separated list of column names that correspond
columnlist     in sequence to the supplied list of values. If omitted, the list
               of values is applied to all columns in column-number order.

valuelist      A comma-separated list of scalar expressions that supplies the
               data values for the corresponding columnlist fields.

host-variable  A host variable that supplies the data values for the
               corresponding columnlist fields. (See example below.)

query          A query’s result set that supplies the data values for the
               corresponding columnlist fields for one or more rows.

column         A single column name whose data value is set to the value paired
               with it using the equal sign.

value          A scalar expression serving as the source for the paired column
               value.

Description
The INSERT statement can be used in two ways:

  • An INSERT can insert data values for one new row into a table.
  • An INSERT with a SELECT can insert data values for multiple new rows into a
    table.

An INSERT statement adds one new row to a table. This operation sets the
%ROWCOUNT variable to the number of affected rows (always either 0 or 1).
An INSERT statement combined with a SELECT statement can insert multiple new
rows to a table. This technique is commonly used to populate a table with
existing data extracted from other tables. This use of INSERT is described in
the  INSERT Query Results section below.
You can insert into a table directly, or insert through a view. Inserting
through a view is subject to requirements and restrictions, as described in
CREATE VIEW.
If you omit the column list, the INSERT assumes all columns are to be inserted,
in column number order. If you specify a column list, the individual values
must correspond positionally with the column names in the column list.
To use INSERT to add data to a Caché table using Microsoft Access, either mark
the table RowID as private or define a unique index on one or more additional
fields.
Privileges
To insert one or more rows of data into a table, you must have either
table-level privileges or column-level privileges for that table.
Table-level Privileges
You must have both INSERT and SELECT privileges for the table. Failing to have
these privileges results in an SQLCODE -99 (Privilege Violation) error. See the
GRANT command for further details.
Table-level privileges are equivalent to (but not identical to) having
column-level privileges on all columns of the table.
Column-level Privileges
If you do not have table-level INSERT privilege, you must have column-level
INSERT privilege for at least one column of the table. To insert a specified
value into a column, you must have column-level INSERT privilege for that
column. Only those columns for which you have INSERT privilege receive the
value specified in the INSERT command.
If you do not have column-level INSERT privilege for a specified column, Caché
SQL inserts the column's default value (if defined), or NULL (if no default is
defined). If you do not have INSERT privilege for a column that has no default
and is defined as NOT NULL, Caché issues an SQLCODE -99 (Privilege Violation)
error at Prepare time.
If the INSERT command specifies fields in a WHERE clause of a result set SELECT
, you must have SELECT privilege for those fields if they are not data insert
fields, and both SELECT and INSERT privileges for those fields if they are
included in the result set.
See the GRANT command for further details.
SQLCODE Errors
By default, an INSERT is an all-or-nothing event: either the row (or rows) is
inserted completely or not at all. Caché returns a status variable SQLCODE,
indicating the success or failure of the INSERT. To insert a row into a table,
the insert must meet all table, columnlist, and value requirements, as follows.
Tables:

  • The table must already exist. Attempting an insert to a nonexistent table
    results in an SQLCODE -30 error. Because INSERT checks for the table's
    existence at compile time, a single compiled SQL program (such as an
    Embedded SQL program) cannot create a table (using CREATE TABLE) and then
    insert values into it.
  • The table cannot be defined as READONLY. Attempting to compile an INSERT
    that references a read-only table results in an SQLCODE -115 error. Note
    that this error is now issued at compile time, rather than only occurring
    at execution time. See the description of READONLY objects in the Object
    Persistence chapter of Using Caché Objects.
  • If updating a table through a view, the view cannot be defined as WITH READ
    ONLY. Attempting to do so results in an SQLCODE -35 error. See the CREATE
    VIEW command for further details.

Columnlist Field Names:

  • The insert must include all required fields. Attempting to insert a row
    without specifying a value for a required field results in an SQLCODE -108
    error.
  • The insert cannot include duplicate field names. Attempting to insert a row
    containing two fields with the same name results in an SQLCODE -377 error.
  • The insert cannot include fields that are defined as READONLY. Attempting
    to compile an INSERT that references a read-only field results in an
    SQLCODE -138 error. Note that this error is now issued at compile time,
    rather than only occurring at execution time.

Field Values:

  • Every field value must be a valid value. Attempting to insert an invalid
    field value results in an SQLCODE -104 error. One example of this is when
    an invalid DOUBLE number is supplied via ODBC or JDBC.
  • By default, an insert cannot specify values for fields for which the value
    is system-generated, such as the RowID, IDKey, or IDENTITY field. By
    default, attempting to insert a non-NULL field value for any of these
    fields results in an SQLCODE -111 error. Attempting to insert a NULL for
    one of these fields causes Caché to override the NULL with a
    system-generated value; the insert completes successfully and no error code
    is issued.
    An IDENTITY field can be made to accept user-specified values. By setting
    the Caché ObjectScript $ZUTIL(115,11) function you can override the
    IDENTITY field default constraint and allow inserts of unique integer
    values to IDENTITY fields. Inserting an IDENTITY field value changes the
    IDENTITY counter so that subsequent system-generated values increment from
    this user-specified value. Attempting to insert a NULL for an IDENTITY
    field generates an SQLCODE -108 error.
  • Every field value must pass all field constraints. For example, attempting
    to insert a duplicate field value in a field with a uniqueness constraint
    results in an SQLCODE -119 error.
  • The insert cannot include a field whose value violates foreign key
    referential integrity, unless the %NOCHECK restriction argument is
    specified. Otherwise, attempting an insert that violates foreign key
    referential integrity results in an SQLCODE -121 error.
  • A field value cannot be a subquery. Attempting to specify a subquery as a
    field value results in an SQLCODE -144 error.

INSERT DEFAULT VALUES
You can insert a row into a table that has all of its field values set to
default values. Fields that have a defined default value are set to that value.
Fields without a defined default value are set to NULL. This is done using the
following command:

INSERT INTO Mytable DEFAULT VALUES

If the table is defined with an IDENTITY field, this command inserts a row with
a system-generated IDENTITY field value.
INSERT Field of SERIAL Data Type
An INSERT operation can specify one of the following values for a field with
the SERIAL data type, with the following results:

  • No value, 0 (zero), or a non-numeric value: Caché ignores the specified
    value, and instead increments this field's current serial counter value by
    1, and inserts the resulting integer into the field.
  • A positive integer value: Caché inserts the user-specified value into the
    field, and changes the serial counter value for this field to this integer
    value.

Thus a SERIAL field contains a series incremental integer values. These values
are not necessarily continuous or unique. For example, the following is a valid
series of values for a SERIAL field: 1, 2, 3, 17, 18, 25, 25, 26, 27.
Sequential integers are either Caché-generated or user-supplied; non-sequential
integers are user-supplied. If you wish SERIAL field values to be unique, you
must apply a UNIQUE constraint on the field.
Restriction Arguments
Specifying restriction argument(s) restricts processing as follows:

  • %NOCHECK  foreign key referential integrity checking is not performed. The
    WITH CHECK OPTION validation for a view is not performed when performing an
    INSERT through a view.
  • %NOLOCK  the row is not locked upon INSERT. This should only be used when a
    single user/process is updating the database.
  • %NOINDEX  the index maps are not set during INSERT processing.
  • %NOTRIGGER  the base table triggers are not pulled during INSERT
    processing.

You can specify multiple restriction arguments in any order. Multiple arguments
are separated by spaces.
Referential Integrity
If you do not specify %NOCHECK, Caché uses the system configuration setting to
determine whether to perform foreign key referential integrity checking. You
can set the system default as follows:

  • The $SYSTEM.SQL.SetFilerRefIntegrity() method call.
  • Go to the System Management Portal, select [Home] > [Configuration] > [SQL
    Settings] > [General SQL Settings]. View and edit the current setting of 
    Perform Referential Integrity Checks on Foreign Keys for INSERT, UPDATE, and DELETE
    . The default is  Yes .

During an INSERT operation, for every foreign key reference a shared lock is
acquired on the corresponding row in the referenced table. This row is locked
until the end of the transaction. This ensures that the referenced row is not
changed between the INSERT referential integrity checking and the end of the
transaction.
DISPLAY to LOGICAL Data Conversion
Data is stored in LOGICAL mode format. If you specify data values in DISPLAY
mode during an INSERT operation, data conversion from DISPLAY mode to LOGICAL
mode depends on the current SELECTMODE. You can specify the SELECTMODE in a 
CREATE FUNCTION, CREATE METHOD, or CREATE PROCEDURE statement, or in embedded
SQL using the Caché ObjectScript #SQLCompile preprocessor command setting:

  • For SELECTMODE=RUNTIME mode (the default), conversion is performed. You can
    specify data values in either DISPLAY mode or LOGICAL mode format. The data
    values are stored in LOGICAL mode format.
  • For SELECTMODE=DISPLAY mode, no conversion is performed. You must specify
    data values in LOGICAL mode format. Attempting to specify a DISPLAY mode
    value results in a field validation error.

For further details, see #SQLCompile Select in the  ObjectScript Macros and the
Macro Preprocessor chapter of Using Caché ObjectScript.
List Structures
Caché supports the list structure data type %List (data type class
%Library.List). This is a compressed binary format, which does not map to a
corresponding native data type for Caché SQL. It corresponds to data type
VARBINARY with a default MAXLEN of 32749. For this reason, Dynamic SQL cannot
use INSERT or UPDATE to set a property value of type %List. For further
details, refer to the Data Types reference page in this manual.
Stream Data
You cannot use a single INSERT to insert multiple rows containing a stream
value. Rows containing stream data must be inserted one row at a time.
You can insert the following types of data values into a stream field:

  • A fully formed object ID (OID) of a stream object. Caché opens the stream
    object and copies its contents into the new stream object.
  • An object reference (oref) of a stream, for example:
   
        set oref=##class(%Stream.GlobalCharacter).%New()
        do oref.Write("Technique 1")

        //do the insert; use an actual oref
        &sql(INSERT INTO MyStreamTable (MyStreamField) VALUES (:oref))

  • A string version of an oref of a stream, for example:
   
        set oref=##class(%Stream.GlobalCharacter).%New()
        do oref.Write("Technique 2")

        //next line converts oref to a string oref
        set string=oref_""

        //do the insert
        &sql(INSERT INTO MyStreamTable (MyStreamField) VALUES (:string))

  • A string literal whose first character is not numeric, for example:
   
        set literal="Technique 3"

        //do the insert; use a string
        &sql(INSERT INTO MyStreamTable (MyStreamField) VALUES (:literal))

    If the first character is numeric, SQL interprets the literal as the string
    form of an oref instead. For example, the value 2@User.MyClass would be
    considered the string version of an oref, and not a string literal.

Attempting to insert an improperly defined stream value results in an SQLCODE
-412 error: General Stream Error.
INSERT Query Results
A single INSERT can be used to insert multiple rows into a table by combining
it with a SELECT statement. The SELECT extracts column data from multiple rows
of one table, and the INSERT creates corresponding new rows containing this
column data in another table. However, you cannot use this method to insert
multiple rows if the data contains a stream value.
You can limit the number of rows inserted by specifying a TOP clause in the 
SELECT statement; TOP is described in the SELECT reference page. You can also
use an ORDER BY clause in the SELECT statement to determine which rows will be
selected by the TOP clause.
An INSERT with SELECT operation sets the %ROWCOUNT variable to the number of
rows inserted (either 0 or a positive integer).
The following example uses two embedded SQL programs to show this use of INSERT
. The first example creates a new table Sample.Students, and the second example
populates this table with data extracted from Sample.Person.
To demonstrate this, please run the two embedded SQL programs in the order
shown. (It is necessary to use two embedded SQL programs here because embedded
SQL cannot compile an INSERT statement unless the referenced table already
exists.)

   ZNSPACE "Samples"
   WRITE !,"Creating table"
  &sql(CREATE TABLE Sample.Students (
    StudentName VARCHAR(16),
    StudentAge INTEGER))
  IF SQLCODE=0 {
    WRITE !,"Created table, SQLCODE=",SQLCODE }
  ELSEIF SQLCODE=-201 {
    WRITE !,"Table already exists, SQLCODE=",SQLCODE }

  ZNSPACE "Samples"
  WRITE !,"Populating table with data"
  NEW SQLCODE,%ROWCOUNT,%ROWID
  &sql(INSERT INTO Sample.Students (StudentName,StudentAge)
     SELECT Name,Age
     FROM Sample.Person WHERE Age <= '21')
  IF SQLCODE=0 {
    WRITE !,"Number of records inserted=",%ROWCOUNT
    WRITE !,"Row ID of last record inserted=",%ROWID }
  ELSE {
    WRITE !,"Insert failed, SQLCODE=",SQLCODE }
Note that executing this program multiple times will succeed; but produces
generally undesirable results. Each execution populates Sample.Students with
another set of records (%ROWCOUNT) with identical Name and Age field values,
automatically assigning each record a unique row ID (%ROWID).
To view the data, go to the System Management Portal, select the Globals option
for the SAMPLES namespace. Scroll to  Sample.StudentD and click the Data
option.
By default, an Insert Query Results operation is an atomic operation. Either
all of the specified rows are inserted in a table, or none of the rows are
inserted. For example, if inserting one of the specified rows would violate
foreign key referential integrity, the INSERT fails and no rows are inserted.
This default is modifiable, as described below.
Atomicity
By default, UPDATE, INSERT, and DELETE are atomic operations. An INSERT either
completes successfully or fails. If any of the specified rows in an insert
query results fails the insert, none of the specified rows are inserted, and
the database reverts to its state before issuing the INSERT.
This default is modifiable within SQL by invoking SET TRANSACTION %COMMITMODE.
This default is also modifiable by invoking the following method: 
$SYSTEM.SQL.SetAutoCommit(). The following options are available:

  • IMPLICIT or 1 (autocommit on)  The default behavior, as described above.
  • NONE or 0 (no auto transaction)  No transaction is initiated when you
    invoke UPDATE, INSERT, or DELETE. A failed UPDATE, INSERT, or DELETE
    operation can leave the database in an inconsistent state, with some of the
    specified rows modified and some unmodified.
  • EXPLICIT or 2 (autocommit off)  UPDATE, INSERT, and DELETE commands
    automatically initiate a transaction, but you must explicitly commit (using
    TCOMMIT) or roll back this transaction following the operation.

Transaction Locking
If you do not specify %NOLOCK, Caché performs standard locking on INSERT, 
UPDATE, and DELETE operations. Unique field values are locked for the duration
of the current transaction.
The default lock threshold is 1000 locks per table. This means that if you
insert more than 1000 rows (unique field values) into a table during a
transaction, the lock threshold is reached and Caché automatically elevates the
locking level from unique field value locks to a table lock. This permits
large-scale inserts during a transaction without overflowing the lock table.
This lock threshold value is configurable. Go to the System Management Portal,
select [Home] > [Configuration] > [SQL Settings] > [General SQL Settings]. View
and edit the current setting of Lock Threshold. For further details on
transaction locking refer to Transaction Processing in the  Modifying the
Database chapter of Using Caché SQL.
Row-Level Security
Caché row-level security permits INSERT to add a row even if the row security
is defined so that you will not be permitted to subsequently access the row. To
ensure that an INSERT does not prevent you from subsequent SELECT access to the
row, it is recommended that you perform the INSERT through a view that has a
WITH CHECK OPTION. For further details, refer to CREATE VIEW.
Examples
The following embedded SQL example inserts a row with three field values, Name,
DOB, and SSN:

  NEW SQLCODE,%ROWCOUNT,%ROWID
  &sql(INSERT INTO Sample.Person (Name,DOB,SSN) VALUES
   ('Fred Wang', 46639,'111-22-3333'))
  IF SQLCODE=0 {
    WRITE !,"Row count=",%ROWCOUNT
    WRITE !,"Row ID=",%ROWID }
  ELSE {
    WRITE !,"Insert failed, SQLCODE=",SQLCODE }
The following two examples use Dynamic SQL to perform the same operation. The
first prepares and executes a Dynamic SQL insert from Cache ObjectScript:

  SET x = "Fran Yardley"
  SET y = "46710"
  SET z = "987-65-9999"
  SET sqltext = "INSERT INTO Sample.Person (Name,DOB,SSN) VALUES (?,?,?)"
  SET result = ##class(%Library.ResultSet).%New()
  SET status = result.Prepare(sqltext)
  SET status = result.Execute(x,y,z)
  IF SQLCODE=0 {
    WRITE !,"Row count=",%ROWCOUNT
    WRITE !,"Row ID=",%ROWID }
  ELSE {
    WRITE !,"Insert failed, SQLCODE=",SQLCODE }
The second prepares and executes a Dynamic SQL insert from Cache Basic:

  x = "Glenn Morrow"
  y = "46640"
  z = "987-65-4321"
  result = New %Library.ResultSet()
  result.Prepare("INSERT INTO Sample.Person (Name,DOB,SSN) VALUES (?,?,?)")
  result.Execute(x,y,z)
  IF SQLCODE=0 THEN
    Println "Row count=",%ROWCOUNT
    Println "Row ID=",%ROWID
  ELSE
    Println "Insert failed, SQLCODE=",SQLCODE
  END IF
Note:
Example programs that delete the records inserted by the programs above are
provided in the DELETE command documentation.
For further details, refer to the Dynamic SQL chapter in Using Caché SQL.
The following embedded SQL example demonstrates the use of input host
variables. Note that with the host variable construction, you can use a
variable reference with an unspecified last subscript to pass an array of
values to INSERT. For example:

  NEW SQLCODE,%ROWCOUNT,%ROWID
  &sql(INSERT INTO Sample.Employee VALUES :emp("profile",))
  WRITE !,"SQL Error code: ",SQLCODE," Row Count: ",%ROWCOUNT
causes each field in the inserted "Employee" row to be set to:

emp("profile",col)

where "col" is the field’s column number in the Sample.Employee table.
The following example shows how the results of a SELECT query can be used as
the data input into an INSERT statement, supplying the data for multiple rows:

INSERT INTO StudentRoster (NAME,GPA,ID_NUM)
     SELECT FullName,GradeAvg,ID
     FROM temp WHERE SchoolYear = '2004'

See Also

  • ALTER TABLE CREATE TABLE DROP TABLE JOIN SELECT DELETE UPDATE VALUES
  •  Modifying the Database chapter in Using Caché SQL
  •  Defining Tables chapter in Using Caché SQL
  •  Defining Views chapter in Using Caché SQL
  • Transaction Processing in the  Modifying the Database chapter of 
    Using Caché SQL


 #}}}
*%INTERNAL*  #{{{

A format-transformation function that returns an expression in LOGICAL format.
Synopsis

%INTERNAL(expression)

%INTERNAL expression

Arguments

expression  The expression to be converted.

Description
%INTERNAL converts expression to the LOGICAL format, which is used to override
the DISPLAY or ODBC format. The LOGICAL format is the in-memory format of data
(the format upon which operations are performed).
%INTERNAL is a Caché SQL extension.
A stream field cannot be specified as an argument to Caché unary functions,
including all format-transformation functions, with the exception of %INTERNAL.
The %INTERNAL function permits a stream field as an expression value, but
performs no operation on that stream field.
Examples
The following examples shows the internal and external formats of the same
fields. Note that the %EXTERNAL format is the same as the default display
format.
In this example, the internal format is an encoded list:

SELECT FavoriteColors,%INTERNAL(FavoriteColors) AS InternalVal,
%EXTERNAL(FavoriteColors) AS ExternalVal
FROM Sample.Person
In this example, the internal format for Date of Birth (DOB) is the Caché
$HOROLOG counter:

SELECT DOB,%INTERNAL(DOB) AS InternalVal,
%EXTERNAL(DOB) AS ExternalVal
FROM Sample.Person
See Also
%EXTERNAL %ODBCIN %ODBCOUT

 #}}}
*ISNULL*  #{{{

A function that tests for NULL and returns the appropriate expression.
Synopsis

ISNULL(check-expression,replace-expression)

Arguments

check-expression    The expression to be evaluated.

replace-expression  An expression that is returned if check-expression is NULL.

Description
ISNULL evaluates check-expression and returns one of two values:

  • If check-expression is NULL, replace-expression is returned.
  • If check-expression is not NULL, check-expression is returned.

The possible data type(s) of replace-expression must be compatible with the
data type of check-expression. The data type returned in DISPLAY mode or ODBC
mode is determined by the data type of check-expression.
The following table shows the various SQL comparison functions. Each function
returns one value if the comparison tests True (A equals B) and another value
if the comparison tests False (A not equal to B):

      SQL Function             Comparison Test          Return Value

NULLIF                    expression1 = expression2  True = NULL
                                                     False = expression1

IFNULL (2 argument form)  expression1 = NULL         True = expression2
                                                     False = NULL

ISNULL                    expression1 = NULL         True = expression2
                                                     False = expression1

NVL                       expression1 = NULL         True = expression2
                                                     False = expression1

IFNULL (3 argument form)  expression1 = NULL         True = expression2
                                                     False = expression3

Note that the ISNULL function is the same as the NVL function, which is
provided for Oracle compatibility.
Refer to NULL section of the  Language Elements chapter of Using Caché SQL for
further details on NULL handling.
Examples
The following example returns the string 'No Preference' if FavoriteColors is
NULL; otherwise, it returns the value of FavoriteColors:

SELECT Name,
ISNULL(FavoriteColors,'No Preference') AS ColorPref
FROM Sample.Person
Compare the behavior of ISNULL with IFNULL:

SELECT Name,
IFNULL(FavoriteColors,'No Preference') AS ColorPref
FROM Sample.Person
This following example returns the second expression (99) because the first
expression is NULL:

SELECT DISTINCT ISNULL(NULL,99) AS NullTest
FROM Sample.Person
This following example returns the first expression (33) because the first
expression is not NULL:

SELECT DISTINCT ISNULL(33,99) AS NullTest
FROM Sample.Person
See Also
IFNULL ISNUMERIC NVL

 #}}}
*ISNUMERIC*  #{{{

A numeric function that tests for a valid number.
Synopsis

ISNUMERIC(check-expression)

Arguments

check-expression  The expression to be evaluated.

Description
ISNUMERIC evaluates check-expression and returns one of the following values:

  • Returns 1 if check-expression is a valid number.
  • Returns 0 if check-expression is not a valid number.
  • Returns NULL if check-expression is NULL.

ISNUMERIC generates an SQLCODE -7 error if a scientific notation exponent is
greater than 308 (308  (number of integers - 1)). For example, 
ISNUMERIC('1E309') and ISNUMERIC('111E307') both generate this error code.
The ISNUMERIC function is very similar to the Caché ObjectScript $ISVALIDNUM
function. However, these two functions return different values when the input
value is NULL.
Examples
In the following example, all of the ISNUMERIC functions return 1:

SELECT DISTINCT ISNUMERIC(99) AS MyInt,
                ISNUMERIC('-99') AS MyNegInt,
                ISNUMERIC('-0.99') AS MyNegFrac,
                ISNUMERIC('-0.00') AS MyNegZip,
                ISNUMERIC('-0.09'+7) AS MyAdd,
                ISNUMERIC('5E2') AS MyExpon
FROM Sample.Person
The following example returns NULL if FavoriteColors is NULL; otherwise, it
returns 0, because FavoriteColors is not a numeric field:

SELECT Name,
ISNUMERIC(FavoriteColors) AS ColorPref
FROM Sample.Person
See Also

  • SQL functions: IFNULL
  • Caché ObjectScript function: $ISVALIDNUM


 #}}}
*LAST_DAY*  #{{{

A scalar date/time function that returns the date of the last day of the month
for a given date expression.
Synopsis

LAST_DAY(date-expression)

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
LAST_DAY takes a date integer (in $HOROLOG format) or a datetime string. A
datetime string is of the format:

yyyy-mm-dd hh:mm:ss

The time portion of this string is optional.
LAST_DAY returns the date of the last day of the specified month as an integer
in $HOROLOG format. Leap years differences are calculated.
LAST_DAY returns 0 when an invalid date is specified: a year earlier than 1841;
the day or month as zero; the month greater than 12; or the day larger than the
number of days in that month on that year.
Examples
The following examples both return the number 59594 (which corresponds to '2004
 02 29') because the last day of the month on the specified date is February 29
(2004 is a leap year):

SELECT DISTINCT LAST_DAY('2004-02-25')
FROM Sample.Person

SELECT DISTINCT LAST_DAY(59590)
FROM Sample.Person
See Also

  • SQL functions: DATENAME DATEPART DAY DAYOFYEAR MONTH YEAR TO_DATE
  • Caché ObjectScript: $ZDATE function, $HOROLOG special variable


 #}}}
*LAST_IDENTITY*  #{{{

A scalar function that returns the identity of the last row inserted, updated,
or deleted.
Synopsis

LAST_IDENTITY()

Description
The LAST_IDENTITY function takes no arguments. Note that the argument
parentheses are required.
LAST_IDENTITY returns the IDENTITY field value of the last row inserted,
updated, or deleted by the current process. If the table has no IDENTITY field,
it returns the row ID (%ROWID) of the last row inserted, updated, or deleted by
the current process.
The returned value is data type INTEGER.
For further details on IDENTITY fields, see CREATE TABLE. For further details
on %ROWID, see the  Embedded SQL chapter of Using Caché SQL.
Examples
The following example uses two embedded SQL programs to returns the most recent
IDENTITY field value following an INSERT. The first example creates a new table
Sample.Students, and the second example populates this table with data
extracted from Sample.Person.
To demonstrate this, please run the two embedded SQL programs in the order
shown. (It is necessary to use two embedded SQL programs here because embedded
SQL cannot compile an INSERT statement unless the referenced table already
exists.)

   WRITE !,"Creating table"
  &sql(CREATE TABLE Sample.Students (
    StudentName VARCHAR(30),
    StudentAge INTEGER,
    StudentID IDENTITY))
  IF SQLCODE=0 {
    WRITE !,"Created table, SQLCODE=",SQLCODE }
  ELSEIF SQLCODE=-201 {
    WRITE !,"Table already exists, SQLCODE=",SQLCODE }

  WRITE !,"Populating table with data"
  NEW SQLCODE,%ROWCOUNT,%ROWID
  &sql(INSERT INTO Sample.Students (StudentName,StudentAge)
     SELECT Name,Age
     FROM Sample.Person WHERE Age <= '21')
  IF SQLCODE=0 {
    WRITE !,"Number of records inserted=",%ROWCOUNT
    WRITE !,"Row ID of last record inserted=",%ROWID }
  ELSE {
    WRITE !,"Insert failed, SQLCODE=",SQLCODE }
  &sql(SELECT LAST_IDENTITY()
       INTO :bang
       FROM Sample.Students)
    WRITE !,"Last identity is:",bang
  &sql(DROP TABLE Sample.Students)
See Also

  • CREATE TABLE
  • INSERT UPDATE DELETE
  • Embedded SQL in Using Caché SQL


 #}}}
*LCASE*  #{{{

A scalar string function that converts all uppercase letters in a string to
lowercase letters.
Synopsis

{fn LCASE(string-expression)}

Arguments

                   The string expression whose characters are to be converted
                   to lowercase. The expression can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

Description
LCASE converts uppercase letters to lowercase. It has no effects on
non-alphabetic characters. It leaves unchanged punctuation and leading and
trailing blank spaces.
LCASE does not force numerics to be interpreted as a string. Caché SQL converts
numerics to canonical form, removing leading and trailing zeros. Caché SQL does
not convert numeric strings to canonical form.
The LOWER function can also be used convert uppercase letters to lowercase.
The %SQLUPPER function is the preferred way in SQL to convert a data value for
not case-sensitive comparison or collation. Refer to %SQLUPPER for further
information on case transformation functions.
Examples
The following example returns each person’s name in lowercase letters:

SELECT Name,{fn LCASE(Name)} AS LowName
     FROM Sample.Person
LCASE also works on Unicode (non-ASCII) alphabetic characters, as shown in the
following embedded SQL example, which converts Greek letters from uppercase to
lowercase:

   SET a=$CHAR(920,913,923,913,931,931,913)
   &sql(SELECT {fn LCASE(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,a,!,b }
See Also

  • SQL functions: LOWER UCASE
  • Caché ObjectScript function: $ZCONVERT


 #}}}
*LEFT*  #{{{

A scalar string function that returns a specified number of characters from the
beginning (leftmost position) of a string expression.
Synopsis

{fn LEFT(string-expression,count)}

Arguments

                   A string expression, which can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

count              An integer that specifies the number of characters to return
                   from the starting position of string-expression.

Description
LEFT returns the specified number of characters from the beginning of a string.
LEFT does not pad strings; if you specify a larger number of characters than
are in the string, LEFT returns the string. LEFT returns NULL if passed a NULL
value for either argument.
LEFT can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example returns the seven leftmost characters from each name in
the Sample.Person table:

SELECT Name,{fn LEFT(Name,7)}AS ShortName
     FROM Sample.Person
The following embedded SQL example shows how LEFT handles a count that is
longer than the string itself:

   &sql(SELECT Name,{fn LEFT(Name,40)}
   INTO :a,:b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,a,"=original",!,b,"=LEFT 40" }
No padding is performed.
See Also
LTRIM RIGHT RTRIM

 #}}}
*LENGTH*  #{{{

A string function that returns the number of characters in a string expression.
Synopsis

LENGTH(string-expression)

{fn LENGTH(string-expression)}

Arguments

                   A string expression, which can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

Description
LENGTH returns an integer that denotes the number of characters, not the number
of bytes, of the given string expression.

  • LENGTH returns the length of the internal (data storage) value, not the
    display value.
  • LENGTH excludes trailing blanks and the string-termination character. (The 
    CHARACTER_LENGTH, CHAR_LENGTH, and DATA_LENGTH functions do not exclude
    trailing blanks and terminators.)
    LENGTH does not exclude leading blanks. You can remove leading blanks from
    a string using the LTRIM function.
  • LENGTH converts numbers to canonical form, removing leading and trailing
    zeros.
  • LENGTH returns NULL if passed a NULL value, and 0 if passed an empty
    string.
  • LENGTH does not support data stream fields. Specifying a stream field for 
    string-expression results in an SQLCODE -37. (The CHARACTER_LENGTH, 
    CHAR_LENGTH, and DATA_LENGTH functions do support data stream fields.

Note that LENGTH can be used as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
Examples
The following example returns the value 12:

SELECT DISTINCT LENGTH('INTERSYSTEMS') AS CharCount
FROM Sample.Person
The following example removes leading and trailing zeros, and returns a length
of 1:

SELECT DISTINCT {fn LENGTH(00000.00)} AS CharCount
FROM Sample.Person
The following two examples both returns the length of a string with leading and
trailing blanks. The first returns 15, because LENGTH excludes trailing blanks,
but not leading blanks. The second returns 12, because LTRIM excludes the
leading blanks:

SELECT DISTINCT LENGTH('   INTERSYSTEMS      ') AS CharCount
FROM Sample.Person

SELECT DISTINCT LENGTH(LTRIM('   INTERSYSTEMS      ')) AS CharCount
FROM Sample.Person
The following example returns the number of characters in each Name value in
the Sample.Person table:

SELECT Name,{fn LENGTH(Name)} AS CharCount
FROM Sample.Person
ORDER BY CharCount
The following example returns the number of characters in the DOB (date of
birth) field. Note that the length returned (by LENGTH, CHAR_LENGTH, and
CHARACTER_LENGTH) is the internal ($HOROLOG) format of the date, not the
display format. The display length of DOB is ten characters; all three length
functions return the internal length of 5:

SELECT DOB,{fn LENGTH(DOB)} AS LenCount,
CHAR_LENGTH(DOB) AS CCount,
CHARACTER_LENGTH(DOB) AS CtrCount
FROM Sample.Person
The following embedded SQL example gives the length of a string of Unicode
characters. The length returned is the number of characters (7), not the number
of bytes.

   SET a=$CHAR(920,913,923,913,931,931,913)
   &sql(SELECT LENGTH(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"The Greek Sea: ",a,!,$LENGTH(a),!,b }
See Also

  • SQL functions: CHAR_LENGTH CHARACTER_LENGTH DATALENGTH LEN
  • Caché ObjectScript function: $LENGTH


 #}}}
*LEN*  #{{{

A string function that returns the number of characters in a string expression.
Synopsis

LEN(string-expression)

Arguments

                   A string expression, which can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

Description
Note:
The LEN function is an alias for the LENGTH function. LEN is provided for TSQL
compatibility. Refer to LENGTH for further details.
See Also

  • LENGTH


 #}}}
*LIST*  #{{{

An aggregate function that creates a comma-separated list of values.
Synopsis

LIST([ALL | DISTINCT] string-expr [%FOREACH(col-list)] [%AFTERHAVING])

Arguments

ALL           Optional  Specifies that LIST returns a list of all values for 
              string-expr. This is the default if no keyword is specified.

DISTINCT      Optional  Specifies that LIST returns a list containing only the
              unique string-expr values. If not specified, the default is ALL.

string-expr   An SQL expression that evaluates to a string. Usually the name of
              a column from the selected table.

%FOREACH(     Optional  A column name or a comma-separated list of column
col-list)     names. See SELECT for further information on %FOREACH

%AFTERHAVING  Optional  Applies the condition found in the HAVING clause.

Description
The LIST aggregate function returns a comma-separated list of the values in the
specified column. LIST returns a comma-separated list of values; to return a
concatenated string of values, use the very similar XMLAGG function.
A simple LIST (or LIST ALL) returns a string containing a comma-separated list
composed of all the values for string-expr in each group of rows. Rows where 
string-expr is NULL are not included in the list.
The following example creates a comma-separated list of all of the values
listed in the Home_State column of the Sample.Person table.

SELECT LIST(Home_State) AS All_State_Values
FROM Sample.Person
Note that this list contains duplicate values.
A LIST DISTINCT returns a string containing a comma-separated list composed of
all the different values for string-expr in each group of rows. Rows where 
string-expr is the NULL value are not added to the list.
The following example creates a comma-separated list of all of the distinct
(unique) values listed in the Home_State column of the Sample.Person table:

SELECT LIST(DISTINCT Home_State) AS All_Unique_State_Values
FROM Sample.Person
ORDER BY Home_State
Examples
The following example creates a comma-separated list of all of the distinct
values found in the FavoriteColors column of the Sample.Person table. Thus
every row has the same value for the All_Colors column. Note that while some
rows have a NULL value for FavoriteColors, this value is not included in the
lists. Data values are returned in internal format.

SELECT Name,FavoriteColors,
LIST(DISTINCT FavoriteColors) AS All_Colors
FROM Sample.Person
ORDER BY FavoriteColors
The following example creates a comma-separated list of all of the distinct
values found in the Home_City column for each of the states. Every row from the
same state contains a list of all of the distinct city values for that state:

SELECT Home_State, Home_City,
LIST(DISTINCT Home_City %FOREACH(Home_State)) AS All_Cities_In_State
FROM Sample.Person
ORDER BY Home_State
For the following examples, suppose we have the following table, AutoClub:

   Name       Make      Model     Year

Smith,Joe    Pontiac  Firebird    1971

Smith,Joe    Saturn   SW2         1997

Smith,Joe    Pontiac  Bonneville  1999

Jones,Scott  Ford     Mustang     1966

Jones,Scott  Mazda    Miata       2000

The query:

SELECT DISTINCT Name, LIST(Make) AS List_Of_Makes
FROM AutoClub WHERE Name = 'Smith,Joe'

returns:

  Name         List_Of_Makes

Smith,Joe  Pontiac,Saturn,Pontiac

The query:

SELECT DISTINCT Name, LIST(DISTINCT Make) AS List_Of_Makes
FROM AutoClub WHERE Name = 'Smith,Joe'

returns:

  Name      List_Of_Makes

Smith,Joe  Pontiac,Saturn

See Also
Aggregate Functions XMLAGG SELECT

 #}}}
*LOG10*  #{{{

A scalar numeric function that returns the base-10 logarithm of a given numeric
expression.
Synopsis

{fn LOG10(float-expression)}

Arguments

float-expression  An expression of type FLOAT.

Description
LOG10 returns the base-10 logarithm value of float-expression.LOG10 returns a
value of data type FLOAT with a precision of 21 and a scale of 18.
LOG10 can only be used as an ODBC scalar function (with the curly brace
syntax).
Examples
The following example returns the base-10 logarithm of an integer:

SELECT DISTINCT {fn LOG10(5)} AS Log10
FROM Sample.Person
returns .69897000433...
The following embedded SQL example returns the base-10 logarithm values for the
integers 1 through 10:

   SET a=1
   WHILE a<11 {
   &sql(SELECT {fn LOG10(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE
     QUIT }
   ELSE {
     WRITE !,"Log-10 of ",a," = ",b
     SET a=a+1 }
   }
See Also

  • SQL functions: EXP LOG ROUND
  • Caché ObjectScript function: $ZLOG


 #}}}
*LOG*  #{{{

A scalar numeric function that returns the natural logarithm of a given numeric
expression.
Synopsis

{fn LOG(float-expression)}

Arguments

float-expression  An expression of type FLOAT.

Description
LOG returns the natural logarithm (base e) of float-expression. LOG returns a
value of data type FLOAT with a precision of 21 and a scale of 18.
LOG can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example returns the natural logarithm of an integer:

SELECT DISTINCT {fn LOG(5)} AS Logarithm
FROM Sample.Person
returns 1.60943791...
The following embedded SQL example shows the relationship between the LOG and 
EXP functions for the integers 1 through 10:

   SET a=1
   WHILE a<11 {
   &sql(SELECT {fn LOG(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE
     QUIT }
   ELSE {
     WRITE !,"Logarithm of ",a," = ",b }
   &sql(SELECT ROUND({fn EXP(:b)},12)
   INTO :c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE
     QUIT }
   ELSE {
     WRITE !,"Exponential of log ",b," = ",c
     SET a=a+1 }
   }
Note that the ROUND function is needed here to correct for very small
discrepancies caused by system calculation limitations. In the above example, 
ROUND is set arbitrarily to 12 decimal digits for this purpose.
See Also

  • SQL functions: EXP LOG10 ROUND
  • Caché ObjectScript function: $ZLN

 

 #}}}
*LOWER*  #{{{

A string function that converts all uppercase letters in a string expression to
lowercase letters.
Synopsis

LOWER(string-expression)

Arguments

                   The string expression whose characters are to be converted
                   to lowercase. The expression can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

Description
LOWER converts uppercase letters to lowercase. It has no effects on
non-alphabetic characters. It leave unchanged punctuation, numbers, and leading
and trailing blank spaces.
LOWER does not force a numeric to be interpreted as a string. Caché SQL
converts numerics to canonical form, removing leading and trailing zeros. A
numeric specified as a string is not converted to canonical form, and retains
leading and trailing zeros.
The LCASE function can also be used convert uppercase letters to lowercase.
The %SQLUPPER function is the preferred way in SQL to convert a data value for
not case-sensitive comparison or collation. Refer to %SQLUPPER for further
information on case transformation functions.
Examples
The following example returns each person’s name in lowercase letters:

SELECT Name,LOWER(Name) AS LowName
     FROM Sample.Person
LOWER also works on Unicode (non-ASCII) alphabetic characters, as shown in the
following embedded SQL example, which converts Greek letters from uppercase to
lowercase:

   SET a=$CHAR(920,913,923,913,931,931,913)
   &sql(SELECT LOWER(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,a,!,b }
See Also

  • SQL functions: LCASE UCASE
  • Caché ObjectScript function: $ZCONVERT


 #}}}
*LTRIM*  #{{{

A string function that returns a string with the leading blanks removed.
Synopsis

LTRIM(string-expression)

{fn LTRIM(string-expression)}

Arguments

                   A string expression, which can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

Description
LTRIM removes the leading blanks from a string expression, and returns the
string as type VARCHAR. If string-expression is NULL, LTRIM returns NULL. If 
string-expression is a string consisting entirely of blank spaces, LTRIM
returns the empty string ('').
LTRIM leave trailing blanks; to remove trailing blanks, use RTRIM. To remove
leading and/or trailing characters of any type, use TRIM. To add blanks, use 
SPACE.
Note that LTRIM can be used as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
Examples
The following embedded SQL example removes the five leading blanks from the
string. It leaves the five trailing blanks:

   SET a="     Test string with 5 leading and 5 trailing spaces.     "
   &sql(SELECT {fn LTRIM(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Before LTRIM",!,"start:",a,":end"
     WRITE !,"After LTRIM",!,"start:",b,":end" }
Returns:

Before LTRIM
start:     Test string with 5 leading and 5 trailing spaces.     :end
After LTRIM
start:Test string with 5 leading and 5 trailing spaces.     :end

See Also
RTRIM TRIM SPACE

 #}}}
*MAX*  #{{{

An aggregate function that returns the maximum data value in a specified
column.
Synopsis

MAX([ALL | DISTINCT] expression)

Arguments

            Optional  Applies the aggregate function to all values. ALL has no
ALL         effect on the value returned by MAX. It is provided for SQL-92
            compatibility.

            Optional  Specifies that each unique value is considered. DISTINCT
DISTINCT    has no effect on the value returned by MAX. It is provided for
            SQL-92 compatibility.

expression  Any valid expression. Usually the name of a column that contains
            the values from which the maximum value is to be returned.

Description
The MAX aggregate function returns the largest (maximum) of the values of 
expression. Commonly, expression is the name of a field, (or an expression
containing one or more field names) in the multiple rows returned by a query.
MAX can be used in a SELECT query or subquery that references either a table or
a view. MAX can appear in a SELECT list or HAVING clause alongside ordinary
field values.
MAX cannot be used in a WHERE clause. MAX cannot be used in the ON clause of a
JOIN, unless the SELECT is a subquery.
Unlike most other aggregate functions, the ALL and DISTINCT keywords perform no
operation in MAX. They are provided for SQL 92 compatibility.
Data Values
The specified field used by MAX can be numeric or nonnumeric. Maximum is
defined as highest in collation sequence: thus 'Z' is the maximum alphabetic
value. By default, alphabetic characters are converted to uppercase collation
before comparison. Empty string ('') values are treated as zero (0).
For numeric values, the scale returned is the same as the expression scale.
NULL values in data fields are ignored when deriving a MAX aggregate function
value. If no rows are returned by the query, or the data field value for all
rows returned is NULL, MAX returns NULL.
Changes Made During the Current Transaction
Like all aggregate functions, MAX always returns the current state of the data,
including uncommitted changes, regardless of the current transaction’s
isolation level. For further details, refer to SET TRANSACTION and START
TRANSACTION.
Examples
The following query returns the highest (maximum) salary in the Sample.Employee
database:

SELECT MAX(Salary) As TopSalary
     FROM Sample.Employee
The following query returns the lowest (minimum) and highest (maximum) name in
collation sequence found in the Sample.Employee database:

SELECT Name,MIN(Name),MAX(Name)
     FROM Sample.Employee
Note that MIN and MAX convert Name values to uppercase before comparison.
The following query returns the highest (maximum) salary for an employee whose
Home_State is 'VT' in the Sample.Employee database:

SELECT MAX(Salary)
     FROM Sample.Employee
     WHERE Home_State = 'VT'
The following query returns the number of employees and the highest (maximum)
employee salary for each Home_State in the Sample.Employee database:

SELECT Home_State,
     COUNT(Home_State) As NumEmployees,
     MAX(Salary) As TopSalary
     FROM Sample.Employee
     GROUP BY Home_State
     ORDER BY TopSalary
See Also
MIN

 #}}}
*MIN*  #{{{

An aggregate function that returns the minimum data value in a specified
column.
Synopsis

MIN([ALL | DISTINCT] expression)

Arguments

            Optional  Applies the aggregate function to all values. ALL has no
ALL         effect on the value returned by MIN. It is provided for SQL-92
            compatibility.

            Optional  Specifies that each unique value is considered. DISTINCT
DISTINCT    has no effect on the value returned by MIN. It is provided for
            SQL-92 compatibility.

expression  Any valid expression. Usually the name of a column that contains
            the values from which the minimum value is to be returned.

Description
The MIN aggregate function returns the smallest (minimum) of the values of 
expression. Commonly, expression is the name of a field, (or an expression
containing one or more field names) in the multiple rows returned by a query.
MIN can be used in a SELECT query or subquery that references either a table or
a view. MIN can appear in a SELECT list or HAVING clause alongside ordinary
field values.
MIN cannot be used in a WHERE clause. MIN cannot be used in the ON clause of a
JOIN, unless the SELECT is a subquery.
Unlike most other aggregate functions, the ALL and DISTINCT keywords perform no
operation in MIN. They are provided for SQL 92 compatibility.
Data Values
The specified field used by MIN can be numeric or nonnumeric. Minimum is
defined as lowest in collation sequence: thus 'a' is the minimum alphabetic
value. By default, alphabetic characters are converted to uppercase collation
before comparison. For numeric fields, the empty string ('') is considered the
minimum value, even when a zero (0) or a negative number value is present.
For numeric values, the scale returned is the same as the expression scale.
NULL values in data fields are ignored when deriving a MIN aggregate function
value. If no rows are returned by the query, or the data field value for all
rows returned is NULL, MIN returns NULL.
Changes Made During the Current Transaction
Like all aggregate functions, MIN always returns the current state of the data,
including uncommitted changes, regardless of the current transaction’s
isolation level. For further details, refer to SET TRANSACTION and START
TRANSACTION.
Examples
The following query returns the lowest (minimum) salary in the Sample.Employee
database:

SELECT MIN(Salary) As LowSalary
     FROM Sample.Employee
The following query returns the lowest (minimum) and highest (maximum) name in
collation sequence found in the Sample.Employee database:

SELECT Name,MIN(Name),MAX(Name)
     FROM Sample.Employee
Note that MIN and MAX convert Name values to uppercase before comparison.
The following query returns the lowest (minimum) salary for an employee whose
Home_State is 'VT' in the Sample.Employee database:

SELECT MIN(Salary)
     FROM Sample.Employee
     WHERE Home_State = 'VT'
The following query returns the number of employees and the lowest (minimum)
employee salary for each Home_State in the Sample.Employee database:

SELECT Home_State,
     COUNT(Home_State) As NumEmployees,
     MIN(Salary) As LowSalary
     FROM Sample.Employee
     GROUP BY Home_State
     ORDER BY LowSalary
See Also
MAX

 #}}}
*MINUTE*  #{{{

A scalar date/time function that returns an integer from 0 to 59 that
corresponds to the minute component in a given date-time expression.
Synopsis

{fn MINUTE(time-expression)}

Arguments

                 An expression that is the name of a column, the result of
                 another scalar function, or a string or numeric literal. It
time-expression  must resolve either to a datetime string or a time integer,
                 where the underlying data type can be represented as TIME or
                 TIMESTAMP.

Description
MINUTE returns the minutes portion of a time integer or a datetime string. A
datetime string is of the format:

yyyy-mm-dd hh:mm:ss

To change this default time format, use the SET OPTION command.
Note that you can supply a time integer (number of elapsed seconds), but not a
time string (hh:mm:ss). You must supply a datetime string (yyyy-mm-dd
hh:mm:ss). You can omit the seconds (:ss) portion of a datetime string and
still return the minutes portion.
The minutes (mm) portion should be an integer in the range from 0 through 59.
There is, however, no range checking for user-supplied values. Numbers greater
than 59, negative numbers and fractions are returned as specified. Leading
zeros are optional on input; leading zeros are suppressed on output.
MINUTE returns zero minutes when the minutes portion is '0', '00', or a
nonnumeric value. Zero minutes is also returned if no time expression is
supplied, or the minutes portion of the time expression is omitted entirely
('hh', 'hh:', 'hh::', or 'hh::ss'), or if the time expression format is
invalid.
The same time information can be returned using DATEPART or DATENAME.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.MINUTE(time-expression)
Examples
The following examples both return the number 45 because it is the forty-fifth
minute of the time expression in the datetime string:

SELECT DISTINCT {fn MINUTE('2000-02-16 18:45:38')} AS Minutes_Given
FROM Sample.Person

SELECT DISTINCT {fn MINUTE(67538)} AS Minutes_Given
FROM Sample.Person
The following example also returns 45. As shown here, the seconds portion of
the time value can be omitted:

SELECT DISTINCT {fn MINUTE('2000-02-16 18:45')} AS Minutes_Given
FROM Sample.Person
The following example returns 0 minutes because the time expression has been
omitted from the datetime string:

SELECT DISTINCT {fn MINUTE('2000-02-16')} AS Minutes_Given
FROM Sample.Person
The following examples all return the minutes portion of the current time.
CURRENT_TIME and CURTIME supply a time string; NOW supplies a datetime string:

SELECT DISTINCT {fn MINUTE(CURRENT_TIME)} AS Minutes_Now1,
                {fn MINUTE({fn CURTIME()})} AS Minutes_Now2,
                {fn MINUTE({fn NOW()})} AS Minutes_Now3
FROM Sample.Person
The following example shows that leading zeros are suppressed. The first MINUTE
function returns a length 2, the others return a length of 1. An omitted time
is considered to be 0 minutes, which has a length of 1:

SELECT DISTINCT LENGTH({fn MINUTE('2004-02-05 11:45:00')}),
                LENGTH({fn MINUTE('2004-02-15 03:05:00')}),
                LENGTH({fn MINUTE('2004-02-15 3:5:0')}),
                LENGTH({fn MINUTE('2004-02-15')})
FROM Sample.Person
The following Embedded SQL example shows that the MINUTE function recognizes
the TimeSeparator character specified for the locale:

  DO ##class(%SYS.NLS.Format).SetFormatItem("TimeSeparator",".")
  &sql(SELECT DISTINCT {fn MINUTE('2000-02-16 18.45.38')}
  INTO :a
  FROM Sample.Person)
  WRITE "minutes=",a
See Also

  • SQL concepts: Data Type Date and Time Constructs
  • SQL functions: HOUR SECOND CURRENT_TIME CURTIME NOW DATEPART DATENAME
  • Caché ObjectScript: $ZTIME function $HOROLOG special variable $ZTIMESTAMP
    special variable


 #}}}
*MOD*  #{{{

A scalar numeric function that returns the modulus (remainder) of a number
divided by another.
Synopsis

{fn MOD(dividend,divisor)}

Arguments

dividend  A number that is the numerator (dividend) of the division.

divisor   A number that is the denominator (divisor) of the division.

Description
MOD returns the mathematical remainder (modulus) from the dividend by the
divisor. It returns a negative or zero result for a division involving a
negative divisor. MOD returns NULL if passed a NULL value for either argument.
The value returned is of data type NUMERIC.
MOD can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example shows the remainder returned by MOD.

SELECT DISTINCT {fn MOD(5,3)} AS Remainder
FROM Sample.Person
returns 2.
The following example shows the remainder returned by MOD with a negative
dividend.

SELECT DISTINCT {fn MOD(-5,3)} AS Remainder
FROM Sample.Person
returns 1.
The following example shows the remainder returned by MOD with a negative
divisor.

SELECT DISTINCT {fn MOD(5,-3)} AS Remainder
FROM Sample.Person
returns  1.
See Also
CEILING FLOOR ROUND TRUNCATE

 #}}}
*MONTH*  #{{{

A date/time function that returns an integer from 1 to 12 that corresponds to
the month in a given date expression.
Synopsis

MONTH(date-expression)
{fn MONTH(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
MONTH returns the month portion of a date integer or a datetime string. A
datetime string is of the format:

yyyy-mm-dd hh:mm:ss

The month (mm) portion should be an integer in the range from 1 through 12.
There is, however, no range checking for user-supplied values. Numbers greater
than 12, zero, and fractions are returned as specified. Because ( ) is used as
a separator character, negative numbers are not supported. Leading zeros are
optional on input. Leading and trailing zeros are suppressed on output.
MONTH returns zero when the month portion is '0', '00', or a nonnumeric value.
Zero is also returned if the month portion of the date string is omitted
entirely ('yyyy  dd'), or if no date expression is supplied.
MONTH interprets the second numeric string encountered in a date string as the
month value, so omitting the year portion of the date string ('mm-dd
hh:mm:ss'), results in the second number encountered ('dd') being treated as
the month value. Thus, a leading hyphen or some placeholder should be supplied
for an unknown year value; for compatibility with Caché, 9999 is generally the
preferred default year value.
Note that MONTH can be invoked as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.MONTH(date-expression)
The elements of a datetime string can be returned using the following SQL
functions: YEAR, MONTH, DAY (or DAYOFMONTH), HOUR, MINUTE, and SECOND. The same
elements can be returned by using the DATEPART or DATENAME function. Date
elements can be returned using TO_DATE. DATEPART and DATENAME performs value
and range checking on month values.
The LAST_DAY function returns the date of the last day of the specified month.
Examples
The following examples both return the number 2 because February is the second
month of the year:

SELECT DISTINCT MONTH('2000-02-16') AS Month_Given
FROM Sample.Person

SELECT DISTINCT {fn MONTH(59589)} AS Month_Given
FROM Sample.Person
The following examples returns zero because the month is omitted:

SELECT DISTINCT MONTH('2000--16') AS Month_Given
FROM Sample.Person

SELECT DISTINCT {fn MONTH('12:34:55')} AS Month_Given
FROM Sample.Person

SELECT DISTINCT MONTH('2000 12:34:55') AS Month_Given
FROM Sample.Person
The following example returns the number 2 because a placeholder character (-)
has been supplied for the omitted year:

SELECT DISTINCT {fn MONTH('-02-16')} AS Month_Given
FROM Sample.Person
The following examples return the current month:

SELECT DISTINCT {fn MONTH({fn NOW()})} AS Month_Now
FROM Sample.Person

SELECT DISTINCT MONTH(CURRENT_DATE) AS Month_Now
FROM Sample.Person
See Also

  • SQL functions: DATEPART DATENAME DAYOFMONTH LAST_DAY MONTHNAME TO_DATE
  • Caché ObjectScript function: $ZDATE


 #}}}
*MONTHNAME*  #{{{

A scalar date/time function that returns a character string containing the name
of the month in a given date expression.
Synopsis

{fn MONTHNAME(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
MONTHNAME takes as input a date integer or a datetime string. A datetime string
has the following format:

yyyy-mm-dd hh:mm:ss

It returns the names of the calendar months, January through December.
MONTHNAME checks that the date supplied is a valid date. The year must be
between 1841 and 9999 (inclusive), the month 01 through 12, and the day
appropriate for that month (for example, 02/29 is only valid on leap years). If
the date is not valid, MONTHNAME sets SQLCODE = -400 (fatal error occurred).
The names of months default to the full-length American English month names. To
change these month name values, use the SET OPTION command with the MONTH_NAME
option.
The same month name information can be returned by using the DATENAME function.
You can use TO_DATE to retrieve a month name or a month name abbreviation with
other date elements. To return an integer corresponding to the month, use MONTH
DATEPART or TO_DATE.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.MONTHNAME(date-expression)
Examples
The following examples both return the character string "February" because it
is the month of the date expression (February 16, 2000):

SELECT DISTINCT {fn MONTHNAME('2000-02-16')} AS NameOfMonth
FROM Sample.Person

SELECT DISTINCT {fn MONTHNAME(59589)} AS NameOfMonth
FROM Sample.Person
The following examples return the current month:

SELECT DISTINCT {fn MONTHNAME({fn NOW()})} AS NameMonthNow
FROM Sample.Person

SELECT DISTINCT {fn MONTHNAME(CURRENT_DATE)} AS NameMonthNow
FROM Sample.Person
The following embedded SQL example shows how MONTHNAME responds to an invalid
date (the year 2001 was not a leap year):

   SET testdate="2001-02-29"
   &sql(SELECT {fn MONTHNAME(:testdate)} AS NameOfMonth
   INTO :a
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"returns: ",a }
   QUIT
The SQLCODE -400 error code is issued.
See Also

  • SQL functions: DATEPART DATENAME DAYOFMONTH MONTH TO_DATE
  • Caché ObjectScript function: $ZDATE


 #}}}
*%MVR*  #{{{

A case-transformation function that converts characters to the MultiValue
collation format.
Synopsis

%MVR(expression)

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

Description
%MVR returns expression in the MultiValue collation sequence. This collation
sequence orders pure numeric values (values for which x=+x) in numeric order
first, followed by all other characters in string order.
The %MVR collation sequence for strings only differs from %EXACT collation
sequence in the handling of NULL. %MVR converts NULL. %EXACT passes through
NULL unchanged.
%MVR is a Caché SQL extension and is intended for MultiValue data
compatibility.
You can perform the same collation conversion in Caché ObjectScript using the
$ZUTIL(28) function. This function can also be invoked from Caché ObjectScript
using the following method call:
$SYSTEM.SQL.MVR(expression)
Examples
The following examples show the difference between the %MVR and %EXACT
collation.
The first example shows the FavoriteColors field with %EXACT collation; rows
with NULL for this field are returned.

SELECT TOP 10 Name,FavoriteColors
FROM Sample.Person
WHERE %EXACT(FavoriteColors) IS NULL
The second example shows the FavoriteColors field with %MVR collation; no rows
are returned.

SELECT TOP 10 Name,FavoriteColors
FROM Sample.Person
WHERE %MVR(FavoriteColors) IS NULL
See Also
ASCII %EXACT %SQLSTRING %STRING

 #}}}
*NOW*  #{{{

A scalar date/time function that returns the current date and time.
Synopsis

{fn NOW()}
{fn NOW}

Description
NOW takes no arguments and returns the date and time as type TIMESTAMP. Note
that the argument parentheses are optional.
It returns the current date and time in the format:

yyyy-mm-dd hh:mm:ss

Hours are represented in 24 hour format. Leading zeros are retained for all
fields.
To change the default datetime string format, use the SET OPTION command with
the various date and time options.
The CURRENT_TIMESTAMP and GETDATE functions can also be used to return the
current date and time. These functions supports precision of fractional
seconds; NOW does not support precision. These functions all use the TIMESTAMP
data type.
To return just the current date, use CURDATE or CURRENT_DATE. To return just
the current time, use CURRENT_TIME or CURTIME. The functions use the DATE or
TIME data type. None of these functions support precision.
These data types perform differently when using embedded SQL. A TIMESTAMP data
type stores and displays its value in the same format. The TIME and DATE data
types store their values as integers in $HOROLOG format; when displayed in SQL
they are converted to date or time display format; when returned from embedded
SQL they are returned as integers. You can use the CAST or CONVERT function to
change the datatype of dates and times.
All Caché SQL timestamp functions are specific to the local time zone setting.
To get a current timestamp that is universal (independent of time zone) use the
Caché ObjectScript $ZTIMESTAMP special variable.
Examples
The following examples both return the current system date and time:

SELECT DISTINCT {fn NOW()} AS DateTime
FROM Sample.Person

SELECT DISTINCT {fn NOW} AS DateTime
FROM Sample.Person
The following embedded SQL example compares local (time zone specific) and
universal (time zone independent) time stamps:

  SET b=$ZDATETIME($ZTIMESTAMP,3)
  &sql(SELECT {fn NOW}
  INTO :a
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"SQL Now is:    ",a
    WRITE !,"ZTimestamp is: ",b }
The following example sets the LastUpdate field in the selected row of the
Orders table to the current system date and time:

UPDATE Orders SET LastUpdate = {fn NOW()}
  WHERE Orders.OrderNumber=:ord

See Also

  • SQL concepts: Data Type Date and Time Constructs
  • SQL timestamp functions: CAST CONVERT CURRENT_TIMESTAMP GETDATE
    TIMESTAMPADD TIMESTAMPDIFF
  • SQL current date and time functions: CURDATE CURRENT_DATE CURRENT_TIME
    CURTIME
  • Caché ObjectScript: $ZDATETIME function $HOROLOG special variable
    $ZTIMESTAMP special variable


 #}}}
*NULLIF*  #{{{

A function that returns NULL if an expression is true.
Synopsis

NULLIF(expression1,expression2)

Arguments

expression1  An SQL expression.

expression2  An SQL expression.

Description
The NULLIF function returns NULL if expression1 is equal to expression2,
otherwise it returns expression1. The data type returned in DISPLAY mode or
ODBC mode is determined by the data type of expression1.
NULLIF is equivalent to:

SELECT CASE
WHEN value1 = value2 THEN NULL
ELSE value1
END
FROM MyTable

The following table shows the various SQL comparison functions. Each function
returns one value if the comparison tests True (A equals B) and another value
if the comparison tests False (A not equal to B):

      SQL Function             Comparison Test          Return Value

NULLIF                    expression1 = expression2  True = NULL
                                                     False = expression1

IFNULL (2 argument form)  expression1 = NULL         True = expression2
                                                     False = NULL

ISNULL                    expression1 = NULL         True = expression2
                                                     False = expression1

NVL                       expression1 = NULL         True = expression2
                                                     False = expression1

IFNULL (3 argument form)  expression1 = NULL         True = expression2
                                                     False = expression3

Examples
The following example uses the NULLIF function to set to null the display field
of all records with Age=20:

SELECT Name,Age,NULLIF(Age,20) AS Nulled20
FROM Sample.Person
See Also
CASE IFNULL ISNULL

 #}}}
*NVL*  #{{{

A function that tests for NULL and returns the appropriate expression.
Synopsis

NVL(check-expression,replace-expression)

Arguments

check-expression    The expression to be evaluated.

replace-expression  The expression that is returned if check-expression is
                    NULL.

Description
NVL evaluates check-expression and returns one of two values:

  • If check-expression is NULL, replace-expression is returned.
  • If check-expression is not NULL, check-expression is returned.

The arguments check-expression and replace-expression can have any data type.
If their data types are different, Caché converts replace-expression to the
data type of check-expression before comparing them. The data type of the
return value is always the same as the data type of check-expression, unless 
check-expression is character data, in which case the return value’s data type
is VARCHAR2.
The following table shows the various SQL comparison functions. Each function
returns one value if the comparison tests True (A equals B) and another value
if the comparison tests False (A not equal to B):

      SQL Function             Comparison Test          Return Value

NULLIF                    expression1 = expression2  True = NULL
                                                     False = expression1

IFNULL (2 argument form)  expression1 = NULL         True = expression2
                                                     False = NULL

ISNULL                    expression1 = NULL         True = expression2
                                                     False = expression1

NVL                       expression1 = NULL         True = expression2
                                                     False = expression1

IFNULL (3 argument form)  expression1 = NULL         True = expression2
                                                     False = expression3

Note that NVL is supported for Oracle compatibility, and is the same as the 
ISNULL function.
Refer to NULL section of the  Language Elements chapter of Using Caché SQL for
further details on NULL handling.
Example
This following example returns the replace-expression (99) because the 
check-expression is NULL:

SELECT DISTINCT NVL(NULL,99) AS NullTest
FROM Sample.Person
This following example returns the check-expression (33) because 
check-expression is not NULL:

SELECT DISTINCT NVL(33,99) AS NullTest
FROM Sample.Person
The following example returns the string 'No Preference' if FavoriteColors is
NULL; otherwise, it returns the value of FavoriteColors:

SELECT Name,
NVL(FavoriteColors,'No Preference') AS ColorPref
FROM Sample.Person
See Also
ISNULL IFNULL

 #}}}
*%OBJECT*  #{{{

A scalar function that opens a stream object and returns the corresponding
oref.
Synopsis

%OBJECT(stream)

Arguments

stream  An expression that is the name of a stream field.

Description
%OBJECT returns the oref (object reference) of a stream field.
You can perform the same operation from Caché ObjectScript by issuing a SELECT
on a stream field; a SELECT returns the oref of the opened stream object.
You can then get an oref from an oid (object ID) by using the following class
method:
DO ##class(%STREAM.Object).%OPEN(oid)
If stream is not a stream field, %OBJECT generates an SQLCODE -128 error.
%OBJECT can be used as an argument to the following functions:

  • CHARACTER_LENGTH(%OBJECT(streamfield)), CHAR_LENGTH(%OBJECT(streamfield)),
    or DATALENGTH(%OBJECT(streamfield)).
  • SUBSTRING(%OBJECT(streamfield),start,length).

See Also

  • SELECT
  • BLOBs and CLOBs chapter of Using Caché SQL


 #}}}
*%ODBCIN*  #{{{

A format-transformation function that returns an expression in Logical format.
Synopsis

%ODBCIN(expression)

%ODBCIN expression

Arguments

expression  The expression to be converted.

Description
%ODBCIN returns expression in the Logical format after passing the value
through the field or data type’s OdbcToLogical method. The Logical format is
the in-memory format of data (the format upon which operations are performed).
%ODBCIN is a Caché SQL extension.
Examples
The following example shows the default display format, the %ODBCIN, and the 
%ODBCOUT formats for the same field.

SELECT FavoriteColors,%ODBCIN(FavoriteColors) AS InVal,
%ODBCOUT(FavoriteColors) AS OutVal
FROM Sample.Person
See Also
%EXTERNAL %INTERNAL %ODBCOUT

 #}}}
*%ODBCOUT*  #{{{

A format-transformation function that returns an expression in ODBC format.
Synopsis

%ODBCOUT(expression)

%ODBCOUT expression

Arguments

expression  The expression to be converted.

Description
%ODBCOUT returns expression in the ODBC format after passing the value through
the field or data type’s LogicalToOdbc method. The ODBC format is the format in
which data can be presented via ODBC. This format is used when data is exposed
to ODBC/SQL. The available formats correspond to those defined by ODBC.
%ODBCOUT is a Caché SQL extension.
Examples
The following example shows the default display format, the %ODBCIN, and the 
%ODBCOUT formats for the same field.

SELECT FavoriteColors,%ODBCIN(FavoriteColors) AS InVal,
%ODBCOUT(FavoriteColors) AS OutVal
FROM Sample.Person
See Also
%EXTERNAL %INTERNAL %ODBCIN

 #}}}
*%OID*  #{{{

A scalar function that returns OID of an ID field.
Synopsis

%OID(id_field)

Arguments

id_field  The field name of an ID field, or a reference field.

Description
%OID takes a field name and returns the fully formed OID (object ID) for the
object. The field must be either an ID field or a reference field (a foreign
key field). Specifying any other type of field in id_field generates an SQLCODE
-1 error.
Examples
The following example shows %OID used with a reference field:

SELECT Name, Spouse, %OID(Spouse)
FROM Sample.Person
WHERE Spouse IS NOT NULL
The following Embedded SQL example shows %OID used with a reference field:

  &sql(SELECT Name, Spouse, %OID(Spouse)
       INTO :n,:s,:soid
       FROM Sample.Person)
  WRITE !,"Name is:",n
  WRITE !,"Spouse name is:",s
  WRITE !,"Spouse OID is:",soid
See Also

  • SELECT
  • %OBJECT


 #}}}
*OPEN_sql*  #{{{

Opens a cursor.
Synopsis

OPEN cursor-name

Arguments

             The name of the cursor, which has already been declared. The
cursor-name  cursor name was specified in the DECLARE statement. Cursor names
             are case-sensitive.

Description
An OPEN statement opens a cursor according to the parameters specified in the
cursor’s DECLARE statement. Once opened, a cursor can be fetched. An open
cursor must be closed.
Attempting to open a cursor that is already open results in an SQLCODE -101
error. Attempting to fetch or close a cursor that is not open results in an
SQLCODE -102 error.
As an SQL statement, this is only supported from embedded SQL. Equivalent
operations are supported through ODBC using the ODBC API.
Example
The following embedded SQL example shows a cursor (named EmpCursor) being
opened and closed:

   SET name="LastName,FirstName",state="##"
   &sql(DECLARE EmpCursor CURSOR FOR
        SELECT Name, Home_State
        INTO :name,:state FROM Sample.Person
        WHERE Home_State %STARTSWITH 'A')
   WRITE !,"BEFORE: Name=",name," State=",state
   &sql(OPEN EmpCursor)
   NEW SQLCODE,%ROWCOUNT,%ROWID
   FOR { &sql(FETCH EmpCursor)
        QUIT:SQLCODE
        WRITE !,"DURING: Name=",name," State=",state }
   WRITE !,"FETCH status SQLCODE=",SQLCODE
   WRITE !,"Number of rows fetched=",%ROWCOUNT
   &sql(CLOSE EmpCursor)
   WRITE !,"AFTER: Name=",name," State=",state
See Also

  • CLOSE DECLARE FETCH
  • SQL Cursors in the  Using Embedded SQL chapter of Using Caché SQL


 #}}}
*%PATTERN_sql* #{{{
Compares a pattern match string to each data value in a query.
Synopsis

scalar-expression %PATTERN pattern

Arguments
scalar-expression 	A scalar expression (most commonly a data column) whose values are being compared with pattern.
pattern 	A quoted string representing the pattern of characters to match with each value in scalar-expression.
Description
The %PATTERN predicate allows you to match a pattern of character type codes and literals to the data values supplied by scalar-expression. If pattern matches a complete scalar expression value, this value is returned. If pattern does not fully match any of the scalar expression values, %PATTERN returns the null string.
%PATTERN, like the other comparison conditions, is used in the WHERE clause or the HAVING clause of a SELECT statement.
%PATTERN uses the same pattern codes as the Caché ObjectScript pattern match operator (the ? operator). A pattern consists of one or more pairs of a repetition count followed by a value. A repetition count can be an integer, a period (.) meaning “any number of characters”, or a range specified by using a combination of a period with integers. A value can be either a character type code letter or a literal string (specified in quotes).
Note that a pattern often consists of multiple repetition/value pairs, because the pattern must exactly match the entire data value. For this reason, many patterns end with the “.E” pair, which means that the rest of the data value can consist of any number of characters of any type.
A few simple examples of pattern match pairs:

    *
      1L means one (and only one) lowercase letter.
    *
      1"L" means one literal character “L”.
    *
      1"617" means one literal string “617”.
    *
      .U means any number of uppercase letters.
    *
      .E means any number of printable characters of any type.
    *
      .3A means any number up to three (three or less) letters (either uppercase or lowercase).
    *
      3.N means three or more numeric digits.
    *
      3.6N means three to six (inclusive) numeric digits.

For further details on pattern codes, refer to Pattern Matching in the Operators and Expressions chapter of Using Caché ObjectScript.
Examples
The following example uses a %PATTERN operator in the WHERE clause to select Home_State values in which the first character is any uppercase letter and the second character is the letter “C”:

SELECT Name,Home_State FROM Sample.Person
WHERE Home_State %PATTERN '1U1"C"'

This example selects records with a Home_State of North Carolina (NC) or South Carolina (SC).
The following example uses a %PATTERN operator in the WHERE clause to select Name values that start with an uppercase letter followed by a lowercase letter.

SELECT Name FROM Sample.Person
WHERE Name %PATTERN '1U1L.E'

The pattern here translates as: 1U (one uppercase letter), followed 1L (one lowercase letter), followed by .E (any number of characters of any type). Note that this pattern would exclude names such as ”JONES”, O'Reilly” and “deGastyne”.
The following example uses a %PATTERN operator in a HAVING clause to select records for people whose first name starts with the letters “Jo”, and to return the count of records searched and records returned.

SELECT Name,
       COUNT(Name) AS TotRecs,
       COUNT(Name %AFTERHAVING) AS JoRecs
FROM Sample.Person
HAVING Name %PATTERN '1U.L1","1"Jo".E'

In this case, the Name field values are formatted as Lastname,Firstname and may contain an optional middle name or initial. To reflect this name format, the pattern here translates as: 1U (one uppercase letter), followed .L (any number of lowercase letters), followed by 1"," (one literal comma character), followed by 1"Jo" (one literal string with the value “Jo”), followed by .E (any number of characters of any type).
See Also

    *
      SELECT statement HAVING clause WHERE clause
    *
      LIKE predicate
    *
      Overview of Predicates
 #}}}
*PI*  #{{{

A scalar numeric function that returns the constant value of pi.
Synopsis

{fn PI()}
{fn PI}

Description
PI takes no arguments. It returns the mathematical constant pi as type FLOAT
with a precision of 19 and a scale of 18.
PI can only be used as an ODBC scalar function (with the curly brace syntax).
Note that the argument parentheses are optional.
Examples
The following examples both return the value of pi:

SELECT DISTINCT {fn PI()} AS ExactPi
FROM Sample.Person

SELECT DISTINCT {fn PI} AS ExactPi
FROM Sample.Person
returns 3.141592653589793238.
See Also

  • SQL functions: ROUND
  • Caché ObjectScript special variable: $ZPI


 #}}}
*POSITION*  #{{{

A string function that returns the position of a string expression within a
string.
Synopsis

POSITION(string-expression-1 IN string-expression-2)

Arguments

                     The string expression to search for. It can be the name of
                     a column, a string literal, or the result of another
string-expression-1  scalar function, where the underlying data type can be
                     represented as any character type (such as CHAR or
                     VARCHAR2).

string-expression-2  The string expression within which to search for 
                     string-expression-1.

Description
POSITION returns the position of the first location of string-expression-1
within string-expression-2. The position is returned as an integer. If 
string-expression-1 is not found, 0 (zero) is returned. POSITION returns NULL
if passed a NULL value for either argument.
POSITION is case-sensitive. Use one of the case-conversion functions to locate
both uppercase and lowercase instances of a letter or character string.
Examples
The following example returns 11, because  b is the 11th character in the
string:

SELECT DISTINCT POSITION('b' IN 'The quick brown fox') AS PosInt
FROM Sample.Person
The following example returns the length of the last name (surname) for each
name in the Sample.Person table. It locates the comma used to separate the last
name from the rest of the name field, then subtracts 1 from that position:

SELECT Name,
POSITION(',' IN Name)-1 AS LNameLen
FROM Sample.Person
The following example returns the position of the first instance of the letter
 B in each name in the Sample.Person table. Because POSITION is case-sensitive,
the %SQLUPPER function is used to convert all name values to uppercase before
performing the search. Because %SQLUPPER adds a blank space at the beginning of
a string, this example subtracts 1 to get the actual letter position. Searches
that do not locate the specified string return zero (0); in this example,
because of the subtraction of 1, the value displayed for these searches is  1:

SELECT Name,
POSITION('B' IN %SQLUPPER(Name))-1 AS BPos
FROM Sample.Person

 #}}}
*POWER*  #{{{

A numeric function that returns the value of a given expression raised to the
specified power.
Synopsis

POWER(numeric-expression,power)
{fn POWER(numeric-expression,power)}

Arguments

numeric-expression  The base number.

power               The exponent, which is the power to which to raise 
                    numeric-expression.

Description
POWER calculates one number raised to the power of another. The resulting value
is returned in the same type as numeric-expression. POWER returns NULL if
passed a NULL value for either argument.
POWER returns a value of data type FLOAT with a precision of 36 and a scale of
18.
Note that POWER can be invoked as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
Examples
The following example raises 5 to the 3rd power:

SELECT DISTINCT POWER(5,3) AS Cubed
FROM Sample.Person
returns 125.
The following embedded SQL example returns the first 16 powers of 2:

   SET a=1
   WHILE a<17 {
   &sql(SELECT {fn POWER(2,:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE
     QUIT }
   ELSE {
     WRITE !,"2 to the ",a," = ",b
     SET a=a+1 }
   }
See Also

  • SQL functions: EXP LOG10 SQRT
  • Caché ObjectScript function: $ZPOWER


 #}}}
*QUARTER*  #{{{

A scalar date/time function that returns an integer from 1 through 4 that
corresponds to the quarter of the year in a given date expression.
Synopsis

{fn QUARTER(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
QUARTER takes a date integer or a datetime string, and returns the quarter of
the calendar year as an integer. A datetime string is of the format:

yyyy-mm-dd hh:mm:ss

The time periods for the four quarters are as follows:

Quarter     Period (inclusive)

1        January 1 to March 31

2        April 1 to June 30

3        July 1 to September 30

4        October 1 to December 31

QUARTER evaluates only the month portion of the datetime string. QUARTER does
not perform value or range checking for user-supplied values. Invalid month
values are returned as follows: month=0 returns 1; month > 12 returns 4.
The same quarter information can be returned by using the DATEPART or DATENAME
function. DATEPART and DATENAME performs value and range checking on the full
date string. You can use the DATEADD or TIMESTAMPADD function to increment a
date by a specified number of quarters.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.QUARTER(date-expression)
Examples
The following examples both return the number 1 because the date (February 25)
is in the first quarter of the year:

SELECT DISTINCT {fn QUARTER('2004-02-25')} AS Q_Given
FROM Sample.Person

SELECT DISTINCT {fn QUARTER(59590)} AS Q_Given
FROM Sample.Person
The following examples return the current quarter:

SELECT DISTINCT {fn QUARTER({fn NOW()})} AS Q_Now
FROM sample.person

SELECT DISTINCT {fn QUARTER(CURRENT_DATE)} AS Q_Now
FROM Sample.Person
See Also
DATEPART DATENAME DATEADD MONTH

 #}}}
*REPEAT*  #{{{

A string function that repeats a string a specified number of times.
Synopsis

REPEAT(expression,repeat-count)
{fn REPEAT(expression,repeat-count)}

Arguments

expression    The string expression to be repeated.

repeat-count  The number of times to repeat, expressed as an integer.

Description
REPEAT returns a string of repeat-count instances of expression, concatenated
together.
If expression is NULL, REPEAT returns NULL. If expression is the empty string, 
REPEAT returns an empty string.
If repeat-count is a fractional number, only the integer part is used. If 
repeat-count is 0, REPEAT returns an empty string. If repeat-count is a
negative number, NULL, or a non-numeric string, REPEAT returns NULL.
Examples
The following examples show the two forms of REPEAT. Both examples return the
string 'BANGBANGBANG':

SELECT DISTINCT REPEAT('BANG',3) AS Tripled
FROM Sample.Person

SELECT DISTINCT {fn REPEAT('BANG',3)} AS Tripled
FROM Sample.Person
See Also

  • REPLICATE


 #}}}
*REPLACE*  #{{{

A string function that replaces a substring within a string.
Synopsis

REPLACE(string,oldsubstring,newsubstring)

Arguments

string        A string expression that is the target for the substring search.

oldsubstring  The substring to match within string.

newsubstring  The substring used to replace oldsubstring.

Description
REPLACE searches a string for a substring and replaces all matches. Matching is
case-sensitive. If a match is found, it replaces every instance of oldsubstring
with newsubstring. The replacement substring may be longer or shorter than the
substring it replaces. If the substring cannot be found, REPLACE returns the
original string unchanged.
The empty string is a string value. You can, therefore, use the empty string
for any argument value. However, note that the Caché ObjectScript empty string
is passed to Caché SQL as NULL.
NULL is not a data value in Caché SQL. For this reason, specifying NULL for any
of the REPLACE arguments returns NULL, regardless of whether or not a match
occurs.
This function provides compatibility with Transact-SQL implementations.
REPLACE and STUFF
Both REPLACE and STUFF perform substring replacement. REPLACE searches for a
substring by data value. STUFF searches for a substring by string position and
length.
For a list of functions that search for a substring, refer to String
Manipulation in the Concepts section of this manual.
Examples
The following example searches for every instance of the substring 'K' and
replaces it with the substring 'P':

SELECT DISTINCT REPLACE('KING KONG','K','P')
FROM Sample.Person
The following embedded SQL example searches for every instance of the substring
'KANSAS' and replaces it with the substring 'NEBRASKA':

  SET str="KANSAS, ARKANSAS, NEBRASKA"
  &sql(SELECT REPLACE(:str,'KANSAS','NEBRASKA')
  INTO :x
  FROM Sample.Person)
  WRITE !,"SQLCODE=",SQLCODE
  WRITE !,"Output string=",x
The following example show that REPLACE handles the empty string ('') just like
any other string value:

SELECT DISTINCT
  REPLACE('','','Nothing'),
  REPLACE('KING KONG','','P'),
  REPLACE('KING KONG','K','')
FROM Sample.Person
The following example shows that REPLACE handles any NULL argument by returning
NULL. All of the following REPLACE functions return NULL, including the last,
in which no match occurs:

SELECT DISTINCT
  REPLACE(NULL,'K','P'),
  REPLACE(NULL,NULL,'P'),
  REPLACE('KING KONG',NULL,'P'),
  REPLACE('KING KONG','K',NULL),
  REPLACE('KING KONG','Z',NULL)
FROM Sample.Person
The following embedded SQL example is identical to the previous NULLs example.
It shows how the Caché ObjectScript empty string host variable is treated as
NULL within SQL:

  SET a=""
  &sql(SELECT
  REPLACE(:a,'K','P'),
  REPLACE(:a,:a,'P'),
  REPLACE('KING KONG',:a,'P'),
  REPLACE('KING KONG','K',:a),
  REPLACE('KING KONG','Z',:a)
  INTO :v,:w,:x,:y,:z
  FROM Sample.Person)
  WRITE !,"SQLCODE=",SQLCODE
  WRITE !,"Output string=",v
  WRITE !,"Output string=",w
  WRITE !,"Output string=",x
  WRITE !,"Output string=",y
  WRITE !,"Output string=",z
See Also

  • CHARINDEX function
  • $FIND function
  • STUFF function
  • String Manipulation


 #}}}
*REPLICATE*  #{{{

A string function that repeats a string a specified number of times.
Synopsis

REPLICATE(expression,repeat-count)

Arguments

expression    The string expression to be repeated.

repeat-count  The number of times to repeat, expressed as an integer.

Description
Note:
The REPLICATE function is an alias for the REPEAT function. REPLICATE is
provided for TSQL compatibility. Refer to REPEAT for further details.
See Also

  • REPEAT


 #}}}
*REVERSE*  #{{{

A scalar string function that returns a character string in reverse character
order.
Synopsis

REVERSE(string-expression)

Arguments

                   The string expression to be reversed. The expression can be
                   the name of a column, a string literal, a numeric, or the
string-expression  result of another scalar function, where the underlying data
                   type can be represented as any character type (such as CHAR
                   or VARCHAR).

Description
REVERSE returns string-expression with its character order reversed. For
example, 'Hello World!' is returned as '!dlroW olleH'. This is a simple
string-order reversal, with no additional processing.
The string returned is data type VARCHAR, regardless of the data type of the
input value. Numbers are converted to canonical form, numeric strings are not
converted to canonical form before reversing.
Leading and trailing blanks are unaffected by reversing.
Reversing a NULL value results in a NULL.
Note:
Because REVERSE always returns a VARCHAR string, some types of data become
invalid when reversed:

  • A reversed list is no longer a valid list and cannot be converted from
    storage format to display format.
  • A reversed date is no longer a valid date, and cannot be converted from
    storage format to display format.

Examples
The following example reverses the Name field values. In this case, this
results in names sorted by middle initial:

SELECT Name,REVERSE(Name) AS RevName
FROM Sample.Person
ORDER BY RevName
Note that because Name and RevName are just different representations of the
same field, ORDER BY RevName and ORDER BY RevName,Name perform the same
ordering.
The following example reverses a number and a numeric string:

SELECT DISTINCT REVERSE(+007.10) AS RevNum,
       REVERSE('+007.10') AS RevNumStr
FROM Sample.Person
The following Embedded SQL example reverses a $DOUBLE number:

  SET dnum=$DOUBLE(1.1)
  &sql(SELECT DISTINCT REVERSE(:dnum)
       INTO :drevnum
       FROM Sample.Person)
  WRITE dnum,!
  WRITE drevnum,!
The following example shows what happens when you reverse a list:

SELECT FavoriteColors,REVERSE(FavoriteColors) AS RevColors
FROM Sample.Person
The following example shows what happens when you reverse a date:

SELECT DOB,%INTERNAL(DOB) AS IntDOB,REVERSE(DOB) AS RevDOB
FROM Sample.Person
See Also

  • CHAR
  • STRING
  • SUBSTRING


 #}}}
*RIGHT*  #{{{

A scalar string function that returns a specified number of characters from the
end (rightmost position) of a string expression.
Synopsis

{fn RIGHT(string-expression,count)}

Arguments

                   A string expression, which can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

count              An integer that specifies the number of characters to return
                   from the ending (rightmost) position of string-expression.

Description
RIGHT returns count number of characters from the end (rightmost position) of 
string-expression. RIGHT returns NULL if passed a NULL value for either
argument.
RIGHT can only be used as an ODBC scalar function (with the curly brace
syntax).
Examples
The following example returns the two rightmost characters of each name in the
Sample.Person table:

SELECT Name,{fn RIGHT(Name,2)}AS MiddleInitial
     FROM Sample.Person
The following embedded SQL example shows how RIGHT handles a count that is
longer than the string itself:

   &sql(SELECT Name,{fn RIGHT(Name,40)}
     INTO :a,:b
     FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,a,"=original",!,b,"=RIGHT 40" }
No padding is performed.
See Also
LEFT LTRIM RTRIM

 #}}}
*ROLLBACK*  #{{{

Rolls back a transaction.
Synopsis

ROLLBACK [WORK]
ROLLBACK TO SAVEPOINT pointname

Arguments

pointname  The name of an existing savepoint, specified as an identifier. For
           further details see the  Identifiers chapter of Using Caché SQL.

Description
A ROLLBACK statement rolls back a transaction, undoing work performed but not
committed, decrementing the $TLEVEL transaction level counter, and releasing
locks. ROLLBACK is used to restore the database to a previous consistent state.

  • A ROLLBACK rolls back all work completed during the current transaction,
    resets the $TLEVEL transaction level counter to zero and releases all
    locks. This restores the database to its state before the beginning of the
    transaction. ROLLBACK and ROLLBACK WORK are equivalent statements; both
    versions are supported for compatibility.
  • A ROLLBACK TO SAVEPOINT pointname rolls back all work done since the
    specified savepoint and decrements the $TLEVEL transaction level counter by
    the number of savepoints undone. When all savepoints have been either
    rolled back or committed and the transaction level counter reset to zero,
    the transaction is completed. If the specified savepoint does not exist, or
    has already been rolled back, ROLLBACK issues an SQLCODE -375 and rolls
    back the entire current transaction.

A ROLLBACK TO SAVEPOINT must specify a pointname. Failing to do so results in
an SQLCODE -301 error.
For details on establishing savepoints, refer to SAVEPOINT.
An SQLCODE -400 is issued if a transaction operation fails to complete
successfully.
Not Rolled Back
The following items are not affected by a ROLLBACK operation:

  • A roll back does not reverse the creation, modification, or purging of a
    Cached Query. These operations are not treated as part of a transaction.
  • A roll back does not decrement the IDKey counter for a default class. The
    IDKey is automatically generated by $INCREMENT, which maintains a count
    independent of the SQL transaction.

Examples
The following Embedded SQL example demonstrates how a ROLLBACK restores the
transaction level counter ($TLEVEL) to 0, the level immediately prior to the 
START TRANSACTION:

  &sql(SET TRANSACTION %COMMITMODE EXPLICIT)
    WRITE !,"Set transaction mode, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
  &sql(START TRANSACTION)
    WRITE !,"Start transaction, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
  &sql(SAVEPOINT a)
    WRITE !,"Set Savepoint a, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
  &sql(SAVEPOINT b)
    WRITE !,"Set Savepoint b, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
    &sql(SAVEPOINT c)
    WRITE !,"Set Savepoint c, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
  &sql(ROLLBACK)
    WRITE !,"Rollback transaction, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
The following Embedded SQL example demonstrates how a 
ROLLBACK TO SAVEPOINT name restores the transaction level ($TLEVEL) to the
level immediately prior to the specified SAVEPOINT:

  &sql(SET TRANSACTION %COMMITMODE EXPLICIT)
    WRITE !,"Set transaction mode, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
  &sql(START TRANSACTION)
    WRITE !,"Start transaction, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
  &sql(SAVEPOINT a)
    WRITE !,"Set Savepoint a, SQLCODE=",SQLCODE
    WRITE !,"Transaction level at a=",$TLEVEL
  &sql(SAVEPOINT b)
    WRITE !,"Set Savepoint b, SQLCODE=",SQLCODE
    WRITE !,"Transaction level at b=",$TLEVEL
  &sql(ROLLBACK TO SAVEPOINT b)
    WRITE !,"Rollback to b, SQLCODE=",SQLCODE
    WRITE !,"Rollback transaction level=",$TLEVEL
  &sql(SAVEPOINT c)
    WRITE !,"Set Savepoint c, SQLCODE=",SQLCODE
    WRITE !,"Transaction level at c=",$TLEVEL
  &sql(SAVEPOINT d)
    WRITE !,"Set Savepoint d, SQLCODE=",SQLCODE
    WRITE !,"Transaction level at d=",$TLEVEL
  &sql(COMMIT)
    WRITE !,"Commit transaction, SQLCODE=",SQLCODE
    WRITE !,"Transaction level=",$TLEVEL
See Also

  • SQL commands: COMMIT SAVEPOINT SET TRANSACTION START TRANSACTION $TLEVEL
  • Transaction Processing in the  Modifying the Database chapter of 
    Using Caché SQL.
  • Caché ObjectScript: TROLLBACK


 #}}}
*ROUND*  #{{{

A numeric function that rounds or truncates a number at a specified number of
digits.
Synopsis

ROUND(numeric-expr,integer-expr[,flag])

{fn ROUND(numeric-expr,integer-expr[,flag])}

Arguments

numeric-expr  The number to be rounded. A numeric expression.

              An integer (or an expression that evaluates to an integer) that
              specifies the number of places to round to, counting from the
integer-expr  decimal point. Can be zero, a positive integer, or a negative
              integer. If integer-expr is a decimal number, Caché truncates it
              to the nearest integer.

flag          Optional  A boolean flag that specifies whether to round or
              truncate the numeric-expr. 0=round, 1=truncate. The default is 0.

Description
This function can be used to either round or truncate a number to the specified
number of decimal digits.
ROUND rounds or truncates numeric-expr to integer-expr places, counting from
the decimal point. When rounding, the number 5 is always rounded up. Leading
and trailing zeroes are removed before the ROUND operation. ROUND returns the
same data type as numeric-expr.

  • If integer-expr is a positive number, rounding is performed at that number
    of digits to the right of the decimal point. If integer-expr is equal to or
    larger than the number of decimal digits, no rounding or zero filling
    occurs.
  • If integer-expr is zero, rounding is to the closest whole integer. In other
    words, rounding is performed at zero digits to the right of the decimal
    point; all decimal digits and the decimal point itself are removed.
  • If integer-expr is a negative number, rounding is performed at that number
    of digits to the left of the decimal point. If integer-expr is equal to or
    larger than the number of integer digits in the rounded result, zero is
    returned.
  • If numeric-expr is zero (however expressed: 00.00, -0, etc.) ROUND returns
    0 (zero) with no decimal digits, regardless of the integer-expr value.
  • If numeric-expr or integer-expr is NULL, ROUND returns NULL.

ROUND and TRUNCATE perform similar operations; they both can be used to
decrease the number of significant decimal or integer digits of a number. ROUND
can be used to either round or truncate a number. TRUNCATE can only be used to
truncate a number.
Examples
The following example uses an integer-expr of 0 (zero) to round several
fractions to integers. It shows that 5 is always rounded up:

SELECT DISTINCT
   ROUND(5.99,0) AS RoundUp,
   ROUND(5.5,0) AS Round5,
   {fn ROUND(5.329,0)} AS Roundoff
FROM Sample.Person
The following example truncates the same fractional numbers as the previous
example:

SELECT DISTINCT
   ROUND(5.99,0,1) AS Trunc1,
   ROUND(5.5,0,1) AS Trunc2,
   {fn ROUND(5.329,0,1)} AS Trunc3
FROM Sample.Person
The following example rounds off pi to four decimal digits:

SELECT DISTINCT {fn PI()} AS ExactPi, ROUND({fn PI()},4) AS ApproxPi
FROM Sample.Person
The following example specifies a integer-expr larger than the number of
decimal digits:

SELECT DISTINCT {fn ROUND(654.98700,9)} AS Rounded
FROM Sample.Person
it returns 654.987 (Caché removed the trailing zeroes before the rounding
operation; no rounding or zero padding occurred).
The following example rounds off the value of Salary to the nearest thousand
dollars:

SELECT Salary,ROUND(Salary, -3) AS PayBracket
FROM Sample.Employee
ORDER BY Salary
Note that if Salary is less than five hundred dollars, it is rounded to 0
(zero).
In the following example each ROUND specifies a negative integer-expr as large
or larger than the number to be rounded:

SELECT DISTINCT
   {fn ROUND(987,-3)} AS Round1,
   {fn ROUND(487,-3)} AS Round2,
   {fn ROUND(987,-4)} AS Round3,
   {fn ROUND(987,-5)} AS Round4
FROM Sample.Person
The first ROUND function returns 1000, because the rounded result has more
digits than the integer-expr. The other three ROUND functions return 0 (zero).
See Also

  • SQL functions: CEILING FLOOR MOD TRUNCATE
  • Caché ObjectScript functions: $NORMALIZE $NUMBER


 #}}}
*RTRIM*  #{{{

A string function that returns a string with the trailing blanks removed.
Synopsis

RTRIM(string-expression)

{fn RTRIM(string-expression)}

Arguments

                   A string expression, which can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

Description
RTRIM removes the trailing blanks from a string expression, and returns the
string as type VARCHAR. If string-expression is NULL, RTRIM returns NULL. If 
string-expression is a string consisting entirely of blank spaces, RTRIM
returns the empty string ('').
RTRIM leave leading blanks; to remove leading blanks, use LTRIM. To remove
leading and/or trailing characters of any type, use TRIM. To add blanks, use 
SPACE.
Note that RTRIM can be used as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
Examples
The following embedded SQL example removes the five trailing blanks from the
string. It leaves the five leading blanks:

   SET a="     Test string with 5 leading and 5 trailing spaces.     "
   &sql(SELECT {fn RTRIM(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Before RTRIM",!,"start:",a,":end"
     WRITE !,"After RTRIM",!,"start:",b,":end" }
Returns:

Before RTRIM
start:     Test string with 5 leading and 5 trailing spaces.     :end
After RTRIM
start:     Test string with 5 leading and 5 trailing spaces.:end

See Also
LTRIM TRIM SPACE

 #}}}
*SAVEPOINT*  #{{{

Marks a point within a transaction.
Synopsis

SAVEPOINT pointname

Arguments

pointname  The name of the savepoint, specified as an identifier. For further
           details see the  Identifiers chapter of Using Caché SQL.

Description
A SAVEPOINT statement marks a point within a transaction. Establishing a
savepoint enables you to perform transaction roll back to the savepoint,
undoing all work done and releasing all locks acquired during that period. In a
long-running transaction, or a transaction with internal control structure, it
is often desirable to be able to roll back part of the transaction without
undoing all work submitted during the transaction.
Any number of savepoints may be established within a transaction. The
establishment of a savepoint increments the $TLEVEL transaction level counter.
Rolling back to a savepoint decrements the $TLEVEL transaction level counter to
its value immediately prior to the savepoint. Savepoints have no effect on the 
COMMIT statement, which commits all work done during the current transaction.
Each savepoint is associated with an savepoint name, a unique identifier.
Savepoint names are not case sensitive. A savepoint name can be a delimited
identifier.

  • If you specify a SAVEPOINT with no pointname, or with a pointname that is
    not a valid identifier, a runtime SQLCODE -301 error is issued.
  • If you specify a SAVEPOINT with a pointname that begins with  SYS , a
    runtime SQLCODE -302 error is issued. These savepoint names are reserved.
  • If you specify more than one SAVEPOINT with the same pointname, the most
    recent SAVEPOINT overrides any previous ones that have the same pointname.

Using Savepoints
If savepoints have been established:

  • A ROLLBACK TO SAVEPOINT pointname rolls back work done since the specified
    savepoint, deletes that savepoint and all intermediate savepoints, and
    decrements the $TLEVEL transaction level counter by the number of
    savepoints deleted. If pointname does not exist, or has already been rolled
    back, this command rolls back the entire transaction, resets $TLEVEL to 0,
    and releases all locks.
  • A ROLLBACK TO SAVEPOINT rolls back all work done since the most recent
    savepoint and decrements by 1 the $TLEVEL transaction level counter. If no
    savepoints have been established, or all savepoints have already been
    rolled back, this command rolls back the entire transaction, resets $TLEVEL
    to 0, and releases all locks.
  • A ROLLBACK rolls back all work done during the current transaction, rolling
    back the work done since START TRANSACTION. It resets the $TLEVEL
    transaction level counter to zero and releases all locks. Note that a
    generic ROLLBACK ignores savepoints.

A COMMIT commits all work done during the current transaction. It resets the 
$TLEVEL transaction level counter to zero and releases all locks. Note that a 
COMMIT ignores savepoints.
Issuing a second START TRANSACTION within a transaction has no effect on
savepoints.
An SQLCODE -400 is issued if a transaction operation fails to complete
successfully.
Examples
The following embedded SQL example creates a transaction with two savepoints:

  NEW SQLCODE,%ROWCOUNT,%ROWID
  &sql(START TRANSACTION)
  &sql(DELETE FROM Sample.Person WHERE Name=NULL)
  IF SQLCODE=100 { WRITE !,"No null name records to delete" }
  ELSEIF SQLCODE'=0 {&sql(ROLLBACK)}
  ELSE {WRITE !,%ROWCOUNT," null name records deleted"}
    &sql(SAVEPOINT svpt_age1)
    &sql(DELETE FROM Sample.Person WHERE Age=NULL)
    IF SQLCODE=100 { WRITE !,"No null age records to delete" }
    ELSEIF SQLCODE'=0 {&sql(ROLLBACK TO SAVEPOINT)}
    ELSE {WRITE !,%ROWCOUNT," null age records deleted"}
      &sql(SAVEPOINT svpt_age2)
      &sql(DELETE FROM Sample.Person WHERE Age>65)
      IF SQLCODE=0 { &sql(COMMIT)}
      ELSEIF SQLCODE=100 { &sql(COMMIT)}
      ELSE {
       &sql(ROLLBACK TO SAVEPOINT svpt_age2)
       WRITE !,"retirement age deletes failed"
      }
    &sql(COMMIT)
  &sql(COMMIT)

Caché ObjectScript and SQL Transactions
Caché ObjectScript transaction processing, using TSTART and TCOMMIT, differs
from, and is incompatible with, SQL transaction processing using the SQL
statements START TRANSACTION, SAVEPOINT, and COMMIT. Both Caché ObjectScript
and Caché SQL provides limited support for nested transactions. Caché
ObjectScript transaction processing does not interact with SQL lock control
variables; of particular concern is the SQL lock escalation variable. An
application should not attempt to mix the two types of transaction processing.
If a transaction involves SQL update statements, then the transaction should be
started by the SQL START TRANSACTION statement and committed with the SQL 
COMMIT statement. Methods that use TSTART/TCOMMIT nesting can be included in
the transaction, as long as they don't initiate the transaction. Methods and
stored procedures should not normally use SQL transaction control statements,
unless, by design, they are the main controller of the transaction. Stored
procedures should not normally use SQL transaction control statements, because
these stored procedures are normally called from ODBC/JDBC, which has its own
model of transaction control.
See Also

  • SQL commands: COMMIT ROLLBACK SET TRANSACTION START TRANSACTION $TLEVEL
  • Transaction Processing in the  Modifying the Database chapter of 
    Using Caché SQL.
  • Caché ObjectScript command: TCOMMIT


 #}}}
*SECOND*  #{{{

A scalar date/time function that returns an integer from 0 to 59 that
corresponds to the second component in a given date-time expression.
Synopsis

{fn SECOND(time-expression)}

Arguments

                 An expression that is the name of a column, the result of
                 another scalar function, or a string or numeric literal. It
time-expression  must resolve either to a datetime string or a time integer,
                 where the underlying data type can be represented as TIME or
                 TIMESTAMP.

Description
SECOND returns the seconds portion of a time integer or a datetime string. A
datetime string is of the format:

yyyy-mm-dd hh:mm:ss

To change this default time format, use the SET OPTION command.
Note that you can supply a time integer (number of elapsed seconds), but not a
time string (hh:mm:ss). You must supply a datetime string (yyyy-mm-dd
hh:mm:ss).
The seconds (ss) portion should be an integer in the range from 0 through 59.
There is, however, no range checking for user-supplied values. Numbers greater
than 59, negative numbers, and fractions are returned as specified. Leading
zeros are optional on input. Leading and trailing zeros are suppressed on
output.
SECOND returns 0 seconds when the seconds portion is '0', '00', or a nonnumeric
value. Zero seconds is also returned if no time expression is supplied, if the
seconds portion of the time expression is omitted entirely ('hh', 'hh:mm',
'hh:mm:', or 'hh::'), or the time expression is invalid.
The same time information can be returned using DATEPART or DATENAME.
Fractional Seconds
SECOND returns fractions of a second if supplied in time-expression. Trailing
zeros are truncated. If no fractional seconds are specified (for example:
38.00) the decimal separator is also truncated.
The standard Caché internal representation of time values ($HOROLOG) does not
support fractional seconds. Timestamps do support fractional seconds.
The following SQL functions support fractional seconds: SECOND, 
CURRENT_TIMESTAMP, DATENAME, DATEPART, and GETDATE. CURTIME, CURRENT_TIME, and 
NOW do not support fractional seconds.
The SQL SET OPTION statement permits you to set the default precision (number
of decimal digits) for fractional seconds.
The Caché ObjectScript $ZTIMESTAMP special variable can be used to represent
fractional seconds. The Caché ObjectScript functions $ZDATETIME, $ZDATETIMEH, 
$ZTIME, and $ZTIMEH support fractional seconds.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.SECOND(time-expression)
Examples
The following examples both return the number 38 because it is the
thirty-eighth second of the time expression:

SELECT DISTINCT {fn SECOND('2000-02-16 18:45:38')} AS Seconds_Given
FROM Sample.Person

SELECT DISTINCT {fn SECOND(67538)} AS Seconds_Given
FROM Sample.Person
The following example returns .9 seconds. The leading and trailing zeros are
truncated:

SELECT DISTINCT {fn SECOND('2000-02-16 18:45:00.9000')} AS Seconds_Given
FROM Sample.Person
The following example returns 0 seconds because the seconds portion of the
datetime string has been omitted:

SELECT DISTINCT {fn SECOND('2000-02-16 18:45')} AS Seconds_Given
FROM Sample.Person
The following example returns 0 seconds because the time expression has been
omitted from the datetime string:

SELECT DISTINCT {fn SECOND('2000-02-16')} AS Seconds_Given
FROM Sample.Person
The following examples all return the seconds portion of the current time. 
CURRENT_TIME and CURTIME supply a time string; NOW supplies a datetime string:

SELECT DISTINCT {fn SECOND(CURRENT_TIME)} AS Seconds_Now1,
                {fn SECOND({fn CURTIME()})} AS Seconds_Now2,
                {fn SECOND({fn NOW()})} AS Seconds_Now3
FROM Sample.Person
The following example shows that leading zeros are suppressed. The first SECOND
function returns a length 2, the others return a length of 1. An omitted time
is considered to be 0 seconds, which has a length of 1:

SELECT DISTINCT LENGTH({fn MINUTE('2004-02-05 11:45:22')}),
                LENGTH({fn MINUTE('2004-02-15 03:05:06')}),
                LENGTH({fn MINUTE('2004-02-15 3:5:6')}),
                LENGTH({fn MINUTE('2004-02-15')})
FROM Sample.Person
The following Embedded SQL example shows that the SECOND function recognizes
the TimeSeparator character specified for the locale:

  DO ##class(%SYS.NLS.Format).SetFormatItem("TimeSeparator",".")
  &sql(SELECT DISTINCT {fn SECOND('2000-02-16 18.45.38')}
  INTO :a
  FROM Sample.Person)
  WRITE "seconds=",a
See Also

  • SQL concepts: Data Type Date and Time Constructs
  • SQL functions: HOUR MINUTE CURRENT_TIME CURTIME NOW DATEPART DATENAME
  • Caché ObjectScript: $ZTIME function $HOROLOG special variable $ZTIMESTAMP
    special variable


 #}}}
*SIGN*  #{{{

A numeric function that returns the sign of a given numeric expression.
Synopsis

SIGN(numeric-expression)

{fn SIGN(numeric-expression)}

Arguments

numeric-expression  A number for which the sign is to be returned.

Description
SIGN returns the following:

  • -1 if numeric-expression is less than zero.
  • 0 (zero) if numeric-expression is zero.
  • 1 if numeric-expression is greater than zero.
  • NULL if numeric-expression is NULL.

SIGN can be used as either an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
Note:
In Caché SQL, two negative signs (hyphens) are the in-line comment indicator.
For this reason, a SIGN argument specifying two successive negative signs must
be presented as a numeric string enclosed in quotes.
Examples
The following examples shows the effects of SIGN:

SELECT DISTINCT SIGN(-49) AS PosNeg
FROM Sample.Person
returns -1.

SELECT DISTINCT {fn SIGN(-0.0)} AS PosNeg
FROM Sample.Person
returns 0.

SELECT DISTINCT SIGN(-+-16.748) AS PosNeg
FROM Sample.Person
returns 1.

SELECT DISTINCT {fn SIGN(NULL)} AS PosNeg
FROM Sample.Person
returns <null>.
See Also
NVL +(Positive)  (Negative)

 #}}}
*%SIMILARITY*  #{{{

Returns a number indicating the similarity of a field value to a text.
Synopsis

%SIMILARITY(field,document)

Arguments

field     A data column whose values are being compared with the document text.
          Must be of data type %TEXT. Cannot be a view field.

          An alphabetic string to match with values in field. A document
document  consists of a series of words separated by a delimiter (commonly, the
          space character).

Description
The %SIMILARITY function returns a numeric value indicating the similarity
between each value of field and the text specified in document. The fractional
values returned range from 0 (no similarity at all) to 1 (identical). The
returned value is of type NUMERIC with a precision of 19 and a scale of 18. You
can use %SIMILARITY to determine order of ranking, for example in an ORDER BY
clause.
To use %SIMILARITY on a string, change the %String property to %Text, and set
LANGUAGECLASS. For example:

Property MyDocument As %Text (LANGUAGECLASS="%Text.English");

The available languages are English, French, German, Italian, Japanese,
Portuguese, and Spanish. See the %Text class documentation (in %SYS) in the 
Caché Class Reference for further details.
If field does not support %Text, Caché generates an SQLCODE -309 error.
Note:
If text is represented as a stream that is greater than the maximum length of a
string and a search on the text uses %SIMILARITY on a non-indexed field, the
document is broken up into chunks of characters. If non-indexed fields span
boundaries between chunks, they may not be properly referenced. To avoid this
issue, only use %SIMILARITY on indexed fields. For information on the maximum
length of a string, see the section  Long Strings in the article 
InterSystems Product Miscellany.
Similarity Analysis
A high degree of similarity generally means that most or all of the words (or
other delimited data items) in field are also found in document, though not
necessarily in the same order. The document text may also contain many words
not present in field. Commonly, non-significant words (articles, prepositions,
pronouns, and other  noise words ) add little or nothing to the degree of
significance. Duplicates of a significant word in document generally add to the
degree of significance.
%SIMILARITY comparison is governed by the class parameters of the %Text.Text
system class, found in the %SYS namespace. These parameters allow you to
specify, among other things, whether comparison is to be case-sensitive or not
case-sensitive, and the treatment of numbers, punctuation characters, and
multi-word phrases.
Caché can use specific language analysis rules, including common word analysis
( noise word lists) and stemming rules, to determine similarity. The available
languages are English, French, German, Italian, Japanese, Portuguese, and
Spanish.
For a much more detailed treatment of %SIMILARITY and %Text, refer to the %Text
class documentation in the Caché Class Reference.
See Also

  • SELECT statement ORDER BY clause WHERE clause
  • %CONTAINS operator
  • %CONTAINSTERM operator


 #}}}
*SIN*  #{{{

A scalar numeric function that returns the sine, in radians, of an angle.
Synopsis

{fn SIN(float-expression)}

Arguments

float-expression  An expression of type FLOAT. This is an angle expressed in
                  radians.

Description
SIN takes any numeric value and returns its sine as a floating point number. 
SIN returns NULL if passed a NULL value. SIN treats nonnumeric strings as the
numeric value 0.
SIN returns a value of data type FLOAT with a precision of 19 and a scale of
18.
SIN can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example shows the effect of SIN:

SELECT DISTINCT {fn SIN(0.52)} AS Sine
FROM Sample.Person
returns 0.496880.
See Also

  • SQL functions: ACOS ASIN ATAN COS COT TAN
  • Caché ObjectScript function: $ZSIN


 #}}}
*SPACE*  #{{{

A string function that returns a string of spaces.
Synopsis

SPACE(count)
{fn SPACE(count)}

Arguments

count  An integer expression specifying the number of blank spaces to return.

Description
SPACE returns a string of blank spaces count spaces long. If count is a numeric
string, a decimal number, or a mixed numeric string, Caché resolves it to its
integer portion. If count is a negative number or a nonnumeric string, Caché
resolves it to 0.
To remove blank spaces from a string, use LTRIM (leading blanks) or RTRIM
(trailing blanks).
Note:
The SPACE function should not be confused with SPACE collation. SPACE collation
appends a single space to a value, forcing it to be evaluated as a string. To
establish SPACE collation, CREATE TABLE provides a %SPACE collation keyword,
and Caché ObjectScript provides the $ZUTIL(28) function.
Examples
The following embedded SQL example returns a string of spaces the length of the
name field:

   &sql(SELECT SPACE(LENGTH(name))
   INTO :a
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Leave this much space:",a,"for names" }
See Also
LTRIM RTRIM TRIM

 #}}}
*%SQLSTRING*  #{{{

A collation function that sorts values as strings.
Synopsis

%SQLSTRING(expression[,maxlen])

%SQLSTRING expression

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

maxlen      Optional  A positive integer, which specifies that the collated
            value will be truncated to the value of maxlen.

Description
%SQLSTRING converts expression to format that is sorted as a (case-sensitive)
string. %SQLSTRING strips trailing whitespace (spaces, tabs, and so on) from
the string, then adds one leading blank space to the beginning of the string.
This appended blank space forces NULL and numeric values to be collated as
strings. Leading and trailing zeros are removed from numbers.
Because %SQLSTRING appends a blank space to all values, it collates a NULL
value as a blank space, with a string length of 1. %SQLSTRING collates any
value containing only whitespace (spaces, tabs, and so on) as the SQL empty
string (''). When %SQLSTRING appends a blank space to an empty (zero-length)
string, it collates as a blank space plus the internal representation of an
empty string, $CHAR(0), resulting in a string length of 2.
The optional maxlen parameter truncates the expression string to the specified
number of characters when indexing or collating. For example, if you insert a
long string with maxlen truncation, the full string is inserted and can be
retrieved by a SELECT statement; the index global for this string is truncated
to the specified length. This means that ORDER BY and comparison operations
only evaluate the truncated index string. Such truncation is especially useful
for indexing on strings that exceed the 255-character limit for Caché
subscripts. When converting from non-Caché systems, some users encountered
problems when they indexed on a VARCHAR(255) field and then tried to insert
data into the table. With the maxlen parameter, if you need to index on a long
field, you can use the truncation length parameter.
For a not case-sensitive string conversion, refer to %SQLUPPER.
You can perform the same collation conversion in Caché ObjectScript using the
$ZUTIL(28) function. This function can also be invoked from Caché ObjectScript
using the following method call:
$SYSTEM.SQL.SQLSTRING(expression,maxlen)
Examples
The following query uses %SQLSTRING in the WHERE clause to perform a
case-sensitive select:

SELECT Name FROM Sample.Person
WHERE %SQLSTRING Name %STARTSWITH %SQLSTRING 'Al'
ORDER BY Name
By default, %STARTSWITH string comparisons are not case-sensitive. This example
uses the %SQLSTRING format to make this comparison case-sensitive. It returns
all names that begin with  Al (such as Allen, Alton, etc.). Note when using 
%STARTSWITH, you should apply %SQLSTRING collation to both sides of the
statement.
The following example uses %SQLSTRING with a string truncation to return the
first two characters of each name. Note that the string truncation is 3 (not 2)
because of the leading blank added by %SQLSTRING. The ORDER BY clause uses this
two-character field to put the rows in a rough collation sequence:

SELECT Name, %SQLSTRING(Name,3) AS FirstTwo
FROM Sample.Person
ORDER BY FirstTwo
This example returns the truncated values without changing the case of letters.
To return truncated values in converted to uppercase, use %STRING.
See Also
%SQLUPPER %STARTSWITH

 #}}}
*%SQLUPPER*  #{{{

A collation function that sorts values as uppercase strings.
Synopsis

%SQLUPPER(expression[,maxlen])
%SQLUPPER expression

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

maxlen      Optional  An integer, which specifies that the collated value will
            be truncated to the value of maxlen.

Description
%SQLUPPER converts expression to a format that is sorted as a (not
case-sensitive) uppercase string. %SQLUPPER converts all alphabetic characters
to uppercase, strips trailing whitespace (spaces, tabs, and so on) from the
string, then adds one leading blank space to the beginning of the string. This
appended blank space causes NULL and numeric values to be collated as strings.
Leading and trailing zeros are removed from numbers.
Because %SQLUPPER appends a blank space to all values, it collates a NULL value
as a blank space, with a string length of 1. %SQLUPPER collates any value
containing only whitespace (spaces, tabs, and so on) as the SQL empty string
(''). When %SQLUPPER appends a blank space to an empty (zero-length) string, it
collates as a blank space plus the internal representation of an empty string,
$CHAR(0), resulting in a string length of 2.
The optional maxlen parameter truncates the converted expression string to the
specified number of characters when indexing or collating. For example, if you
insert a long string with maxlen truncation, the full string is inserted and
can be retrieved by a SELECT statement; the index global for this string is
truncated to the specified length. This means that ORDER BY and comparison
operations only evaluate the truncated index string. Such truncation is
especially useful for indexing on strings that exceed the 255-character limit
for Caché subscripts. When converting from non-Caché systems, some users
encountered problems when they indexed on a VARCHAR(255) field and then tried
to insert data into the table. With the maxlen parameter, if you need to index
on a long field, you can use the truncation length parameter.
For a case-sensitive string conversion, refer to %SQLSTRING.
You can perform the same collation conversion in Caché ObjectScript using the
$ZUTIL(28) function. This function can also be invoked from Caché ObjectScript
using the following method call:
$SYSTEM.SQL.SQLUPPER(expression,maxlen)
Other Case Conversion Functions
The %SQLUPPER function is the preferred way in SQL to convert a data value for
not case-sensitive comparison or collation. %SQLUPPER adds a leading blank
space to the beginning of the data, which forces numeric data and the NULL
value to be interpreted as strings.
The following are other methods for converting the case of a data value:

  • %ALPHAUP: converts letters to uppercase, has no effect on number
    characters, deletes all punctuation characters except commas and question
    marks, deletes all blank spaces (leading, trailing, and embedded). Does not
    force numerics to be interpreted as a string.
  • UPPER, %UPPER, and UCASE: converts letters to uppercase, has no effect on
    number characters, punctuation characters, embedded spaces, and leading and
    trailing blank spaces. Does not force numerics to be interpreted as a
    string.
  • LOWER and LCASE: converts letters to lowercase, has no effect on number
    characters, punctuation characters, embedded spaces, and leading and
    trailing blank spaces. Does not force numerics to be interpreted as a
    string.
  • %STRING: converts letters to uppercase, deletes all punctuation except
    commas, deletes all blank spaces (leading, trailing, and embedded). It adds
    a leading blank space to the beginning of the data, which forces numeric
    data and the NULL value to be interpreted as strings. Leading and trailing
    zeros are removed from numbers.
  • %SQLSTRING: does not convert letter case. However, it adds a leading blank
    space to the beginning of the data, which forces numeric data and the NULL
    value to be interpreted as strings. Leading and trailing zeros are removed
    from numbers.

Alphanumeric Collation Order
The case conversion functions collate data values that begin with a number
using different algorithms, as follows:

%ALPHAUP and %STRING                     %SQLUPPER, %SQLSTRING, and all other
                                         case conversion functions

5988 Clinton Avenue, 6023 Washington     5988 Clinton Avenue, 6 Oak Avenue,
Court, 6090 Elm Court, 6185 Clinton      6023 Washington Court, 6090 Elm Court,
Drive, 6209 Clinton Street, 6284 Oak     6185 Clinton Drive, 6209 Clinton
Drive, 6310 Franklin Street, 6406 Maple  Street, 6284 Oak Drive, 6310 Franklin
Place, 641 First Place, 6572 First       Street, 6406 Maple Place, 641 First
Avenue, 6643 First Street, 665 Ash       Place, 6572 First Avenue, 66 Main
Drive, 66 Main Street, 672 Main Court,   Street, 6643 First Street, 665 Ash
6754 Oak Court, 6986 Madison Blvd, 6     Drive, 672 Main Court, 6754 Oak Court,
Oak Avenue, 7000 Ash Court, 709 Oak      6986 Madison Blvd, 7000 Ash Court, 709
Avenue                                   Oak Avenue

Examples
The following query uses %SQLUPPER with a string truncation to return the first
two characters of each name in uppercase. Note that the string truncation is 3
(not 2) because of the leading blank added by %SQLUPPER. The ORDER BY clause
uses this two-character field to put the rows in a rough collation sequence:

SELECT Name, %SQLUPPER(Name,3) AS FirstTwo
FROM Sample.Person
ORDER BY FirstTwo
See Also
%SQLSTRING %STARTSWITH

 #}}}
*SQRT*  #{{{

A scalar numeric function that returns the square root of a given numeric
expression.
Synopsis

{fn SQRT(float-expression)}

Arguments

float-expression  An expression, of type FLOAT, for which the square root is to
                  be calculated.

Description
SQRT returns the square root of float-expression. SQRT returns NULL if passed a
NULL value.
SQRT returns a value of data type FLOAT with a precision of 36 and a scale of
18.
SQRT can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example takes the square root of 49:

SELECT DISTINCT {fn SQRT(49)} AS SRoot
FROM Sample.Person
returns 7.
The following embedded SQL example returns the square roots of the integers 0
through 10:

   SET a=0
   WHILE a<11 {
   &sql(SELECT {fn SQRT(:a)}
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE
     QUIT }
   ELSE {
     WRITE !,"The square root of ",a," = ",b
     SET a=a+1 }
   }
See Also

  • SQL functions: POWER ROUND
  • Caché ObjectScript function: $ZSQR


 #}}}
*STR*  #{{{

A function that converts a numeric to a string.
Synopsis

STR(number[,length[,decimals]])

Arguments

          An expression that resolves to a numeric. It can be a field name, a
number    numeric, or the result of another function. If a field name is
          specified, the logical value is used.

          Optional  An integer specifying the total length of the desired
length    output string, including all characters (digits, decimal point, sign,
          blank spaces). The default is 10.

decimals  Optional  An integer specifying the number of places to the right of
          the decimal point to include. The default is 0.

Description
STR converts a numeric to the STRING format, truncating the numeric based on
the values of length and decimals. The length argument must be large enough to
include the entire integer portion of the number, and, if decimals is
specified, that number of decimal digits plus 1 (for the decimal point). If 
length is not large enough, STR returns a string of asterisks (*) equal to 
length.
STR converts numerics to their canonical form before string conversion. It
therefore performs arithmetic operations, removes leading and trailing zeros
and leading plus signs from numbers.
If the number argument is NULL, STR returns NULL. If the number argument is the
empty string (''), STR returns the empty string. STRING retains whitespace.
Examples
In the following embedded SQL example, STR converts numerics into a string.

   &sql(SELECT STR(123),
               STR(123,4),
               STR(+00123.45,3),
               STR(+00123.45,3,1),
               STR(+00123.45,5,1)
        INTO :v,:w,:x,:y,:z
        FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Resulting STR:",v," string"
     WRITE !,"Resulting STR:",w," string"
     WRITE !,"Resulting STR:",x," string"
     WRITE !,"Resulting STR:",y," string"
     WRITE !,"Resulting STR:",z," string" }
The first STR function returns a string consisting of 7 leading blanks and the
number 123; the seven leading blanks are because the default string length is
10. The second STR function returns the string  123 ; note the leading blank
needed to return a string of length 4. The third STR function returns the
string  123 ; the numeric is put into canonical form, and decimals defaults to
0. The fourth STR function returns  *** because the string length is not long
enough to encompass the entire number as specified; the number of asterisks
indicates the string length. The fifth STR function returns  123.4 ; note that
the length must be 5 to include the decimal digit.
See Also
STRING %STRING %SQLUPPER %SQLSTRING

 #}}}
*STRING*  #{{{

A function that converts and concatenates expressions into a string.
Synopsis

STRING(string1[,string2][,...][,stringn])

Arguments

        An expression, which can be a field name, a string literal, a numeric,
string  or the result of another function, where the underlying data type can
        be represented as any character type (such as CHAR or VARCHAR2). If a
        field name is specified, the logical value is used.

Description
STRING converts one or more strings to the STRING format, and then concatenates
these strings into a single string. No case transformation is performed.
STRING converts numerics to their canonical form before string conversion. It
therefore performs arithmetic operations, removes leading and trailing zeros
and leading plus signs from numbers.
If one of the string arguments is NULL, STRING returns NULL. If one of the 
string arguments is the empty string (''), STRING concatenates the other
arguments. STRING retains whitespace.
You can use the %SQLSTRING function to convert a data value for case-sensitive
string comparison, or the %SQLUPPER function to convert a data value for not
case-sensitive string comparison.
Examples
In the following embedded SQL example, STRING concatenates three substrings
into a single string. The example shows the handling of blank spaces, the empty
string, and NULL:

   &sql(SELECT STRING('a','b','c'),
               STRING('a',' ','c'),
               STRING('a','','c'),
               STRING('a',NULL,'c')
        INTO :w,:x,:y,:z
        FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Resulting string is:",w
     WRITE !,"Resulting string is:",x
     WRITE !,"Resulting string is:",y
     WRITE !,"Resulting string is:",z }
In the following embedded SQL example, STRING converts numerics into a string.
All of these STRING functions return the string '123':

   &sql(SELECT STRING(123),
               STRING(+00123.00),
               STRING('1',23),
               STRING(1,(10*2)+3)
        INTO :w,:x,:y,:z
        FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Resulting string is:",w
     WRITE !,"Resulting string is:",x
     WRITE !,"Resulting string is:",y
     WRITE !,"Resulting string is:",z }
In the following embedded SQL example, STRING retrieves sample data from fields
and concatenates it into a string:

   &sql(SELECT STRING(Name,Age)
        INTO :x
        FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Resulting string is:",x }
See Also
%STRING %SQLUPPER %SQLSTRING STR

 #}}}
*%STRING*  #{{{

Deprecated. A case-transformation function that converts characters to the
STRING collation format.
Synopsis

%STRING(expression[,maxlen])
%STRING expression

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

maxlen      Optional  An integer, which specifies that the collated value will
            be truncated to the value of maxlen.

Description
This is a deprecated collation function. Please refer to %SQLSTRING (for
case-sensitive string comparison) or %SQLUPPER (for not case-sensitive string
comparison) for new development.
%STRING converts expression to the STRING format:

  • Converts all letters to uppercase.
  • Removes all punctuation characters, except the comma.
  • Removes leading and trailing zeros from numbers.
  • Removes all blank spaces (leading, trailing, and embedded).
  • Then adds a single space to the beginning of the value, forcing numeric
    data and the NULL value to be collated as strings.

Because %STRING appends a blank space to all values, it collates a NULL value
as a blank space, with a string length of 1. %STRING collates any value
containing only whitespace (spaces, tabs, and so on) as the SQL empty string
(''). When %STRING appends a blank space to an empty (zero-length) string, it
collates as a blank space plus the internal representation of an empty string,
$CHAR(0), resulting in a string length of 2.
The optional maxlen truncation parameter is especially useful for indexing on
strings that exceed the 255-character limit for Caché subscripts. When
converting from non-Caché systems, some users encountered problems when they
indexed on a VARCHAR(255) field and then tried to insert data into the table.
With the maxlen parameter, if you need to index on a long field, you can use
STRING collation with a truncation length parameter.
%STRING is a Caché SQL extension and is intended for SQL lookup queries.
You can perform the same collation conversion in Caché ObjectScript using the
$ZUTIL(28) function. This function can also be invoked from Caché ObjectScript
using the following method call:
$SYSTEM.SQL.STRING(expression,maxlen)
The %SQLUPPER function is the preferred way in SQL to convert a data value for
not case-sensitive comparison or collation. Refer to %SQLUPPER for further
information on case transformation functions.
Examples
The following example selects Name values that begin with  od :

SELECT Name
FROM Sample.Person
WHERE %STRING(Name) %STARTSWITH %STRING 'od'
Because %STRING removes punctuation and blank spaces and performs not
case-sensitive collation, this example returns names such as  Odem , O'Donnell 
,  ODonnell , and  O Donnell .
The following example uses %STRING with a string truncation to return the first
two characters of each name in uppercase. Note that the string truncation is 3
(not 2) because of the leading blank added by %STRING. The ORDER BY clause uses
this two-character field to put the rows in a rough collation sequence:

SELECT Name, %STRING(Name,3) AS FirstTwo
FROM Sample.Person
ORDER BY FirstTwo
Alphanumeric Collation Order
The case conversion functions collate data values that begin with a number
using different algorithms, as follows:

%ALPHAUP and %STRING                     %SQLUPPER, %SQLSTRING, and all other
                                         case conversion functions

5988 Clinton Avenue, 6023 Washington     5988 Clinton Avenue, 6 Oak Avenue,
Court, 6090 Elm Court, 6185 Clinton      6023 Washington Court, 6090 Elm Court,
Drive, 6209 Clinton Street, 6284 Oak     6185 Clinton Drive, 6209 Clinton
Drive, 6310 Franklin Street, 6406 Maple  Street, 6284 Oak Drive, 6310 Franklin
Place, 641 First Place, 6572 First       Street, 6406 Maple Place, 641 First
Avenue, 6643 First Street, 665 Ash       Place, 6572 First Avenue, 66 Main
Drive, 66 Main Street, 672 Main Court,   Street, 6643 First Street, 665 Ash
6754 Oak Court, 6986 Madison Blvd, 6     Drive, 672 Main Court, 6754 Oak Court,
Oak Avenue, 7000 Ash Court, 709 Oak      6986 Madison Blvd, 7000 Ash Court, 709
Avenue                                   Oak Avenue

See Also

  • STRING
  • %SQLUPPER
  • %SQLSTRING
  • %STARTSWITH


 #}}}
*STUFF*  #{{{

A string function that replaces a substring within a string.
Synopsis

STUFF(string,start,length,substring)

Arguments

string     A string expression that is the target for the substring
           replacement.

           The starting point for replacement, specified as a positive integer.
           A character count from the beginning of string, counting from 1.
start      Permitted values are 0 through the length of string. To append
           characters, specify a start of 0 and a length of 0. The empty string
           or a nonnumeric value is treated as 0.

           The number of characters to replace, specified as a positive
           integer. To insert characters, specify a length of 0. To replace all
length     characters after start, specify a length greater than the number of
           existing characters. The empty string or a nonnumeric value is
           treated as 0.

           A string expression used to replace the substring identified by its
substring  starting point and length. Can be longer or shorter than the
           substring it replaces. Can be the empty string.

Description
STUFF replaces a substring with another substring. It identifies the substring
to be replaced by location and length, and replaces it with substring.
This function provides compatibility with Transact-SQL implementations.
The replacement substring may be longer or shorter than the original value. To
delete the original value, substring can be the empty string ('').
The start value must be within the current length of string. You can append a 
substring to the beginning of string by specifying a start value of 0. The
empty string or a nonnumeric value is treated as 0.
Specifying NULL for the start, length, or substring argument returns NULL.
REPLACE and STUFF
Both REPLACE and STUFF perform substring replacement. REPLACE searches for a
substring by data value. STUFF searches for a substring by string position and
length.
For a list of functions that search for a substring, refer to String
Manipulation in the Concepts section of this manual.
Examples
The following example shows a single-character substitution, turning KING into
KONG:

SELECT DISTINCT STUFF('KING',2,1,'O')
FROM Sample.Person
The following examples replace an 8-character substring (Kentucky) with a
longer 12-character substring and a shorter 2-character substring:

SELECT DISTINCT
   STUFF('In my old Kentucky home',11,8,'Rhode Island'),
   STUFF('In my old Kentucky home',11,8,'KY')
FROM Sample.Person
The following example inserts a substring:

SELECT DISTINCT
   STUFF('In my old Kentucky home',19,0,' (KY)')
FROM Sample.Person
The following example appends a substring to the beginning of the string:

SELECT DISTINCT
   STUFF('In my old Kentucky home',0,0,'The sun shines bright ')
FROM Sample.Person
The following example deletes an 8-character substring by replacing it with the
empty string:

SELECT DISTINCT STUFF('In my old Kentucky home',11,8,'')
FROM Sample.Person
See Also

  • REPLACE function
  • $EXTRACT function
  • SUBSTRING function
  • SUBSTR function
  • String Manipulation


 #}}}
*SUBSTR*  #{{{

A string function that returns a substring that is derived from a specified
string expression.
Synopsis

SUBSTR(string-expression,start[,length])

Arguments

                   The string expression from which the substring is to be
                   derived. The expression can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

                   An integer that specifies where in string-expression the
                   substring will begin. A positive starting position specifies
                   the number of characters from the beginning of the string.
start              The first character in string-expression1 is at position 1.
                   A negative starting position specifies the number of
                   characters from the end of the string. If start is 0 (zero),
                   it is treated as 1.

                   Optional  A positive integer that specifies the length of
                   the substring to return. This value specifies that the
length             substring ends length characters to the right of the
                   starting position. If omitted, substring goes from start to
                   the end of string-expression. If length is 0 or a negative
                   number, Caché returns NULL.

Description
Because start can be negative, you can obtain a substring from either the
beginning or end of the original string.
Floating-point numbers passed as arguments to SUBSTR are converted to integers
by truncating the fractional portion.

  • If start is 0,  0, or 1, the returned substring begins with the first
    character of the string.
  • If start is a negative number that positions before the beginning of the
    string, the returned substring begins with the first character of the
    string.
  • If start is past the end of the string, NULL is returned.
  • If length larger than the remaining characters in the string, the substring
    from start to the end of the string is returned.
  • If length is less that 1, NULL is returned.
  • If either start or length is NULL, NULL is returned.

SUBSTR cannot be used with stream data. If string-expression is a stream field,
SUBSTR generates an SQLCODE -37. Use SUBSTRING to extract a substring from
stream data.
SUBSTR is supported for Oracle compatibility.
Examples
The following example returns the substring CDEFG because it specifies that the
substring begin at the third character (C) and continue to the end of the
string:

SELECT DISTINCT SUBSTR('ABCDEFG',3) AS Sub
   FROM Sample.Person
The following example returns the substring CDEF because it specifies that the
substring begin at the third character (C) and continue for four characters
(until F):

SELECT DISTINCT SUBSTR('ABCDEFG',3,4) AS Sub
   FROM Sample.Person
The following example returns the substring CDEF because it specifies that
Caché should first count five characters backwards from the end of the original
string, and then return the next four characters:

SELECT DISTINCT SUBSTR('ABCDEFG',-5,4) AS Sub
   FROM Sample.Person
See Also

  • SQL function: SUBSTRING
  • Caché ObjectScript functions: $EXTRACT $PIECE


 #}}}
*SUBSTRING*  #{{{

A string function that returns a substring from a larger character string.
Synopsis

SUBSTRING(string-expression,start,length)

SUBSTRING(string-expression FROM start FOR length)

{fn SUBSTRING(string-expression,start,length)}

Arguments

                   The string expression from which the substring is to be
                   derived. An expression, which can be the name of a column, a
string-expression  string literal, or the result of another scalar function.
                   The underlying data type can be a character type (such as
                   CHAR or VARCHAR), a numeric, or a data stream.

                   An integer that specifies the position in string-expression
                   to begin the substring. The first character in 
                   string-expression is at position 1. If the start position is
start              higher than the length of the string, SUBSTRING returns an
                   empty string (''). If the start position is lower than 1
                   (zero, or a negative number) the substring begins at
                   position 1, but the length of the substring is reduced by
                   the start position.

                   Optional  An integer that specifies the length of the
length             substring to return. If length is not specified, the default
                   is to return the rest of the string.

Description
The value of start controls the starting point of the substring:

  • If start is less than 1, the value of length is decremented by a
    corresponding amount. Thus, if start is 0, the value of length is
    diminished by 1; if start is  1, the value of length is diminished by 2.

The value of length controls the size of the substring:

  • If length is a positive value (1 or greater), the substring ends length
    number of characters to the right of the starting position. (This effective
    length may be diminished if the start number is less than 1.)
  • If length is larger than the number of character remaining in the string,
    all characters to the right of the starting position through the end of 
    string-expression are returned.
  • If length is zero, NULL is returned.
  • If length is a negative number, Caché issues an SQLCODE  140 error.

Floating-point numbers passed as arguments to SUBSTRING are converted to
integers by truncating the fractional portion.
If any SUBSTRING argument value is NULL, SUBSTRING returns NULL.
SUBSTRING extracts a substring from the beginning of a string. SUBSTR can
extract a substring from either the beginning or the end of a string. Note that
these two SQL functions handle argument values differently.
SUBSTRING can be used with stream data; SUBSTR cannot be used with stream data.
The SUBSTRING return value is the same data type as the string-expression data
type. Therefore, if string-expression is LONGVARBINARY, SUBSTRING returns
BINARY.
SUBSTRING can be used as an ODBC scalar function (with the curly brace syntax)
or as an SQL general function.
Examples
This example returns the string  forward :

SELECT DISTINCT {fn SUBSTRING( 'forward pass',1,7 )} AS SubText
FROM Sample.Person
This example returns the string  pass :

SELECT DISTINCT {fn SUBSTRING( 'forward pass',9,4 )} AS SubText
FROM Sample.Person
The following example returns the first four characters of each name:

SELECT Name,SUBSTRING(Name,1,4) AS FirstFour
FROM Sample.Person
The following example demonstrates another syntactical form of SUBSTRING. This
example is functionally the same as the previous example:

SELECT Name,SUBSTRING(Name FROM 1 FOR 4) AS FirstFour
FROM Sample.Person
The following example shows how the length is reduced by a start value of less
than 1. (A start value of 0 reduces length by 1, a start value of -1 reduces 
length by 2, and so forth.) In this case, length is reduced by 3, so only one
character ( A ) is returned:

SELECT DISTINCT {fn SUBSTRING( 'ABCDEFG',-2,4 )} AS SubText
FROM Sample.Person
See Also

  • SQL function: SUBSTR
  • Caché ObjectScript functions: $EXTRACT $PIECE


 #}}}
*SUM*  #{{{

An aggregate function that returns the sum of the values of a specified column.
Synopsis

SUM([ALL | DISTINCT] expression)

Arguments

ALL         Optional  Specifies that SUM return the sum of all values for 
            expression. This is the default if no keyword is specified.

            Optional  Specifies that SUM return the sum of the distinct
DISTINCT    (unique) values for expression. If not specified, the default is
            ALL.

expression  Any valid expression. Usually the name of a column that contains
            the data values to be summed.

Description
The SUM aggregate function returns the sum of the values of expression.
Commonly, expression is the name of a field, (or an expression containing one
or more field names) in the multiple rows returned by a query.
SUM can be used in a SELECT query or subquery that references either a table or
a view. SUM can appear in a SELECT list or HAVING clause alongside ordinary
field values.
SUM cannot be used in a WHERE clause. SUM cannot be used in the ON clause of a 
JOIN, unless the SELECT is a subquery.
Data Values
SUM is normally applied to a field or expression that has a numeric value.
Because only minimal type checking is performed, it is possible (though rarely
meaningful) to invoke it for nonnumeric fields. SUM evaluates nonnumeric
values, including the empty string (''), as zero (0).
SUM returns data type INTEGER for an expression with data type INT, SMALLINT,
or TINYINT. SUM returns data type BIGINT for an expression with data type
BIGINT. SUM returns data type DOUBLE for an expression with data type DOUBLE.
For all other numeric data types, SUM returns data type NUMERIC.
SUM returns a value with a precision of 18. The scale of the returned value is
the same as the expression scale, with the following exception. If expression
is a numeric value with data type VARCHAR or VARBINARY, the scale of the
returned value is 8.
By default, aggregate functions use Logical (internal) data values, rather than
Display values.
SUM cannot be used on fields with DATE, TIME, or TIMESTAMP data types.
Attempting to do so results in an SQLCODE -379 error.
NULL values in data fields are ignored when deriving a SUM aggregate function
value. If no rows are returned by the query, or the data field value for all
rows returned is NULL, SUM returns NULL.
Changes Made During the Current Transaction
Like all aggregate functions, SUM always returns the current state of the data,
including uncommitted changes, regardless of the current transaction’s
isolation level. For further details, refer to SET TRANSACTION and START
TRANSACTION.
Examples
The following query returns the sum of the salaries of all employees in the
Sample.Employee database:

SELECT SUM(Salary) AS Total_Payroll
     FROM Sample.Employee
The following query returns the sum and the average of the salaries for each
job title in the Sample.Employee database:

SELECT Title,SUM(Salary) AS Total,AVG(Salary) AS Average
     FROM Sample.Employee
     GROUP BY Title
     ORDER BY Average
The following query shows SUM used with an arithmetic expression. For each job
title in the Sample.Employee database it returns the sum of the current
salaries and the sum of the salaries with a 10% increase in pay:

SELECT Title,SUM(Salary) AS Total,SUM(Salary * 1.1) AS Raises
     FROM Sample.Employee
     GROUP BY Title
     ORDER BY Title
The following query shows SUM used with a logical expression using the CASE
statement. It counts all of the salaried employees, and uses SUM to count all
of the salaried employees earning $90,000 or more.

SELECT COUNT(Salary) As AllPaid,
       SUM(CASE WHEN (Salary >= 90000)
           THEN 1 ELSE 0 END) As TopPaid
       FROM Sample.Employee
See Also

  • AVG
  • COUNT


 #}}}
*SYSDATE*  #{{{

A date/time function that returns the current date and time.
Synopsis

SYSDATE

Description
SYSDATE takes no arguments and returns the current date and time. It returns
time in whole second increments. The SYSDATE function is very similar to the 
CURRENT_TIMESTAMP function, with the exception that CURRENT_TIMESTAMP supports
an optional precision argument that enables it to return fractional seconds.
The CURRENT_TIMESTAMP function is preferred for use in Caché SQL. The SYSDATE
function is provided for compatibility with other versions of SQL. Refer to
CURRENT_TIMESTAMP for further details.
The following example shows that SYSDATE and CURRENT_TIMESTAMP are equivalent
functions:

SELECT DISTINCT
   SYSDATE AS SysStamp,
   CURRENT_TIMESTAMP AS TStamp
FROM Sample.Person
The following example shows the use of CURRENT_TIMESTAMP with a precision
argument to return fractional seconds:

SELECT DISTINCT
   SYSDATE AS SysStamp,
   CURRENT_TIMESTAMP(2) AS TStamp
FROM Sample.Person
See Also

  • CURRENT_TIMESTAMP


 #}}}
*TAN*  #{{{

A scalar numeric function that returns the tangent, in radians, of an angle.
Synopsis

{fn TAN(float-expression)}

Arguments

float-expression  An expression of type FLOAT. This is an angle expressed in
                  radians.

Description
TAN takes any numeric value and returns its tangent. TAN returns NULL if passed
a NULL value. TAN treats nonnumeric strings as the numeric value 0.
TAN returns a value of data type FLOAT with a precision of 36 and a scale of
18.
TAN can only be used as an ODBC scalar function (with the curly brace syntax).
Examples
The following example shows the effect of TAN.

SELECT DISTINCT {fn TAN(0.52)} AS Tangent
FROM Sample.Person
returns 0.572561.
See Also

  • SQL functions: ACOS ASIN ATAN COS COT SIN
  • Caché ObjectScript function: $ZTAN


 #}}}
*TIMESTAMPADD*  #{{{

A scalar date/time function that returns a new timestamp calculated by adding a
number of intervals of a specified type to a specified timestamp.
Synopsis

{fn TIMESTAMPADD(interval-type,integer-exp,timestamp-exp)}

Arguments

interval-type  The type of time/date interval that integer-exp represents,
               specified as a keyword.

integer-exp    An integer value expression that is to be added to timestamp-exp
               .

timestamp-exp  A TIMESTAMP value expression, which will be increased by the
               value of integer-exp.

Description
The TIMESTAMPADD function modifies a date/time expression by incrementing the
specified date part by the specified number of units. For example, if 
interval-type is SQL_TSI_MONTH and integer-exp is 5, TIMESTAMPADD increments 
timestamp-exp by five months. You can also decrement a date part by specifying
a negative integer for integer-exp. The calculated date is returned as a
TIMESTAMP. You can increment or decrement by fractional seconds, counted in
thousandths of a second (.001).
Note that TIMESTAMPADD can only be used as an ODBC scalar function (with the
curly brace syntax).
Similar time/date modification operations can be performed on a timestamp using
the DATEADD general function.
Interval Types
The interval-type parameter can be one of the following timestamp intervals:

  • SQL_TSI_FRAC_SECOND
  • SQL_TSI_SECOND
  • SQL_TSI_MINUTE
  • SQL_TSI_HOUR
  • SQL_TSI_DAY
  • SQL_TSI_WEEK
  • SQL_TSI_MONTH
  • SQL_TSI_QUARTER
  • SQL_TSI_YEAR

Incrementing or decrementing a timestamp interval causes other intervals to be
modified appropriately. For example, incrementing the hour past midnight
automatically increments the day, which may in turn increment the month, and so
forth. TIMESTAMPADD always returns a valid date, taking into account the number
of days in a month, and calculating for leap year. For example, incrementing
January 31 by one month returns February 28 (the highest valid date in the
month), unless the specified year is a leap year, in which case it returns
February 29.
DATEADD and TIMESTAMPADD handle quarters (3 month intervals); DATEDIFF and 
TIMESTAMPDIFF do not handle quarters.
Timestamp Format
The timestamp-exp parameter value has the same logical format and external
format: a string of the form:

yyyy-mm-dd hh:mm:ss

For this parameter:

  • If timestamp-exp specifies only a date value, the date portion of 
    timestamp-exp is set to '1900 01 01' before calculating the resulting
    timestamp.
  • If timestamp-exp specifies only a date value, the time portion of 
    timestamp-exp is set to '00:00:00' before calculating the resulting
    timestamp.
  • You can include or omit fractional seconds.

Range and Value Checking
TIMESTAMPADD performs the following checks on input values. If a value fails a
check, the null string is returned.

  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. Years must be specified as four digits.
  • Date values must be within a valid range. Years: 1841 through 9999. Months:
    1 through 12. Days: 1 though 31. Hours: 0 through 23. Minutes: 0 through
    59. Seconds: 0 through 59.
  • The incremented year value returned must be within the range 1841 through
    9999. Incrementing beyond this range returns <null>.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Date values less than 10 may include or omit a leading zero. Other
    non-canonical integer values are not permitted. Therefore, a Day value of
    '07' or '7' is valid, but '007', '7.0' or '7a' are not valid.

Examples
The following example adds 1 week to the original timestamp:

SELECT DISTINCT {fn TIMESTAMPADD(SQL_TSI_WEEK,1,'2003-12-20 12:00:00')}
FROM Sample.Person
it returns 2003-12-27 12:00:00, because adding 1 week adds 7 days.
The following example adds 5 months to the original timestamp:

SELECT DISTINCT {fn TIMESTAMPADD(SQL_TSI_MONTH,5,'1999-12-20 12:00:00')}
FROM Sample.Person
returns 2000-05-20 12:00:00 because in this case adding 5 months also
increments the year.
The following example also adds 5 months to the original timestamp:

SELECT DISTINCT {fn TIMESTAMPADD(SQL_TSI_MONTH,5,'1999-01-31 12:00:00')}
FROM Sample.Person
it returns 1999-06-30 12:00:00. Here TIMESTAMPADD modified the day value as
well as the month, because simply incrementing the month would result in June
31, which is an invalid date.
The following example increments the original timestamp by 45 minutes:

SELECT DISTINCT {fn TIMESTAMPADD(SQL_TSI_MINUTE,45,'1999-12-20 00:00:00')}
FROM Sample.Person
returns 1999-12-20 00:45:00.
The following example decrements the original timestamp by 45 minutes:

SELECT DISTINCT {fn TIMESTAMPADD(SQL_TSI_MINUTE,-45,'1999-12-20 00:00:00')}
FROM Sample.Person
it returns 1999-12-19 23:15:00. Note that in this case decrementing the time
also decremented the day.
See Also
TIMESTAMPDIFF DATEADD DATENAME DATEPART

 #}}}
*TIMESTAMPDIFF*  #{{{

A scalar date/time function that returns the integer number of intervals of a
specified type between two timestamps.
Synopsis

{fn TIMESTAMPDIFF(interval-type,startdate,enddate)}

Arguments

interval-type  The type of time/date interval that the returned value will
               represent.

startdate      A TIMESTAMP value expression.

enddate        A TIMESTAMP value expression that will be compared to startdate.

Description
The TIMESTAMPDIFF function returns the difference between two given timestamps
(that is, one timestamp is subtracted from the other) for the specified
interval (seconds, days, weeks, etc.). The value returned is an INTEGER that
specifies the number of these intervals between the two timestamps. (If enddate
is earlier than startdate, TIMESTAMPDIFF returns a negative INTEGER value.) You
can return an interval of fractional seconds, counted in thousandths of a
second (.001).
The interval-type parameter can be one of the following timestamp intervals:

  • SQL_TSI_FRAC_SECOND
  • SQL_TSI_SECOND
  • SQL_TSI_MINUTE
  • SQL_TSI_HOUR
  • SQL_TSI_DAY
  • SQL_TSI_WEEK
  • SQL_TSI_MONTH
  • SQL_TSI_YEAR

TIMESTAMPDIFF and DATEDIFF do not handle quarters (3-month intervals).
The timestamp parameter values have the same logical format and external
format: a string of the form 'yyyy-mm-dd hh:mm:ss'.

  • If either timestamp expression is a TIME value and interval-type specifies
    calendar time (days, weeks, months, or years), the date portion of the
    expression is set to '1900 01 01' before calculating the resulting
    timestamp.
  • If either timestamp expression is a DATE value and interval-type specifies
    clock time (seconds, minutes, or hours), the time portion of the expression
    is set to '00:00:00' before calculating the resulting timestamp.
  • You can include or omit fractional seconds.

Note that TIMESTAMPDIFF can only be used as an ODBC scalar function (with the
curly brace syntax). Similar time/date comparison operations can be performed
on a timestamp using the DATEDIFF general function.
Range and Value Checking
TIMESTAMPDIFF performs the following checks on input values. If a value fails a
check, the null string is returned.

  • A valid startdate or enddate may consist of a date string (yyyy-mm-dd), a
    time string (hh:mm:ss), or a date and time string (yyyy-mm-dd hh:mm:ss). If
    both date and time are specified, both must be valid. For example, you can
    return a Year value if no time string is specified, but you cannot return a
    Year value if an invalid time string is specified.
  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. For example, you cannot return a Year value if the Day
    value is omitted. Years must be specified as four digits. If you omit the
    date portion of an input value, TIMESTAMPDIFF defaults to '1900 01 01'.
  • A time string must be properly formatted with the appropriate separator
    character. Because a time value can be zero, you can omit one or more time
    elements (either retaining or omitting the separator characters) and these
    elements will be returned with a value of zero. Thus, 'hh:mm:ss.nnn',
    'hh:mm:ss', 'hh:mm:', 'hh:mm', 'hh::ss', 'hh::', 'hh', and ':::' are all
    valid. To omit the Hour element, the date expression must not have a date
    portion of the string, and you must retain at least one separator character
    (:).
  • Date and time values must be within a valid range. Years: 1841 through
    9999. Months: 1 through 12. Days: 1 though 31. Hours: 0 through 23.
    Minutes: 0 through 59. Seconds: 0 through 59.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Most date and time values less than 10 may include or omit a leading zero.
    However, an Hour value of less than 10 must include the leading zero if it
    is part of a datetime string. Other non-canonical integer values are not
    permitted. Therefore, a Day value of '07' or '7' is valid, but '007', '7.0'
    or '7a' are not valid.

Examples
The following example returns 7 because the second timestamp (1999-12-20
12:00:00) is 7 months greater than the first one:

SELECT DISTINCT {fn TIMESTAMPDIFF(SQL_TSI_MONTH,
     '1999-5-19 00:00:00','1999-12-20 12:00:00')}
FROM Sample.Person
The following example returns 566 because the second timestamp ('12:00:00') is
566 minutes greater than the first one (02:34:12):

SELECT DISTINCT {fn TIMESTAMPDIFF(SQL_TSI_MINUTE,
     '02:34:12','12:00:00')}
FROM Sample.Person
See Also
TIMESTAMPADD DATEDIFF

 #}}}
*TO_CHAR*  #{{{

A string function that converts a date or a number to a character string.
Synopsis

TO_CHAR(tochar-expression[,format])

TOCHAR(tochar-expression[,format])

Arguments

tochar-expression  A logical date, timestamp, or number expression to be
                   converted.

format             Optional  A letter code specifying a date, timestamp, or
                   number format for the tochar-expression conversion.

Description
The names TO_CHAR and TOCHAR are interchangeable and are supported for Oracle
compatibility.
The TO_CHAR function has three uses:

  • To translate a date or timestamp to a formatted date or datetime string.
  • To translate a number to a formatted numeric string.

TO_CHAR converts a date or a timestamp to a string. TO_DATE converts a string
to a date. To convert a date of one data type to a date of another data type,
use the CONVERT function.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.TOCHAR(tochar-expression,format)
Note: Locales mentioned below in the format code definitions refer to the same
locales mentioned in the Caché ObjectScript $ZDATE and $ZDATEH documentation.
Date-to-String Conversion
The first use of TO_CHAR is to convert a date expression to a string. The value
for tochar-expression must be a valid Logical date.
Note that any characters used in the format string which are not format codes
are just returned in place in the resulting string.
The following table lists the valid date format codes for this version of 
TO_CHAR.

Format                                  Meaning
 Code

D       Day of week (1-7, where 1 is Sunday).

DD      Two-digit day of month (01-31).

DY      Abbreviated name of the day, as specified by the WeekdayAbbr property
        of the current locale. The defaults are: Sun Mon Tue Wed Thu Fri Sat

        Name of day, as specified by the WeekdayName property in the current
DAY     locale. The defaults are: Sunday Monday Tuesday Wednesday Thursday
        Friday Saturday

MM      Two-digit month number (01-12; 01 = JAN).

        Abbreviated name of month, as specified by the MonthAbbr property in
MON     the current locale. The defaults are: Jan Feb Mar Apr May Jun Jul Aug
        Sep Oct Nov Dec

        Full name of the month, as specified by the MonthName property in the
MONTH   current locale. The defaults are: January February March April May June
        July August September October November December

YYYY    Four-digit year.

YYY     Last 3 digits of the year.

YY      Last 2 digits of the year.

Y       Last digit of the year.

RRRR    Four-digit year.

RR      Last 2 digits of the year.

DDD     Day of the Year (see below).

J       Julian date (number of days since January 1, 4712 BC (BCE)).

Separator characters are required between the date format elements, with the
exception of the following format strings: YYYYMMDD, DDMMYYYY, and YYYYMM. The
last of these returns the year and month values and ignores the day of the
month.
Day of the Year
You can use DDD to convert a date expression to the day of the year (number of
days elapsed since January 1) and the year. The format string DDD,YYYY must be
paired with a date expression in $HOROLOG format. (The $HOROLOG time value, if
specified, is ignored.) The DDD and YYYY (or YY) format elements can be
specified in any order; a separator character between them is mandatory and is
returned as a literal. The following examples show this use of Day of the Year:

SELECT DISTINCT TO_CHAR('60871','YYYY:DDD')
FROM Sample.Person

SELECT DISTINCT TO_CHAR('60871,12345','DDD YY')
FROM Sample.Person
TO_CHAR permits you to return the day of the year corresponding to a date
expression. TO_DATE permits you to return a date expression corresponding to a
day of the year.
Julian Dates
The  Julian date format is provided to allow for dates before the year 1840. 
TO_CHAR converts a date value for data type %Date or %TimeStamp to a
seven-digit Julian date number.
If you specify a format that consists of a string containing the letter 'J',
the date value returned will be a  Julian date that is, a count of days from
January 1, 4712BCE. Only the letter 'J' may be specified in the format string;
the inclusion of any other characters causes 'J' to be treated as a literal,
and the date to be translated as a standard date.
A Julian day count is always represented as a seven-digit number, with leading
zeros when necessary. The maximum tochar-expression value for Julian dates is
'9999-12-31' which corresponds to Julian day count 5373484. The minimum value
is '-4712-01-01' which corresponds to Julian day count 0000001.
The following example returns 2369916 (signing of the Declaration of
Independence of the United States) and 1709980 (battle of Actium marks
beginning of Roman Empire under Augustus Caesar):

SELECT TO_CHAR('1776-07-04','J') AS UnitedStatesStart,
       TO_CHAR('-0031-09-02','J') AS RomanEmpireStart
Note:
The following consideration should not affect the interconversion of dates and
Julian day counts using TO_CHAR and TO_DATE. It may affect some calculations
made using Julian day counts.
Julian day counts prior to 1721424 (1/1/1) are compatible with other software
implementations, such as Oracle. They are not identical to BCE dates in
ordinary usage. In ordinary usage, there is no Year 0; dates go from 12/31/-1
to 1/1/1. In Oracle usage, the Julian dates 1721058 through 1721423 are simply
invalid, and return an error. In Caché these Julian dates return the
non-existent Year 0 as a place holder. Thus calculations involving BCE dates
must be adjusted by one year to correspond to common usage.
TO_CHAR permits you to return a Julian day count corresponding to a date
expression. TO_DATE permits you to return a date expression corresponding to a
Julian day count, as shown in the following example:

SELECT DISTINCT
  TO_CHAR('1776-07-04','J') AS JulianCount,
  TO_DATE(2369916,'J') AS JulianDate
FROM Sample.Person
For further details on using Julian dates, see the TO_DATE function.
Timestamp-to-String Conversion
You can use TO_CHAR to convert a timestamp expression to a string. The value
for tochar-expression must be a valid Logical timestamp value.
The date portion of the timestamp is formatted using the date-to-string
conversion format codes. The following table lists additional format codes for
the time portion of the timestamp.

Format Code                  Meaning

HH           Hour of Day (1 through 12)

HH12         Hour of Day (1 through 12)

HH24         Hour of Day (0 through 23)

MI           Minute (0 through 59)

SS           Second (0 through 59)

SSSSS        Seconds since midnight (0 through 86388)

AM           Meridian Indicator (before noon)

PM           Meridian Indicator (after noon)

These time format codes should only be used with a timestamp tochar-expression.
If a date expression is converted with time format codes, the time portion
defaults to 12:00:00.
The following example returns the current system date (a timestamp), and the
current system date converted for display with two different formats:

SELECT DISTINCT SYSDATE,
     TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS'),
     TO_CHAR(SYSDATE,'DD MONTH YYYY at SSSSS seconds')
FROM Sample.Person
Note that any characters used in the format string which are not format codes
are just returned in place in the resulting string.
Date Conversion Examples
The following example takes a date integer and returns a date string formatted
according to the format string argument:

SELECT DISTINCT TO_CHAR(59684,'MM/DD/YYYY')
FROM Sample.Person
returns the string: 05/29/2004
The following example takes a date integer and returns a formatted date string.
Characters that are not format characters are passed through to the output
string as literals:

SELECT DISTINCT TO_CHAR(59684,'That date is MM/DD/YYYY')
FROM Sample.Person
returns the string: That date is 05/29/2004
The following example takes a date integer and returns a formatted date string.

SELECT DISTINCT TO_CHAR(59684,'DAY MONTH DD, YYYY')
FROM Sample.Person
returns the string: Saturday May 29, 2004
TO_CHAR and TO_DATE

  • TO_DATE converts a formatted date string to the corresponding date integer.
    If you erroneously supply TO_DATE with a date integer, it returns this
    integer unmodified.
  • TO_CHAR converts a date integer to a formatted date string. If you
    erroneously supply TO_CHAR with a formatted date string, it returns
    erroneous data.

These correct and erroneous uses of TO_DATE and TO_CHAR are shown in the
following examples.
The following Embedded SQL example uses TO_DATE to perform a date conversion. 
TO_DATE takes a date string and returns the corresponding date integer (59832).
The $ZDATE function is used to display this date integer as the formatted date
10/24/2004. In this example, TO_DATE is also erroneously supplied a date
integer; it simply returns this integer.

   &sql(SELECT
          TO_DATE('2004-10-24','YYYY-MM-DD'), /* correct */
          TO_DATE(59832,'YYYY-MM-DD')         /* ERROR!  */
        INTO :a,:b
        FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,a
     WRITE !,$ZDATE(a)
     WRITE !,b
 }
The following Embedded SQL example shows date conversions using TO_CHAR. The
first TO_CHAR converts a date integer to the corresponding formatted date
string, as expected. However, the second TO_CHAR gives unexpected results.
Since TO_CHAR expects a numeric input, it treats the date separators in the
input as minus signs and performs the subtractions. It therefore formats a date
corresponding to the date integer 1970 (2004 minus 10 minus 24): 1846 5 24.
Obviously, this was not the programmer’s intent.

   &sql(SELECT
        TO_CHAR(59832,'YYYY-MM-DD'),     /* correct */
        TO_CHAR(2004-10-24,'YYYY-MM-DD') /* ERROR!  */
        INTO :a,:b
        FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,a
     WRITE !,b }
Number-to-String Conversion
The second use of TO_CHAR is to convert a number to a string. The following
table lists the valid format codes for the format parameter for this version of
TO_CHAR.
If you omit the format parameter, the input numeric value is evaluated as an
integer: leading zeros and a leading plus sign are deleted, a leading minus
sign is retained, and the numeric value is truncated at the first nonnumeric
character, such as a comma or period. No leading blanks or other formatting is
provided.

Format  Example                           Description
 Code

                 Return value with the specified number of digits, with a
9       9999     leading space if positive or with a minus sign if negative.
                 Leading zeros are blank, except for a zero value, which
                 returns a zero for the integer part of the fixed-point number.

0       09999    Return leading zeros.
        99990    Return trailing zeros.

$       $9999    Return value with a leading dollar sign. Note that the dollar
                 sign is preceded by a blank for positive numbers.

                 Return blanks for the integer part of a fixed-point number
B       B9999    when the integer part is zero (regardless of 0’ in the format
                 parameter).

                 Return negative value with a leading minus sign "-". Return
S       S9999    positive value with a leading plus sign "+".
        9999S    Return negative value with a trailing minus sign "-". Return
                 positive value with a trailing plus sign "+".

                 Return a decimal separator character in the specified
D       99D99    position. The decimal separator used is the one defined for
                 the locale. The default is a period ".". Only one "D" is
                 allowed in the format parameter.

                 Return a group separator character in the specified position
G       9G999    (s). The group separator used is the one defined for the
                 locale. The default is a comma ",". No group separators may
                 appear to the right of the decimal.

FM      FM90.9   Return a value with no leading or trailing blanks.

                 Return a comma in the specified position. No comma may appear
,       9,999    to the right of the decimal. The format parameter may not
                 begin with a comma.

                 Return a decimal point (that is, a period  . ) in the
.       99.99    specified position. Only one "." is allowed in the format
                 parameter.

If the format parameter contains fewer integer digits than the input numeric
expression, TO_CHAR does not return a number; instead, it returns a string of
two or more pound signs (##). The number of pound signs represents the length
of the current format parameter, plus one.
If the format parameter contains fewer decimal digits than the input numeric
expression, TO_CHAR rounds the number to the specified number of decimal
digits, or to an integer, if no decimal format is provided.
Number-to-String Examples
The following embedded SQL example shows basic number-to-string conversions:

   &sql(SELECT
     TO_CHAR(1000,'9999'),
     TO_CHAR(10,'9999')
   INTO :numfull,:numshort
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Formatted number:",numfull
     WRITE !,"Formatted number:",numshort
     WRITE !,"Note leading blanks" }
Returns the specified number with the appropriate number of leading blanks. An
unsigned positive number is always preceded by a blank character. Additional
leading blanks are provided if the specified number has fewer digits than the 
format parameter.
The following embedded SQL example shows the use of separator characters:

   &sql(SELECT
      TO_CHAR(1000,'9,999.99'),
      TO_CHAR(1000,'9G999D99')
   INTO :comma,:groupsep
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Formatted number:",comma
     WRITE !,"Formatted number:",groupsep
     WRITE !,"Note leading blank" }
The first TO_CHAR returns the string: ' 1,000.00'. The second TO_CHAR may also
return this value, but the separator characters displayed depend upon the
locale setting.
The following embedded SQL example shows the use of positive and negative
signs:

   &sql(SELECT
      TO_CHAR(10,'99.99'),
      TO_CHAR(-10,'99.99'),
      TO_CHAR(10,'S99.99'),
      TO_CHAR(-10,'S99.99'),
      TO_CHAR(10,'99.99S'),
      TO_CHAR(-10,'99.99S')
   INTO :pos,:neg,:poslead,:neglead,:postrail,:negtrail
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Formatted number:",pos
     WRITE !,"Formatted number:",neg
     WRITE !,"Formatted number:",poslead
     WRITE !,"Formatted number:",neglead
     WRITE !,"Formatted number:",postrail
     WRITE !,"Formatted number:",negtrail
     WRITE !,"Note use of leading blank" }
Note that a leading blank only appears before a positive number with no sign
formatting. No leading blank appears before a negative number, or before any
signed number, regardless of the placement of the sign.
The following embedded SQL example show the use of the  FM format to override
the default leading blank for unsigned positive numbers:

   &sql(SELECT
      TO_CHAR(12345678.90,'99G999G999D99'),
      TO_CHAR(12345678.90,'FM99G999G999D99')
   INTO :num,:fmnum
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Formatted number:",num
     WRITE !,"Formatted number:",fmnum
     WRITE !,"Note leading blank" }
The first TO_CHAR returns the string: ' 12,345,678.90'. The second TO_CHAR
returns the string: '12,345,678.90' (with no leading blank).
The following embedded SQL example show the use of the leading dollar sign:

   &sql(SELECT
     TO_CHAR(1234567890,'$9G999G999G999'),
     TO_CHAR(1234567890,'S$9G999G999G999'),
     TO_CHAR(12345678.90,'$99G999G999D99')
   INTO :d,:sd,:dD
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Formatted number:",d
     WRITE !,"Formatted number:",sd
     WRITE !,"Formatted number:",dD
     WRITE !,"Note leading blanks" }
The dollar sign is always preceded either by a sign or by a blank character.
The following embedded SQL example shows what happens when the format parameter
contain fewer integer digits than the input numeric value:

   &sql(SELECT
     TO_CHAR(1234567.89,'9'),
     TO_CHAR(1234567.89,'99'),
     TO_CHAR(1234567.89,'99D99')
   INTO :a,:b,:c
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Formatted number:",a
     WRITE !,"Formatted number:",b
     WRITE !,"Formatted number:",c }
Each TO_CHAR returns a string of pound signs:  ## ,  ### , and  ###### ,
respectively.
The following embedded SQL example shows what happens when the format parameter
contains fewer decimal digits than the input numeric expression:

   &sql(SELECT
     TO_CHAR(1234567.4999,'9999999D9'),
     TO_CHAR(1234567.91,'9999999')
   INTO :a,:b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"Formatted number:",a
     WRITE !,"Formatted number:",b }
The returned numbers are rounded to  1234567.5 and  1234568 , respectively.
See Also

  • SQL functions: CONVERT TO_DATE TO_NUMBER
  • Caché ObjectScript functions: $FNUMBER $ZDATE


 #}}}
*TO_DATE*  #{{{

A date function that converts a formatted string to a date.
Synopsis

TO_DATE(date_string[,format])

TODATE(date_string[,format])

Arguments

date_string  The string to be converted to a date. A string date expression
             where the underlying data type is CHAR or VARCHAR2.

             Optional  A date format string corresponding to date_string. If 
format       format is omitted, 'DD MON YYYY' is the default value; this
             default is configurable.

Description
The names TO_DATE and TODATE are interchangeable and are supported for Oracle
compatibility.
The TO_DATE function converts date strings in various formats to a date integer
value, with data type DATE. It is used to input dates in various string
formats, storing them in a standard internal representation. TO_DATE returns a
date with the following format:

nnnnn

Where nnnnn is a positive integer between 0 (December 31, 1840) and 2980013
(December 31, 9999), inclusive. This represents a count of days. Dates before
December 31, 1840 can be represented using Julian dates, as described below.
Time values are ignored.
To reverse this date string-to-integer operation, use the TO_CHAR function. To
perform DATE data type conversions, use the CAST or CONVERT function.
Note:
An earlier version of TO_DATE supported date integer-to-string conversions that
now must be done using the TO_CHAR function. Older applications may have to be
modified.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.TODATE(date_string,format)
The TO_DATE function can be used in data definition when supplying a default
value to a field. For example:

CREATE TABLE mytest
(ID NUMBER(12,0) NOT NULL,
End_Year DATE DEFAULT TO_DATE('31-12-2007','DD-MM-YYYY') NOT NULL)

For further details on this use of TO_DATE, refer to the CREATE TABLE command.
Date String
The first argument specifies a date string literal. You can supply a date
string of any kind for the input date_string. Each character must correspond to
the format string, with the following exceptions:

  • Leading zeros may be included or omitted (with the exception a date_string
    without separator characters).
  • Years may be specified with two digits or four digits.
  • Month names may be specified in full or as the first three letters of the
    name. Only the first three letters must be correct. Month names are not
    case sensitive.
  • Time values appended to a date are ignored.

Format
The second argument specifies a date format as a string of code characters.
Default Date Format
If you specify no format, TO_DATE parses the date string using the default
format. The supplied default format is DD MON YYYY. For example, '11 Nov 1993'.
This default format is configurable, using the Caché ObjectScript 
$SYSTEM.SQL.SetToDateDefaultFormat() class method. To determine the current
setting, call $SYSTEM.SQL.CurrentSettings(), which displays the 
TO_DATE() Default Format setting.
Format Elements
A format is a string of one or more format elements specified according to the
following rules:

  • Format elements are not case-sensitive.
  • Almost any sequence or number of format elements is permitted.
  • Format strings separate their elements with non-alphanumeric separator
    characters (for example, a space, slash, or hyphen) that match the
    separator characters in the date_string. This use of specified date
    separator characters does not depend on the DateSeparator defined for your
    NLS locale.
  • The following date format strings do not require separator characters: 
    MMDDYYYY, DDMMYYYY, YYYYMMDD, and YYYYDDMM. The incomplete date format 
    YYYYMM is also supported, and assume a DD value of 01. Note that in these
    cases leading zeros must be provided for MM and DD values.

The following table lists the valid date format elements for the format
parameter:

Element                                 Meaning

DD       Two-digit day of month (01-31). Leading zeros are not required, unless
         format contains no date separator characters.

         Two-digit month number (01-12; 01 = January). Leading zeros are not
         required, unless format contains no date separator characters.
MM       Locale-specific exceptions include the following: In Japanese and
         Chinese, a month number consists of a numeric value followed by the
         ideogram for  month . In Russian, a month number can be specified in
         Roman numerals.

         Abbreviated name of month, as specified by the MonthAbbr property in
MON      the current locale. By default, this is the first three letters of the
         month name.

MONTH    Full name of the month, as specified by the MonthName property in the
         current locale.

YYYY     Four-digit year.

YY       Last two digits of the year. The first 2 digits of a 2-digit year
         default to 19.

RR /     Two-digit year to four-digit year conversion. (See below.)
RRRR

DDD      Day of the year. The number of days since January 1. (See below.)

J        Julian date. (See below.)

Two-Digit Year Conversion (RR and RRRR formats)
The YY format converts a two-digit year value to four digits by simply
appending 19. Thus 07 becomes 1907 and 93 becomes 1993.
The RR format provides more flexible two-digit to four-digit year conversion.
This conversion is based on the current year. If the current year is in the
first half of a century (for example, 2000 through 2050), two-digit years from
00 through 49 are expanded to a four-digit year in the current century, and
two-digit years from 50 through 99 are expanded to a four-digit year in the
previous century. If the current year is in the second half of a century (for
example, 2050 through 2099), all two-digit years are expanded to a four-digit
year in the current century. This expansion of two-digit years to four-digit
years is shown in the following example:

SELECT DISTINCT
       TO_DATE('29 September 00','DD MON RR'),
       TO_DATE('29 September 08','DD MON RR'),
       TO_DATE('29 September 49','DD MON RR'),
       TO_DATE('29 September 50','DD MON RR'),
       TO_DATE('29 September 77','DD MON RR')
      FROM Sample.Person
The RRRR format permits you to input a mix of two digit and four-digit years.
Four-digit years are passed through unchanged (the same as YYYY). Two-digit
years are converted to four-digit years, using the RR format algorithm. This is
shown in the following example:

SELECT DISTINCT
       TO_DATE('29 September 2008','DD MON RRRR')AS FourDigit,
       TO_DATE('29 September 08','DD MON RRRR') AS TwoDigit,
       TO_DATE('29 September 1949','DD MON RRRR') AS FourDigit,
       TO_DATE('29 September 49','DD MON RRRR') AS TwoDigit,
       TO_DATE('29 September 1950','DD MON RRRR') AS FourDigit,
       TO_DATE('29 September 50','DD MON RRRR') AS TwoDigit
       FROM Sample.Person
Day of the Year (DDD format)
You can use DDD to convert the day of the year (number of days elapsed since
January 1) to an actual date. The format string DDD,YYYY must be paired with a
corresponding date_string consisting of an integer number of days and a
four-digit year. (Two-digit years cannot be used with DDD.) The number of
elapsed days must be a positive integer in the range 1 through 365 (366 if YYYY
is a leap year). The four-digit year must be within the standard Caché date
range: 1841 through 9999. The DDD and YYYY format elements can be specified in
any order; a separator character between them is mandatory. The following
example shows this use of Day of the Year:

SELECT DISTINCT TO_DATE('2008:60','YYYY:DDD')
FROM Sample.Person
If a format string contains both a DD and a DDD element, the DDD element is
dominant. This is shown in the following example, which returns 2/29/2008 (not
12/31/2008):

SELECT DISTINCT TO_DATE('2008-12-31-60','YYYY-MM-DD-DDD')
FROM Sample.Person
TO_DATE permits you to return a date expression corresponding to a day of the
year. TO_CHAR permits you to return the day of the year corresponding to a date
expression.
Julian Dates (J format)
In Caché SQL, a Julian date should be used for any date before December 31,
1840. Because Caché represents this date internally as 0, special syntax is
needed to represent earlier dates. TO_DATE provides a format of 'J' (or 'j')
for this purpose. Julian date conversion converts a seven-digit internal
numeric value (a Julian day count) to a display-format or ODBC-format date. For
example:

SELECT DISTINCT TO_DATE(2300000,'J')
FROM Sample.Person
returns the following date: 1585 01 31 (ODBC format) or 01/31/1585 (display
format). Julian day count 1721424 returns January 1st of the Year 1 (1 01 01).
Julian day counts such as 1709980 (battle of Actium marks beginning of Roman
Empire under Augustus Caesar) return BCE (BC) dates, which are displayed with
the year preceded by a minus sign.
Note:
The following consideration should not affect the interconversion of dates and
Julian day counts using TO_CHAR and TO_DATE. It may affect some calculations
made using Julian day counts.
Julian day counts prior to 1721424 (1/1/1) are compatible with other software
implementations, such as Oracle. They are not identical to BCE dates in
ordinary usage. In ordinary usage, there is no Year 0; dates go from 12/31/-1
to 1/1/1. In Oracle usage, the Julian dates 1721058 through 1721423 are simply
invalid, and return an error. In Caché these Julian dates return the
non-existent Year 0 as a place holder. Thus calculations involving BCE dates
must be adjusted by one year to correspond to common usage.
A Julian day count is always represented internally as a seven-digit number,
with leading zeros when necessary. TO_DATE allows you to input a Julian day
count without the leading zeros. The highest permitted Julian date is 5373484,
it returns 12/31/9999. The lowest permitted Julian date is 0000001, it returns 
01/01/-4712 (which is BCE date 01/01/-4713). Any value outside this range
generates an SQLCODE -400 error, with a %msg value of 
 Invalid Julian Date value. Julian date must be between 1 and 5373484 .
TO_DATE permits you to return a date expression corresponding to a Julian day
count. TO_CHAR permits you to return a Julian day count corresponding to a date
expression, as shown in the following example:

SELECT DISTINCT
  TO_CHAR('1776-07-04','J') AS JulianCount,
  TO_DATE(2369916,'J') AS JulianDate
FROM Sample.Person
Examples
Default Date Format Examples
The following embedded SQL example specifies date strings that are parsed using
the default date format. Both of these are converted to the DATE data type
internal value of 60537:

  &sql(SELECT DISTINCT
       TO_DATE('29 September 2006'),
       TO_DATE('29 SEP 2006')
    INTO :a,:b
    FROM Sample.Person)
  WRITE !,a,!,b
The following embedded SQL example specifies date strings with two-digit years
with format default. Note that two-digit years default to 1900 through 1999.
Thus, the internal DATE value is 24012:

  &sql(SELECT DISTINCT
       TO_DATE('29 September 06'),
       TO_DATE('29 SEP 06')
    INTO :a,:b
    FROM Sample.Person)
  WRITE !,a,!,b
Specified Date Format Examples
The following embedded SQL example specifies date strings in various formats.
All of these are converted to the DATE data type internal value of 60810.

  &sql(SELECT DISTINCT
       TO_DATE('2007 Jun 29','YYYY MON DD'),
       TO_DATE('JUNE 29, 2007','month dd, YYYY'),
       TO_DATE('2007***06***29','YYYY***MM***DD'),
       TO_DATE('06/29/2007','MM/DD/YYYY')
    INTO :a,:b,:c,:d
    FROM Sample.Person)
  WRITE !,a,!,b,!,c,!,d
The following embedded SQL example specifies date formats that do not require
element separators. They return the date internal value of 60810:

  &sql(SELECT DISTINCT
       TO_DATE('06292007','MMDDYYYY'),
       TO_DATE('29062007','DDMMYYYY'),
       TO_DATE('20072906','YYYYDDMM'),
       TO_DATE('20070629','YYYYMMDD')
    INTO :a,:b,:c,:d
    FROM Sample.Person)
  WRITE !,a,!,b,!,c,!,d
The following example specifies the YYYYMM date format. It does not require
element separators. This example returns the date June 1, 2007 (06/01/2007):

 SELECT DISTINCT
       TO_DATE('200706','YYYYMM')
       FROM Sample.Person
See Also

  • SQL functions: CAST CONVERT TO_CHAR TO_NUMBER
  • Caché ObjectScript functions: $ZDATE $ZDATEH


 #}}}
*TO_NUMBER*  #{{{

A string function that converts a given string expression to a value of NUMBER
data type.
Synopsis

TO_NUMBER(string-expression)

TONUMBER(string-expression)

Arguments

                   The string expression to be converted. The expression can be
string-expression  the name of a column, a string literal, or the result of
                   another function, where the underlying data type is of type
                   CHAR or VARCHAR2.

Description
TO_NUMBER converts a string to a number and returns the number. TO_CHAR
converts a number to a string.
Note that the names TO_NUMBER and TONUMBER are interchangeable. They are
supported for Oracle compatibility.
TO_NUMBER conversion takes a numeric string and converts it to a canonical
number by removing leading and trailing zeros and a trailing decimal separator
character, resolving plus and minus signs, and expanding exponential notation
("E" or "e").
TO_NUMBER halts conversion when it encounters a nonnumeric character (such as a
letter or a numeric group separator). Thus the string '7dwarves' converts to 7.
TO_NUMBER does not resolve arithmetic operations. Thus the string '2+4'
converts to 2. If the first character of string-expression is a nonnumeric
string, TO_NUMBER returns 0. If string-expression is an empty string (''), 
TO_NUMBER returns 0. If NULL is specified for string-expression, TO_NUMBER
returns null.
Examples
Note:
The following examples use a period (.) as the decimal separator character and
a comma (,) as the numeric group separator character.
The following two examples show how TO_NUMBER converts a string to a number:
removing leading and trailing zeros, resolving multiple signs and removing plus
signs, and truncating the number when it encounters a nonnumeric character:

SELECT DISTINCT TO_NUMBER('+-+-01000.00+') AS Num
FROM Sample.Person
returns: 1000
However, because a comma is not considered a numeric character:

SELECT DISTINCT TO_NUMBER('+-+-01,000.00+') AS Num
FROM Sample.Person
returns: 1
The following example resolves exponential notation:

SELECT DISTINCT TO_NUMBER('+7E-2') AS Num
FROM Sample.Person
returns: .07
The following example shows how to use TO_NUMBER to list street addresses
ordered in ascending numerical order:

SELECT Home_Street,Name
FROM Sample.Person
ORDER BY TO_NUMBER(Home_Street)
Compare the results with the same data ordered in ascending string order:

SELECT Home_Street,Name
FROM Sample.Person
ORDER BY Home_Street
See Also

  • TO_CHAR
  • TO_DATE


 #}}}
*TRIM*  #{{{

A string function that returns a character string with leading and/or trailing
characters removed.
Synopsis

TRIM(end_keyword string-expression-1 FROM string-expression-2)

Arguments

                     Optional  A keyword specifying the which end of 
end_keyword          string-expression-2 to strip. Available values are
                     LEADING, TRAILING, BOTH. The default is BOTH.

                     The string expression specifying the characters to strip
string-expression-1  from string-expression-2. Every instance of the specified
                     character is stripped. Thus 'abc' strips 'bbbaacaaa'.

                     The string expression which will be stripped. Both string
                     expressions can be the name of a column, a string literal,
string-expression-2  or the result of another function, where the underlying
                     data type can be represented as any character type (such
                     as CHAR or VARCHAR2).

Description
TRIM returns NULL if passed a NULL value to either string expression.
The optional end_keyword argument can take the following values:

LEADING   A keyword that specifies that the characters in string-expression-1
          are to be removed from the beginning of string-expression-2.

TRAILING  A keyword that specifies that the characters in string-expression-1
          are to be removed from the end of string-expression-2.

          A keyword that specifies that the characters in string-expression-1
BOTH      are to be removed from both the beginning and end of 
          string-expression-2. BOTH is the default and is used if no 
          end_keyword is specified.

You can use LTRIM to trim leading blanks, or RTRIM to trim trailing blanks.
Examples
The following example uses the end_keyword default and removes leading and
trailing blanks from "abc":

SELECT DISTINCT TRIM(' ' FROM '   abc   ') AS Trimmed
     FROM Sample.Person
The following example removes the character "x" from the beginning of the
string "xxxabcxxx", resulting in "abcxxx":

SELECT DISTINCT TRIM(LEADING 'x' FROM 'xxxabcxxx') AS Trimmed
     FROM Sample.Person
The following example removes the character "x" from the beginning and end of
"xxxabcxxx", resulting in "abc":

SELECT DISTINCT TRIM(BOTH 'x' FROM 'xxxabcxxx') AS Trimmed
     FROM Sample.Person
The following example removes all instances of the characters "xyz" from the
end of "abcxxyz", resulting in "abc":

SELECT DISTINCT TRIM(TRAILING 'xyz' FROM 'abcxxyz') AS Trimmed
     FROM Sample.Person
See Also

  • SQL functions: LTRIM RTRIM
  • Caché ObjectScript function: $ZSTRIP


 #}}}
*TRUNCATE*  #{{{

A scalar numeric function that truncates a number at a specified number of
digits.
Synopsis

{fn TRUNCATE(numeric-expr,integer-expr)}

Arguments

numeric-expr  The number to be truncated. A number or numeric expression.

              An integer (or an expression that evaluates to an integer) that
              specifies the number of places to truncate, counting from the
integer-expr  decimal point. Can be zero, a positive integer, or a negative
              integer. If integer-expr is a decimal number, Caché rounds it to
              the nearest integer.

Description
TRUNCATE truncates numeric-expr by truncating at the integer-expr number of
digits from the decimal point. It does not round numbers or add padding zeroes.
Leading and trailing zeroes are removed before the TRUNCATE operation. TRUNCATE
returns the same data type as numeric-expr.

  • If integer-expr is a positive number, truncation is performed at that
    number of digits to the right of the decimal point. If integer-expr is
    equal to or larger than the number of decimal digits, no truncation or zero
    filling occurs.
  • If integer-expr is zero, the number is truncated to a whole integer. In
    other words, truncation is performed at zero digits to the right of the
    decimal point; all decimal digits and the decimal point itself are
    truncated.
  • If integer-expr is a negative number, truncation is performed at that
    number of digits to the left of the decimal point. If integer-expr is equal
    to or larger than the number of integer digits in the number, zero is
    returned.
  • If numeric-expr is zero (however expressed: 00.00, -0, etc.) TRUNCATE
    returns 0 (zero) with no decimal digits, regardless of the integer-expr
    value.
  • If numeric-expr or integer-expr is NULL, TRUNCATE returns NULL.

TRUNCATE and ROUND are numeric functions that perform similar operations; they
both can be used to decrease the number of significant decimal or integer
digits of a number. However, TRUNCATE does not perform rounding. TRIM can be
used to perform a similar truncation operation on strings.
TRUNCATE can only be used as an ODBC scalar function (with the curly brace
syntax).
Examples
The following two examples both truncate a number to two decimal digits. The
first specifies integer-expr as an integer, the second (using embedded SQL)
specifies integer-expr as a host variable that resolves to an integer:

SELECT DISTINCT {fn TRUNCATE(654.321,2)} AS Trunc
FROM Sample.Person

  SET x=2
  &sql(SELECT {fn TRUNCATE(654.321,:x)}
  INTO :a
  FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"truncated value is:",a }
both examples return 654.32 (truncation to two decimal places).
The following example specifies a integer-expr larger than the number of
decimal digits:

SELECT DISTINCT {fn TRUNCATE(654.32100,9)} AS Trunc
FROM Sample.Person
it returns 654.321 (Caché removed the trailing zeroes before the truncation
operation; no truncation or zero padding occurred).
The following example specifies a integer-expr of zero:

SELECT DISTINCT {fn TRUNCATE(654.321,0)} AS Trunc
FROM Sample.Person
it returns 654 (all decimal digits and the decimal point are truncated).
The following example specifies a negative integer-expr:

SELECT DISTINCT {fn TRUNCATE(654.321,-2)} AS Trunc
FROM Sample.Person
it returns 600 (two integer digits have been truncated and replaced by zeroes;
note that no rounding has been done).
The following example specifies a negative integer-expr as large as the integer
portion of the number:

SELECT DISTINCT {fn TRUNCATE(654.321,-3)} AS Trunc
FROM Sample.Person
it returns 0.
See Also

  • SQL functions: ROUND RTRIM TRIM
  • Caché ObjectScript function: $NORMALIZE


 #}}}
*UCASE*  #{{{

A string function that converts all lowercase letters in a string to uppercase
letters.
Synopsis

UCASE(string-expression)
{fn UCASE(string-expression)}

Arguments

                   The string whose characters are to be converted to
                   uppercase. The expression can be the name of a column, a
string-expression  string literal, or the result of another scalar function,
                   where the underlying data type can be represented as any
                   character type (such as CHAR or VARCHAR).

Description
Converts lowercase letters to uppercase. It has no effects on non-alphabetic
characters; it leaves unchanged numbers, punctuation, and leading or trailing
blank spaces.
Note that UCASE can be used as an ODBC scalar function (with the curly brace
syntax) or as an SQL general function.
UCASE does not force a numeric to be interpreted as a string. Caché SQL removes
leading and trailing zeros from numerics. A numeric specified as a string
retains leading and trailing zeros.
The %SQLUPPER function is the preferred way in SQL to convert a data value for
not case-sensitive comparison or collation. Refer to %SQLUPPER for further
information on case transformation functions.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.UPPER(expression)
Examples
The following example returns each person’s name in uppercase letters:

SELECT Name,{fn UCASE(Name)} AS CapName
     FROM Sample.Person
UCASE also works on Unicode (non-ASCII) alphabetic characters, as shown in the
following embedded SQL example, which converts Greek letters from lowercase to
uppercase:

   SET a=$CHAR(950,949,965,963)
   &sql(SELECT UCASE(:a)
   INTO :b
   FROM Sample.Person)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,a,!,b }
See Also

  • SQL functions: %ALPHAUP LCASE %SQLUPPER UPPER %UPPER
  • Caché ObjectScript function: $ZCONVERT


 #}}}
*UNION*  #{{{

Combines one or more SELECT statements.
Synopsis

select-statement {UNION [ALL] select-statement}

select-statement {UNION [ALL] (query)}

(query) {UNION [ALL] select-statement}

(query) {UNION [ALL] (query)}

Arguments

                  Optional  A keyword literal. If specified, duplicate data
ALL               values are returned. If omitted, duplicate data values are
                  suppressed.

select-statement  A SELECT statement, which retrieves data from a database.

query             A query that combines one or more SELECT statements.

Description
A UNION combines two or more queries into a single query that retrieves data
into a result set. The queries that are combined by a UNION can be simple
queries, consisting of a single SELECT statement, or compound queries.
For a union to be possible between SELECT statements, the number of columns
specified in each must match, and each specified column must be of a compatible
data type with the corresponding column position in the other SELECT statement
(s). You can specify a NULL column in one SELECT to pair with a data column in
another SELECT in order to match the number of columns. This use of NULL is
shown in the example below. Specifying incompatible column lists results in an
SQLCODE -9 error.
Caution:
To use the SELECT * syntax in a UNION, the tables must contain the same number
of columns. Therefore, changing the table definition by adding or deleting a
column may cause unforeseen errors in unions of this sort.
Because corresponding columns rarely have the same names in two tables, it is
recommended that you use the AS clause to identify the result set columns. If
no AS is specified, and the column names are not identical, Caché SQL assigns
names such as Literal_2 to the result set columns.
An ordinary UNION eliminates duplicate rows (all values identical) from the
result set. A UNION ALL preserves duplicate rows in the result set.
A UNION statement can conclude with an ORDER BY clause, which orders the result
set. You cannot specify an ORDER BY clause in any other location in a union.
Using a column number in ORDER BY that does not correspond to a SELECT list
column results in an SQLCODE -5 error. Using a column name in ORDER BY that
does not correspond to a SELECT list column results in an SQLCODE -6 error.
String fields in the result set are always assigned EXACT collation.
Examples
The following example creates a result set that contains a row for every Name
found in each of the two tables; if a Name is found in both tables, two rows
are created. When the Name is an employee, it lists the office location,
concatenated with the word  office as State, and the employee’s Title. When
Name is a person, it lists the home location, concatenated with the word  home 
as State, and <null> for Title. The ORDER BY clause operates on the result set;
the combined rows are ordered by Name:

SELECT Name,Office_State||' office' AS State,Title
FROM Sample.Employee
UNION
SELECT Name,Home_State||' home',NULL
FROM Sample.Person
ORDER BY Name
The following two examples show the effects of the ALL keyword. In the first
example, UNION returns only unique values. In the second example, UNION ALL
returns all values, including duplicates:

SELECT Name
FROM Sample.Employee
WHERE Name %STARTSWITH 'A'
UNION
SELECT Name
FROM Sample.Person
WHERE Name %STARTSWITH 'A'
ORDER BY Name

SELECT Name
FROM Sample.Employee
WHERE Name %STARTSWITH 'A'
UNION ALL
SELECT Name
FROM Sample.Person
WHERE Name %STARTSWITH 'A'
ORDER BY Name
See Also

  • SELECT ORDER BY
  • CREATE QUERY CREATE PROCEDURE
  •  Querying the Database chapter in Using Caché SQL


 
AND condition-expression]  

where value-assignment-statement can be:
   SET column = scalar-expression [,column = scalar-expression]
   (column1[,column2]) VALUES (scalar-expression[,scalar-expression])
   VALUES (scalar-expression[,scalar-expression])

Arguments

                        Optional  One or more of the following keywords,
restriction             separated by spaces: %NOLOCK, %NOCHECK, %NOINDEX,
                        %NOTRIGGER.

                        The name of an existing table where data is to be
table-ref               updated. You can also specify a view through which to
                        perform the update on a table.

                        Optional  An alias for a table-ref (table or view)
AS t-alias              name. An alias must be a valid identifier. The AS
                        keyword is optional.

FROM table2             Optional  Specifies a table used in constructing a
                        complex condition-expression (see below).

                        Optional  Specifies one or more boolean predicates used
WHERE                   to determine which rows are to be updated. If a WHERE
condition-expression    clause (or a WHERE CURRENT OF clause) is not supplied, 
                        UPDATE updates all the rows in the table. For further
                        details, see WHERE.

                        Optional  Specifies that the UPDATE begins at the
                        current position of cursor, which is a cursor that
WHERE CURRENT OF        points to the table. Either updates the row the cursor
cursor                  points to and all row subsequent to this position, or
                        (if an AND clause is supplied) all of these rows that
                        match the AND conditional expression. For further
                        details, see WHERE CURRENT OF.

AND                     Optional  Used with a WHERE CURRENT OF clause to
conditional-expression  specify a condition used to determine which rows are to
                        be updated.

                        Optional  The name of an existing column. Multiple
column                  column names are specified as a comma-separated list.
                        If omitted, all columns are updated.

                        A column data value expressed as a scalar expression.
scalar-expression       Multiple data values are specified as a comma-separated
                        list with each data value corresponding in sequence to
                        a column.

Description
An UPDATE command changes existing values for columns in a table. You can
update data in a table directly, update through a view, or update using a
subquery enclosed in parentheses. Updating through a view is subject to
requirements and restrictions, as described in CREATE VIEW.
The UPDATE command provides one or more new column values to one or more
existing base table rows that contain those columns. Assignment of data values
to columns is done using a value-assignment-statement. By default, a 
value-assignment-statement updates all rows in the table.
More commonly, an UPDATE specifies the updating of a specific row (or rows)
based on a conditional-expression. By default, an UPDATE operation goes through
all of the rows of a table and updates all rows that satisfy the 
conditional-expression. If no rows satisfy the conditional-expression, UPDATE
completes successfully and returns an SQLCODE 100 (No more data).
You can specify a WHERE clause or a WHERE CURRENT OF clause (but not both). If
the WHERE CURRENT OF clause is used, the UPDATE operation begins at the current
position of the cursor. For details on positioned operations, see WHERE CURRENT
OF.
The UPDATE operation sets the %ROWCOUNT local variable to the number of updated
rows, and the %ROWID local variable to the Row ID of the last row updated.
By default, the UPDATE operation is an all-or-nothing event. Either all
specified rows and columns are updated, or none are.
Privileges
To perform an update, you must either have column-level UPDATE privilege for
the specified column(s), or table-level UPDATE privilege for the specified
table (or view). When updating all fields in a row, note that column-level
privileges cover all table columns named in the GRANT command; table-level
privileges cover all table columns, including those added after the privilege
was assigned. Failing to have the necessary privileges results in an SQLCODE
-99 (Privilege Violation) error. See the GRANT command for further details.
You must have SELECT privilege for fields in a WHERE clause, whether or not
those fields are to be updated. You must have both SELECT and UPDATE privileges
for those fields if they are included in the update field list. In the
following example, the Name field must have (at least) column-level SELECT
privilege:

UPDATE Sample.Employee (Salary) VALUES (1000000) WHERE Name='Smith, John'

In the above example, the Salary field requires only column-level UPDATE
privilege.
Value Assignment
You can assign new values to specified columns in a variety of ways.

  • Using the SET keyword, specify one or more column = scalar-expression pairs
    as a comma-separated list. For example:
   
    SET StatusDate='05/12/06',Status='Purged'

  • Using the VALUES keyword, specify a list of columns equated to a
    corresponding scalar-expressions list. For example:
   
    (StatusDate,Status) VALUES ('05/12/06','Purged')

    When assigning scalar-expression values to a column list, there must be a
    scalar-expression for each specified column.
  • Using the VALUES keyword, specify a list of scalar-expressions
    corresponding to all of the columns of the row. The list of column names
    may be omitted. For example:
   
    VALUES ('Fred Wang',65342,'22 Main St. Anytown MA','123-45-6789')

Data values must correspond positionally to the column names in the column-list
. If no column list is specified, you must specify a value for each base table
column, specified in column number order.
DISPLAY to LOGICAL Data Conversion
Data is stored in LOGICAL mode format. If you specify data values in DISPLAY
mode during an UPDATE operation, data conversion from DISPLAY mode to LOGICAL
mode depends on the current SELECTMODE. You can specify the SELECTMODE in a 
CREATE FUNCTION, CREATE METHOD, or CREATE PROCEDURE command, or in embedded SQL
using the Caché ObjectScript #SQLCompile preprocessor command setting:

  • For SELECTMODE=RUNTIME mode (the default), conversion is performed. You can
    specify data values in either DISPLAY mode or LOGICAL mode format. The data
    values are stored in LOGICAL mode format.
  • For SELECTMODE=DISPLAY mode, no conversion is performed. You must specify
    data values in LOGICAL mode format. Attempting to specify a DISPLAY mode
    value results in a field validation error.

For further details, see #SQLCompile Select in the  ObjectScript Macros and the
Macro Preprocessor chapter of Using Caché ObjectScript.
SQLCODE Errors
By default, a multi-row UPDATE is an atomic operation. If one or more rows
cannot be updated, the UPDATE operation fails and no rows are updated. Caché
returns a status variable SQLCODE, which indicates the success or failure of
the UPDATE. To update a table, the update must meet all table, column name, and
value requirements, as follows.
Tables:

  • The table must exist in the current (or specified) namespace. If the
    specified table cannot be located, Caché issues an SQLCODE -30 error.
  • The table cannot be defined as READONLY. Attempting to compile an UPDATE
    that references a read-only table results in an SQLCODE -115 error. Note
    that this error is now issued at compile time, rather than only occurring
    at execution time. See the description of READONLY objects in the Object
    Persistence chapter of Using Caché Objects.
  • If updating a table through a view, the view cannot be defined as WITH READ
    ONLY. Attempting to do so results in an SQLCODE -35 error. See the CREATE
    VIEW command for further details.

Column Names and Values:

  • The update cannot include duplicate field names. Attempting an update that
    specifies two fields with the same name results in an SQLCODE -377 error.
  • You cannot update non-modifiable fields, such as a RowId field or an
    IDENTITY field. The field values for these fields are system-generated and
    not user-modifiable. Attempting to do so returns an SQLCODE -107 error. See
    the CREATE TABLE command for further details.
  • You cannot update a SERIAL data type field unless its currently has no data
    value (NULL), or has a value of 0. Attempting to do so returns an SQLCODE
    -105 error.
  • If updating one of the specified rows would violate foreign key referential
    integrity (and %NOCHECK is not specified), the UPDATE fails to update any
    rows and instead issues an SQLCODE -124 error.
  • You cannot update a non-stream field with stream data. This results in an
    SQLCODE -303 error, as described below.

List Structures
Caché supports the list structure data type %List (data type class
%Library.List). This is a compressed binary format, which does not map to a
corresponding native data type for Caché SQL. It corresponds to data type
VARBINARY with a default MAXLEN of 32749. For this reason, Dynamic SQL cannot
use UPDATE or INSERT to set a property value of type %List. For further
details, refer to the Data Types reference page in this manual.
Stream Values
You cannot use a single UPDATE to modify multiple rows that contain a stream
value field. Stream data fields must be updated one row at a time.
You can update a stream field using a fully formed object ID (OID) of a stream
object. Caché opens the stream object and copies its contents into the new
stream object.
You cannot update a non-Stream field with the contents of a Stream field. This
results in an SQLCODE -303 error:  No implicit conversion of Stream value to
non-Stream field in UPDATE assignment is supported . To update a string field
with Stream data, you must first use the SUBSTRING function to convert the
first n characters of the Stream data to a string, as shown in the following
example:

UPDATE MyTable
     SET MyStringField=SUBSTRING(MyStreamField,1,2000)

Atomicity
By default, UPDATE, INSERT, and DELETE are atomic operations. An UPDATE either
completes successfully or fails. If any of the specified rows fails the update,
none of the specified rows are updated, and the database reverts to its state
before issuing the UPDATE.
This default is modifiable within SQL by invoking SET TRANSACTION %COMMITMODE.
This default is also modifiable by invoking the following method: 
$SYSTEM.SQL.SetAutoCommit(). The following options are available:

  • IMPLICIT or 1 (autocommit on)  The default behavior, as described above.
  • NONE or 0 (no auto transaction)  No transaction is initiated when you
    invoke UPDATE, INSERT, or DELETE. A failed UPDATE, INSERT, or DELETE
    operation can leave the database in an inconsistent state, with some of the
    specified rows modified and some unmodified.
  • EXPLICIT or 2 (autocommit off)  UPDATE, INSERT, and DELETE commands
    automatically initiate a transaction, but you must explicitly commit (using
    TCOMMIT) or roll back this transaction following the operation.

Restriction Arguments
Specifying restriction argument(s) restricts processing as follows:

  • %NOCHECK  foreign key referential integrity checking is not performed. The
    WITH CHECK OPTION validation for a view is not performed when performing an
    UPDATE through a view.
  • %NOLOCK  the row is not locked upon UPDATE. This should only be used when a
    single user/process is updating the database.
  • %NOINDEX  the index maps are not set during UPDATE processing.
  • %NOTRIGGER  the base table triggers are not pulled (executed) during UPDATE
    processing. Neither BEFORE nor AFTER triggers are executed.

You can specify multiple restriction arguments in any order. Multiple arguments
are separated by spaces.
Referential Integrity
If you do not specify %NOCHECK, Caché uses the system configuration setting to
determine whether to perform foreign key referential integrity checking. You
can set the system default as follows:

  • The $SYSTEM.SQL.SetFilerRefIntegrity() method call.
  • Go to the System Management Portal, select [Home] > [Configuration] > [SQL
    Settings] > [General SQL Settings]. View and edit the current setting of 
    Perform Referential Integrity Checks on Foreign Keys for INSERT, UPDATE, and DELETE
    . The default is  Yes .

During an UPDATE operation, for every foreign key reference which has a field
value being updated, a shared lock is acquired on both the old (pre-update)
referenced row and the new (post-update) referenced row in the referenced table
(s). These rows are locked until the end of the transaction. Locking the old
row ensures that the referenced row is not changed before a potential rollback
of the UPDATE. Locking the new row ensures that the referenced row is not
changed between the UPDATE referential integrity checking and the end of the
transaction.
Transaction Locking
If you do not specify %NOLOCK, Caché performs standard locking on INSERT, 
UPDATE, and DELETE operations. Unique field values are locked for the duration
of the current transaction.
The default lock threshold is 1000 locks per table. This means that if you
update more than 1000 unique field values in a table during a transaction, the
lock threshold is reached and Caché automatically elevates the locking level
from unique field value locks to a table lock. This permits large-scale updates
during a transaction without overflowing the lock table.
This lock threshold value is configurable. Go to the System Management Portal,
select [Home] > [Configuration] > [SQL Settings] > [General SQL Settings]. View
and edit the current setting of Lock Threshold. For further details on
transaction locking refer to Transaction Processing in the  Modifying the
Database chapter of Using Caché SQL.
Row-Level Security
Caché row-level security permits UPDATE to modify any row that security permits
it to access. It allows you to update a row even if the update creates a row
that security will not permit you to subsequently access. To ensure that an
update does not prevent you from subsequent SELECT access to the row, it is
recommended that you perform the UPDATE through a view that has a WITH CHECK
OPTION. For further details, refer to CREATE VIEW.
FROM Clause Syntax
Commonly, a UPDATE command has no FROM keyword. It simply specifies the table
(or view) on which to update one or more rows.
However, you can also include an optional FROM clause after the 
value-assignment-statement. This FROM clause specifies a second table used in
the WHERE clause when selection criteria involve multiple tables. Updates are
performed only on the table specified at the beginning of the UPDATE, not on
the FROM clause table. A FROM clause can be complex, and can include ANSI join
syntax. Any syntax supported in a SELECT FROM clause is permitted in an UPDATE
FROM clause. UPDATE FROM clause support provides compatibility with
Transact-SQL.
The following example shows how this FROM clauses might be used. It updates
those records from the Employees table where the same EmpId is also found in
the Retirees table:

UPDATE Employees
     SET retired='Yes'
     FROM Retirees Rt
     WHERE Employees.EmpId = Rt.EmpId

For the UPDATE table-ref and the FROM clause to make reference to the same
instance of a table, the table must either be unaliased in both places, or both
must specify the same alias.
Examples
The following example updates the StatusDate and Status columns of the
Employees table for all rows that have a Status column value of  Completed .

UPDATE Employees
     SET StatusDate='05/12/06',Status='Purged'
     WHERE Status='Completed'

The following embedded SQL example inserts a row (if necessary), then updates
one of the field values of that row.

InsertRec
  &sql(INSERT INTO Sample.Person (Name,DOB,SSN) VALUES
   ('Fred Wang',46639,'111-22-3333'))
  IF SQLCODE = 0 {
    WRITE !,"Record inserted"
    GOTO UpdateRec }
  ELSEIF SQLCODE = -119 {
    WRITE !,"Record already exists"
    GOTO UpdateRec }
  ELSE {
  WRITE !,"Insert failed, SQLCODE=",SQLCODE
  QUIT }
UpdateRec
  NEW SQLCODE,%ROWCOUNT,%ROWID
  &sql(UPDATE Sample.Person
       SET DOB = 45639
       WHERE SSN = '111-22-3333')
    IF SQLCODE=0 {
    WRITE !,"Update succeeded"
    WRITE !,"Row count=",%ROWCOUNT
    WRITE !,"Row ID=",%ROWID }
    ELSE {
    WRITE !,"Update failed, SQLCODE=",SQLCODE }
Note:
An example program that deletes the record inserted by this program is provided
in the DELETE command documentation.
The following two programs create a table with four columns, insert a record,
then update all the columns of that record with new values. Because all of the
columns are being updated, the update VALUES keyword does not need to list the
column names.

   DO $SYSTEM.Security.Login("_SYSTEM","SYS")
   &sql(CREATE TABLE Sample.WordTest (
  Testnum     INT NOT NULL,
  Lang        CHAR(1) NOT NULL,
  Firstword   CHAR(30) ,
  Lastword    CHAR(30) ,
  CONSTRAINT WordTestPK PRIMARY KEY (Testnum))
  )
  IF SQLCODE=0 {
    WRITE !,"Table created" }
  ELSE {
    WRITE !,"CREATE TABLE failed. SQL code is: ",SQLCODE }

InsertRec
  &sql(INSERT INTO Sample.WordTest (Testnum,Lang,Firstword,Lastword) VALUES
   (1,'E','Hello','Goodbye'))
  IF SQLCODE = 0 {
    WRITE !,"Record inserted"
    GOTO UpdateRec }
  ELSE {
  WRITE !,"Insert failed, SQLCODE=",SQLCODE
  QUIT }
UpdateRec
   NEW SQLCODE,%ROWCOUNT,%ROWID
  &sql(UPDATE Sample.WordTest
       VALUES (2,'I','Pronto','Ciao')
       WHERE Lang='E')
    IF SQLCODE=0 {
    WRITE !,"Update succeeded"
    WRITE !,"Row count=",%ROWCOUNT
    WRITE !,"Row ID=",%ROWID }
    ELSE {
    WRITE !,"Update failed, SQLCODE=",SQLCODE }
The following example updates using a subquery:

UPDATE (SELECT name,age,ssn FROM Sample.Person WHERE age>65) AS view1
    SET name='Pension'||view2.name FROM view2
    WHERE view1.ssn=view2.ssn AND view2.age<70

See Also

  • CREATE TABLE ALTER TABLE DROP TABLE
  • INSERT DELETE
  • SELECT
  • VALUES
  • FROM
  • WHERE
  • WHERE CURRENT OF
  • CREATE VIEW
  •  Modifying the Database chapter in Using Caché SQL
  •  Defining Tables chapter in Using Caché SQL
  •  Defining Views chapter of Using Caché SQL.
  • Transaction Processing in the  Modifying the Database chapter of 
    Using Caché SQL.


 #}}}
*UPPER*  #{{{

Deprecated. A case-transformation function that converts alphabetic characters
to the UPPER collation format.
Synopsis

UPPER(expression)
UPPER expression

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

Description
This is a deprecated collation function. Please refer to %SQLUPPER for new
development. %SQLUPPER provides superior collation of numerics, NULL values and
empty strings.
UPPER converts all alphabetic characters to uppercase (i.e., the UPPER format).
It leaves unchanged numbers, punctuation, and leading or trailing blank spaces.
UPPER does not force a numeric to be interpreted as a string. Caché SQL removes
leading and trailing zeros from numerics. A numeric specified as a string
retains leading and trailing zeros.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.UPPER(expression)
Examples
The following example returns all names, selecting those where the uppercase
form of the name starts with  JO :

SELECT Name
FROM Sample.Person
WHERE UPPER(Name) %STARTSWITH UPPER('JO')
The following example returns all names in uppercase, selecting those where the
name starts with  JO :

SELECT UPPER(Name) AS CapName
FROM Sample.Person
WHERE Name %STARTSWITH UPPER('JO')
The following example converts the lowercase Greek letter Delta to uppercase.

SELECT DISTINCT UPPER {fn CHAR(948)},{fn CHAR(948)}
FROM Sample.Person
Note that the above example uses the UPPER syntax that uses a space, rather
than parentheses, to separate keyword from argument.
See Also
%SQLUPPER %UPPER %STARTSWITH

 #}}}
*%UPPER*  #{{{

Deprecated. A case-transformation function that converts alphabetic characters
to the UPPER collation format.
Synopsis

%UPPER(expression)
%UPPER expression

Arguments

            A string expression, which can be the name of a column, a string
expression  literal, or the result of another function, where the underlying
            data type can be represented as any character type (such as CHAR or
            VARCHAR2).

Description
This is a deprecated collation function. Please refer to %SQLUPPER for new
development. %SQLUPPER provides superior collation of numerics, NULL values and
empty strings.
%UPPER converts all alphabetic characters to uppercase (i.e., the UPPER
format). It leaves unchanged numbers, punctuation, and leading and trailing
blank spaces.
%UPPER does not force a numeric to be interpreted as a string. Caché SQL
removes leading and trailing zeros from numerics. A numeric specified as a
string retains leading and trailing zeros.
%UPPER is a Caché SQL extension and is intended for SQL lookup queries.
You can perform the same collation conversion in Caché ObjectScript using the
$ZUTIL(28) function. This function can also be invoked from Caché ObjectScript
using the following method call:
$SYSTEM.SQL.UPPER(expression)
Examples
The following example returns all names, selecting those where the uppercase
form of the name starts with  JO :

SELECT Name
FROM Sample.Person
WHERE %UPPER(Name) %STARTSWITH %UPPER('Jo')
The following example returns all names in uppercase, selecting those where the
name starts with  JO :

SELECT %UPPER(Name) AS CapName
FROM Sample.Person
WHERE Name %STARTSWITH 'Jo'
The following example converts the lowercase Greek letter Delta to uppercase.

SELECT DISTINCT %UPPER {fn CHAR(948)},{fn CHAR(948)}
FROM Sample.Person
Note that the above example uses the %UPPER syntax that uses a space, rather
than parentheses, to separate keyword from argument.
See Also
%SQLUPPER UPPER %STARTSWITH

 #}}}
*USER*  #{{{

A function that returns the user name of the current user.
Synopsis

USER

{fn USER}
{fn USER()}

Description
USER takes no arguments and returns the user name (also referred to as the
authorization ID) of the current user. The general function does not allow
parentheses; the ODBC scalar function can specify or omit the empty
parentheses.
A user name is defined with the CREATE USER command.
Typical uses for USER are in the SELECT statement select list or in the WHERE
clause of a query. In designing a report, USER can be used to print the current
user for whom the report is being produced.
Examples
The following example returns the current user name:

SELECT DISTINCT USER AS CurrentUser
FROM Sample.Person
The following example selects the name and record creation date information for
those records created by the current user:

SELECT Name FROM Sample.Person WHERE Name = USER
See Also
CREATE USER GRANT

 #}}}
*VALUES*  #{{{

Specifies data values for use in fields.
Synopsis

(field1{,fieldn})
     VALUES (value1{,valuen})

Arguments

field  A field name or a comma-separated list of field names.

value  A value or comma-separated list of values. Each value is assigned to the
       corresponding field.

Description
The VALUES clause is used in an INSERT or UPDATE statement to specify the data
values to insert into the fields. Typically:

  • INSERT queries use the following syntax:

    INSERT INTO tablename (fieldname,fieldname,...)
         VALUES (value,...)

  • UPDATE queries use the following syntax:

    UPDATE tablename (fieldname,fieldname,...)
         VALUES (value,...)

The elements in the VALUES clause correspond in sequence to the fields
specified after the table name. Note if there is only one value element
specified in the VALUES clause, it is not necessary to enclose the element in
parentheses.
The following embedded SQL example shows an INSERT statement that adds a single
row to the "Employee" table:

   &sql(INSERT INTO Employee (Name,SocSec,Telephone)
        VALUES("Boswell",333448888,"546-7989"))

INSERT and UPDATE queries can use a VALUES clause without requiring you to
explicitly specify a list of field names after the table name. In order to omit
the list of field names after the table name, your query must meet the
following two criteria:

  • The number of values specified in the VALUES clause is the same as the
    number of fields in the table (exclusive of the ID field).
  • The values in the VALUES clause are listed in order of the internal column
    numbers of the fields, beginning with column 2. Column 1 is always reserved
    for the system-generated ID field, and is not specified in a VALUES clause.

For example, the query:

INSERT INTO Sample.Person VALUES (5,"John")

is equivalent to the query:

INSERT INTO Sample.Person (Age,Name) VALUES (5,"John")

if the table "Sample.Person" has exactly two user-defined fields.
In this example, the value 5 is assigned to the field with the lower column
number, and the value "John" is assigned to the other field.
A VALUES clause can specify an element of an array, as is the following
embedded SQL example:

   &sql( UPDATE Person(Tel)
        VALUES :per("tel",)
        WHERE ID = :id )

An UPDATE query can also reference an array with unspecified last subscript.
Whereas INSERT uses the presence and absence of array elements to assign values
and default values to a newly created row, UPDATE uses the presence of an array
element to indicate that the corresponding field should be updated. For
example, consider the following array for a table with six columns:

emp("profile",2)="Smith"
emp("profile",3)=2
emp("profile",3,1)="1441 Main St."
emp("profile",3,2)="Cableton, IL 60433"
emp("profile",5)=NULL
emp("profile",7)=25
emp("profile","next")="F"

Column 1 is always reserved for the ID field, and is not user-specified. The
inserted "Employee" row has Column 2, "Name", set to "Smith"; Column 3,
"Address", set to a two-line value; Column 4, "Department", is not specified,
and is thus set to the default, and Column 5, "Location", is set to NULL. The
default value for "Location" is not used since the corresponding array element
is defined with a null value. The array elements "7" and "next" do not
correspond to column numbers in the "Employee" table, therefore the query
ignores them. Here’s the UPDATE statement that uses this array:

  &sql(UPDATE Employee
       VALUES :emp('profile',)
       WHERE Employee = 379)

Given the above definitions and array values, this statement will update the
values of the "Name", "Address", and "Location" fields of the "Employee" row
for which Row ID = 379.
However, omitting the subscript entirely results in error code -54, Array
designator (last subscript omitted) expected after VALUES.
You may also use an array reference with an UPDATE query that targets multiple
rows, for example:

  &sql(UPDATE Employee
       VALUES :emp('profile',)
       WHERE Type = 'PART-TIME')

A VALUES clause variable cannot use dot syntax. Therefore, the following
embedded SQL example is correct:

   SET sname = state.Name
   &sql(INSERT INTO StateTbl VALUES :sname)

The following is not correct:

     &sql(INSERT INTO State VALUES :state.Name)

NULL and empty string values are different. For further details, see NULL. For
backward compatibility, all empty string ('') values in older existing data are
considered as NULL values. In new data, empty strings are stored in the data as
$CHAR(0). Through SQL, NULL is referenced as 'NULL'. For example:

INSERT INTO Sample.Person
(SSN,Name,Home_City) VALUES ('123-45-6789','Doe,John',NULL)

Through SQL, empty string is referenced as '' (two single quotes). For example:

INSERT INTO Sample.Person
(SSN,Name,Home_City) VALUES ('123-45-6789','Doe,John','')

You cannot insert a NULL value for the ID field.
Examples
The following embedded SQL example inserts a record for  Doe,John into the
Sample.Person table. It then selects this record, and then deletes this record.
A second SELECT confirms the deletion.

   SET x="Doe,John",y="123-45-6789",z="Metropolis"
   SET (a,b,c,d,e)=0
   NEW SQLCODE,%ROWCOUNT,%ROWID
   &sql(INSERT INTO Sample.Person
   (Name,SSN,Home_City) VALUES (:x,:y,:z))
   IF SQLCODE'=0 {
     WRITE !,"INSERT Error code ",SQLCODE
     QUIT }
   &sql(SELECT Name,SSN,Home_City
        INTO :a,:b,:c
        FROM Sample.Person
        WHERE Name =:x)
   IF SQLCODE'=0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
      WRITE !,"After INSERT:"
      WRITE !,"Name=",a," SSN=",b," City=",c
      WRITE !,"SQL code=",SQLCODE," Number of rows=",%ROWCOUNT }
    &sql(DELETE FROM Sample.Person
        WHERE Name=:x)
    &sql(SELECT Name,SSN
        INTO :d,:e
        FROM Sample.Person
        WHERE Name='Doe,John')
   IF SQLCODE <0 {
     WRITE !,"Error code ",SQLCODE }
   ELSE {
     WRITE !,"After DELETE:"
     WRITE !,"Name=",d," SSN=",e
     WRITE !,"SQL code=",SQLCODE," Number of rows=",%ROWCOUNT }
See Also
INSERT UPDATE

 #}}}
*WEEK*  #{{{

A scalar date/time function that returns an integer from 1 to 53 that
corresponds to the week of the year in a given date expression.
Synopsis

{fn WEEK(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
WEEK takes a date integer or datetime string, and returns the number of weeks
from the beginning of the year for that date. Weeks are calculated using the
$HOROLOG date (number of days since Dec. 31, 1840). Therefore, weeks are
counted from year to year, such that Week 1 is the days that complete the
seven-day period begun by the last week of the previous year. A week always
begins with a Sunday; therefore, the first Sunday of the calendar year marks
the changing from Week 1 to Week 2. If the first Sunday of the year is January
1, then that Sunday is in Week 1; if the first Sunday of the year is later than
January 1, then that Sunday is the first day of Week 2. For this reason, Week 1
is commonly less than seven days in length. You can determine the day of the
week by using the DAYOFWEEK function.
The total number of weeks in a year is commonly 53, and can be 54 in leap
years.
The same week information can be returned by using the DATEPART or DATENAME
function.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.WEEK(date-expression)
Date Validation
WEEK performs the following checks on input values. If a value fails a check,
the null string is returned.

  • A valid date-expression may be a DATE or TIMESTAMP data type value returned
    by a function such as CURRENT_DATE or NOW.
  • A valid date-expression may be a date string (yyyy-mm-dd) or a date and
    time string (yyyy-mm-dd hh:mm:ss). WEEK evaluates only the date portion of
    the string.
  • A date string must be complete and properly formatted with the appropriate
    number of elements and digits for each element, and the appropriate
    separator character. Years must be specified as four digits.
  • Date values must be within a valid range. Years: 1841 through 9999. Months:
    1 through 12. Days: 1 though 31.
  • The number of days in a month must match the month and year. For example,
    the date '02 29' is only valid if the specified year is a leap year.
  • Date values less than 10 may include or omit a leading zero. Other
    non-canonical integer values are not permitted. Therefore, a Day value of
    '07' or '7' is valid, but '007', '7.0' or '7a' are not valid.

Examples
The following embedded SQL example returns the day of week and week of year for
January 2, 2005 (which is a Sunday) and January 1, 2006 (which is a Sunday).

  SET x="2005-1-2"
  SET y="2006-1-1"
  &sql(SELECT {fn DAYOFWEEK(:x)},{fn WEEK(:x)},
       {fn DAYOFWEEK(:y)},{fn WEEK(:y)}
  INTO :a,:b,:c,:d
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"2005 Day of Week is: ",a," (Sunday=1)"
    WRITE " Week of Year is: ",b
    WRITE !,"2006 Day of Week is: ",c," (Sunday=1)"
    WRITE " Week of Year is: ",d }
The following examples return the number 9 because the date is the ninth week
of the year 2004:

SELECT DISTINCT {fn WEEK('2004-02-25')} AS Week
FROM Sample.Person

SELECT DISTINCT {fn WEEK('2004-02-25 08:35:22')} AS Week
FROM Sample.Person

SELECT DISTINCT {fn WEEK(59590)} AS Week
FROM Sample.Person
The following example returns the number 54 because this particular date is in
a leap year that began with Week 2 starting on the second day, as demonstrated
by the example immediately following it:

SELECT DISTINCT {fn WEEK('2000-12-31')} AS Week
FROM Sample.Person

SELECT DISTINCT
{fn WEEK('2000-01-01')}||{fn DAYNAME('2000-01-01')} AS WeekofDay1,
{fn WEEK('2000-01-02')}||{fn DAYNAME('2000-01-02')} AS WeekofDay2
FROM Sample.Person
The following examples return the current week:

SELECT DISTINCT {fn WEEK({fn NOW()})} AS Week_Now
FROM Sample.Person

SELECT DISTINCT {fn WEEK(CURRENT_DATE)} AS Week_Now
FROM Sample.Person

SELECT DISTINCT {fn WEEK(CURRENT_TIMESTAMP)} AS Week_Now
FROM Sample.Person
See Also
DATEPART DATENAME DAYOFWEEK MONTH QUARTER YEAR

AND condition-expression

Arguments

                      Specifies that the operation is done at the current
                      position of cursor, which is a cursor that points to the
cursor                table. Either updates or deletes the row the cursor
                      points to and all row subsequent to this position, or (if
                      an AND clause is supplied) all of these rows that match
                      the AND predicate condition.

AND                   Optional  Used with a WHERE CURRENT OF clause to further
condition-expression  limit the conditions under which the specified operation
                      occurs. See Overview of Predicates.

Description
The WHERE CURRENT OF clause can be used in an UPDATE or DELETE statement. It is
used with cursor-based commands, as in the following embedded SQL example:

   &sql(DELETE FROM Employees WHERE CURRENT OF EmployeeCursor)

which deletes the row that the last FETCH command obtained from the
"EmployeeCursor" cursor.
The following embedded SQL example shows an UPDATE operation using embedded
SQL:

   &sql(OPEN EmployeeCursor)
   FOR {
   &sql(FETCH EmployeeCursor)
   QUIT:SQLCODE'=0
   &sql(UPDATE Employees SET Field = :var WHERE CURRENT OF EmployeeCursor) }
   &sql(CLOSE EmployeeCursor)

Note that in an UPDATE statement with a WHERE CURRENT OF clause it is not valid
to specify the new value using current field values, such as 
SET Salary=Salary+100. Attempting to do so results in an SQLCODE -69 error: SET
<field> = <value expression> not allowed with WHERE CURRENT OF <cursor>.
See Also

  • DECLARE OPEN FETCH CLOSE
  • DELETE UPDATE
  • SQL Cursors in the  Using Embedded SQL chapter of Using Caché SQL


 #}}}
*XMLAGG*  #{{{

An aggregate function that creates a concatenated string of values.
Synopsis

XMLAGG([ALL | DISTINCT] string-expr [%FOREACH(col-list)] [%AFTERHAVING])

Arguments

              Optional  Specifies that XMLAGG returns a concatenated string of
ALL           all values for string-expr. This is the default if no keyword is
              specified.

              Optional  Specifies that XMLAGG returns a concatenated string
DISTINCT      containing only the unique string-expr values. If not specified,
              the default is ALL.

string-expr   An SQL expression that evaluates to a string. Commonly this is
              the name of a column from which to retrieve data.

%FOREACH(     Optional  A column name or a comma-separated list of column
col-list)     names. See SELECT for further information on %FOREACH

%AFTERHAVING  Optional  Applies the condition found in the HAVING clause.

Description
The XMLAGG aggregate function returns a concatenated string of all values from 
string-expr. The return value is of data type VARCHAR, with a default length of
4096. XMLAGG returns a concatenated string of values; to return a
comma-separated list of values, use the very similar LIST function.

  • A simple XMLAGG (or XMLAGG ALL) returns a string containing a concatenated
    string composed of all the values for string-expr in the selected rows.
    Rows where string-expr is NULL are ignored.
    The following two examples both return the same single value, a
    concatenated string of all of the values listed in the Home_State column of
    the Sample.Person table.
   
    SELECT XMLAGG(Home_State) AS All_State_Values
    FROM Sample.Person
   
    SELECT XMLAGG(ALL Home_State) AS ALL_State_Values
    FROM Sample.Person
    Note that this concatenated string contains duplicate values.
  • An XMLAGG DISTINCT returns a concatenated string composed of all the
    distinct (unique) values for string-expr. Rows where string-expr is NULL
    are ignored.
    The following example creates a concatenated string of all of the distinct
    (unique) values listed in the Home_State column of the Sample.Person table:
   
    SELECT XMLAGG(DISTINCT Home_State) AS DISTINCT_State_Values
    FROM Sample.Person

XML and XMLAGG
One common use of XMLAGG is to tag each data item from a column. This is done
by combining XMLAGG and XMLELEMENT as shown in the following example:

SELECT XMLAGG(XMLELEMENT("para",Home_State))
FROM Sample.Person

This results in an output string such as the following:

<para>LA</para><para>MN</para><para>LA</para><para>NH</para><para>ME</para>...

Examples
The following example creates a concatenated string of all of the distinct
values found in the FavoriteColors column of the Sample.Person table. Thus
every row has the same value for the All_Colors column. Note that while some
rows have a NULL value for FavoriteColors, this value is not included in the
concatenated string. Data values are returned in internal format.

SELECT Name,FavoriteColors,
   XMLAGG(DISTINCT FavoriteColors) AS All_Colors_In_Table
FROM Sample.Person
ORDER BY FavoriteColors
The following example creates a concatenated string of all of the distinct
values found in the Home_City column for each of the states. Every row from the
same state contains a list of all of the distinct city values for that state:

SELECT Home_State, Home_City,
   XMLAGG(DISTINCT Home_City %FOREACH(Home_State)) AS All_Cities_In_State
FROM Sample.Person
ORDER BY Home_State
For the following examples, suppose we have the following table, AutoClub:

   Name       Make      Model     Year

Smith,Joe    Pontiac  Firebird    1971

Smith,Joe    Saturn   SW2         1997

Smith,Joe    Pontiac  Bonneville  1999

Jones,Scott  Ford     Mustang     1966

Jones,Scott  Mazda    Miata       2000

The query:

SELECT DISTINCT Name, XMLAGG(Make) AS String_Of_Makes
FROM AutoClub WHERE Name = 'Smith,Joe'

returns:

  Name        String_Of_Makes

Smith,Joe  PontiacSaturnPontiac

The query:

SELECT DISTINCT Name, XMLAGG(DISTINCT Make) AS String_Of_Makes
FROM AutoClub WHERE Name = 'Smith,Joe'

returns:

  Name     String_Of_Makes

Smith,Joe  PontiacSaturn

See Also
LIST function
XMLELEMENT function
SELECT statement
Aggregate Functions

 #}}}
*XMLCONCAT*  #{{{

A function that concatenates XML elements.
Synopsis

XMLCONCAT(XmlElement1,XmlElement2[,XmlElementN])

Arguments

XmlElement  An XMLELEMENT function. Specify two or more XmlElement to
            concatenate.

Description
The XMLCONCAT function returns the values from several XMLELEMENT functions as
a single string. XMLCONCAT can be used in a SELECT query or subquery that
references either a table or a view. XMLCONCAT can appear in a SELECT list
alongside ordinary field values.
Examples
The following query concatenates the values from two XMLELEMENT functions:

SELECT Name,XMLCONCAT(XMLELEMENT("Para",Name),
                      XMLELEMENT("Para",Home_City)) AS ExportString
     FROM Sample.Person
A sample row of the data returned would appear as follows:

ExportString
<Para>Emerson,Molly N.</Para><Para>Boston</Para>

The following query nests an XMLCONCAT within an XMLELEMENT function:

SELECT XMLELEMENT("Item",Name,
          XMLCONCAT(
              XMLELEMENT("Para",Home_City,' ',Home_State),
              XMLELEMENT("Para",'is residence')))
       AS ExportString
FROM Sample.Person
A sample row of the data returned would appear as follows:

ExportString
<Item>Emerson,Molly N.<Para>Boston MA</Para><Para>is residence</Para></Item>

See Also
SELECT statement
XMLAGG function
XMLELEMENT function

 #}}}
*XMLELEMENT*  #{{{

A function that tags values returned from a specified column or columns.
Synopsis

XMLELEMENT(tag,expression[,expression])

XMLELEMENT(tag,XMLATTRIBUTES(expression [AS alias]),expression[,expression])

Arguments

            The name of an XML (or HTML) tag. The NAME keyword is optional.
            This argument has three syntactical forms: NAME "tag", "tag", and 
            NAME. The first two are functionally identical. If specified, tag
            must be enclosed in double quotes. The case of letters in tag is
NAME tag    preserved. A tag should contain at least one nonnumeric character
            (0 9, decimal point, leading + or  sign). No other validation
            checking is performed on tag. If you specify the NAME keyword
            without a tag value, Caché supplies the default tag value: <Name>
            ... </Name>.

            Any valid expression. Usually the name of a column that contains
            the data values to be tagged. You can specify a comma-separated
expression  list of columns or other expressions, all of which will be enclosed
            within the same tag. The first comma-separated element can be an 
            XMLATTRIBUTES function. Only one XMLATTRIBUTES element can be
            specified.

Description
The XMLELEMENT function returns the values of expression tagged with the XML
(or HTML) tag specified in tag. XMLELEMENT can be used in a SELECT query or
subquery that references either a table or a view. XMLELEMENT can appear in a 
SELECT list alongside ordinary field values.
Commonly, expression is the name of a field, (or an expression containing one
or more field names) in the multiple rows returned by a query.
The specified expression value is returned enclosed by a start tag and an end
tag, as shown in the following format:

<tag>value</tag>

If the value to be tagged is either the empty string ('') value or a NULL, the
following is returned:

<tag></tag>

If the expression contains multiple comma-separated elements, the results are
concatenated, as shown in the following format:

<tag>value1value2</tag>

XMLELEMENT functions can be nested. XMLELEMENT and XMLFOREST functions may be
nested in any combination. XMLELEMENT functions can be concatenated using
XMLCONCAT. However, XMLELEMENT does not do XML type resolution of entire
expressions. For example, XMLELEMENT can not perform character conversion
within a clause of a CASE statement (see example below).
XMLATTRIBUTES Function
The XMLATTRIBUTES function can only be used within an XMLELEMENT function. If
an element of expression is an XMLATTRIBUTES function, the specified expression
becomes an attribute of the tag, as shown in the following format:

<tag ID='63' >value</tag>

You can only specify one XMLATTRIBUTES function within an XMLELEMENT function.
By convention it is the first expression element, though it can be any element
in expression. Caché encloses attribute values with single quotes and inserts a
space between the attribute value and the closing angle bracket (>) for the
tag.
XMLELEMENT and XMLFOREST Compared

  • XMLELEMENT concatenates the values of its expression list within a single
    tag. XMLFOREST assigns a separate tag for each expression item.
  • XMLELEMENT requires that you specify a tag value. XMLFOREST allows you to
    either take default tag values or specify individual tag values. XMLELEMENT
    cannot specify an empty (nameless) tag: <>value</>; XMLFOREST can.
  • XMLELEMENT allows you to specify a tag attribute using XMLATTRIBUTES. 
    XMLFOREST does not allow you to specify a tag attribute.
  • XMLELEMENT returns a tag string for NULL. XMLFOREST does not return a tag
    string for NULL.

Punctuation Character Values
If a data value contains a punctuation character that XML/HTML might interpret
as a tag or other coding, XMLFOREST and XMLELEMENT convert this character to
the corresponding encoded form:
ampersand (&) becomes &amp;
apostrophe (') becomes &apos;
quotation mark (") becomes &quot;
open angle bracket (<) becomes &lt;
close angle bracket (>) becomes &gt;
To represent an apostrophe in a supplied text string, specify two apostrophes,
as in the following example: 'can''t'. Doubling apostrophes is not necessary
for column data.
Examples
The following example returns each person’s Name field value in Sample.Person
as ordinary data and as xml tagged data:

SELECT Name,
       XMLELEMENT("Para",Name) AS ExportName
     FROM Sample.Person
A sample row of the data returned would appear as follows:

Name                    ExportName
Emerson,Molly N.   <Para>Emerson,Molly N.</Para>

The following example returns every distinct Home_City and Home_State pair
value in Sample.Person as xml tagged data with the tag <Address> ... </
Address>:

SELECT DISTINCT
   XMLELEMENT(NAME "Address",Home_City,' ',Home_State) AS CityState
   FROM Sample.Person
   ORDER BY Home_City

Note that in the above example the optional NAME keyword is supplied. In the
next example, the NAME keyword is provided without the tag value:

SELECT DISTINCT
   XMLELEMENT(NAME,Home_City,' ',Home_State) AS CityState
   FROM Sample.Person
   ORDER BY Home_City
In this case the same data is returned, but is tagged with the default tag:
<Name> ... </Name>.
The following example shows that XMLELEMENT functions can be nested:

SELECT XMLELEMENT("Para",Home_State,
                 XMLELEMENT("Emphasis",Name),Age)
FROM Sample.Person
A sample row of the data returned would appear as follows:

<Para>CA<Emphasis>Emerson,Molly N.</Emphasis>24</Para>

The following example shows that XMLELEMENT can not tag a value within a CASE
statement clause:

SELECT XMLELEMENT("Para",Home_State,
    XMLELEMENT("Para",Name),
    CASE WHEN Age < 21 THEN NULL
      ELSE XMLELEMENT("Para",Age) END )
FROM Sample.Person
A sample row of the data returned would appear as follows:

<Para>CA<Para>Emerson,Molly N.</Para>&lt;Para&gt;24&lt;/Para&gt;</Para>

The following query returns the Name field values in Sample.Person as
XML-tagged data in a tag that uses the ID field as a tag attribute:

SELECT XMLELEMENT("Para",XMLATTRIBUTES(ID),Name)AS ExportName
     FROM Sample.Person
A sample row of the data returned would appear as follows:

ExportName
<Para ID='101' >Emerson,Molly N.</Para>

You can specify an alias for an attribute, as shown in the following example:

SELECT XMLELEMENT("Para",XMLATTRIBUTES(ID AS ItemKey),Name)AS ExportName
     FROM Sample.Person
A sample row of the data returned would appear as follows:

ExportName
<Para ItemKey='101' >Emerson,Molly N.</Para>

See Also
XMLAGG function
XMLCONCAT function
XMLFOREST function
SELECT statement

 #}}}
*XMLFOREST*  #{{{

A function that tags values returned from multiple columns.
Synopsis

XMLFOREST(expression [AS tag][,expression [AS tag]])

Arguments

            An expression, or (usually) a comma-separated list of expressions.
expression  Usually these are names of columns that contains the data values to
            be tagged. Each expression in the list will be enclosed in its own
            tag.

            Optional  The value of the tag for the preceding expression. If tag
            is unquoted, the first character of tag must be a letter; blanks
AS tag      and quotation marks are not permitted in tag. Enclosing tag in
            double quotes removes these restrictions. If tag is omitted, the
            tag value is either the name of the expression column or an empty
            tag.

Description
The XMLFOREST function returns the values of each expression tagged with its
own XML (or HTML) tag.
XMLFOREST can be used in a SELECT query or subquery that references either a
table or a view. XMLFOREST can appear in a SELECT list alongside ordinary
column values.
The specified expression value is returned enclosed by a start tag and an end
tag, as shown in the following format:

<tag>value</tag>

Commonly, expression is the name of a column, or an expression containing one
or more column names. XMLFOREST tags each expression as follows:

  • If AS tag is specified, XMLFOREST tags the resulting values with the
    specified tag. The tag value is case-sensitive.
  • If AS tag is omitted, and expression is a column name, XMLFOREST tags the
    resulting values with the column name. Column name default tags are always
    uppercase.
  • If AS tag is omitted, and expression is not a column name (for example, an
    aggregate function, a literal, or a concatenation of two columns) XMLFOREST
    tags the resulting values with a blank tag. For example: <>literal string
    </>

XMLFOREST provides a separate tag for each item in a comma-separated list. 
XMLELEMENT concatenates all of the items in a comma-separated list within a
single tag.
XMLFOREST functions can be nested. Any combination of nested XMLFOREST and 
XMLELEMENT functions is permitted. XMLFOREST functions can be concatenated
using XMLCONCAT.
NULL Values
The XMLFOREST function only returns a tag for actual data values. It does not
return a tag when the expression value is NULL. The empty string ('') is
considered a data value. If the value to be tagged is the empty string (''), 
XMLFOREST returns:

<tag></tag>

XMLFOREST differs from XMLELEMENT in the handling of NULL. XMLELEMENT always
returns a tag value, even when the field value is NULL.
Punctuation Character Values
If a data value contains a punctuation character that XML/HTML might interpret
as a tag or other coding, XMLFOREST and XMLELEMENT convert this character to
the corresponding encoded form:
ampersand (&) becomes &amp;
apostrophe (') becomes &apos;
quotation mark (") becomes &quot;
open angle bracket (<) becomes &lt;
close angle bracket (>) becomes &gt;
To represent an apostrophe in a supplied text string, specify two apostrophes,
as in the following example: 'can''t'. Doubling apostrophes is not necessary
for column data.
Examples
The following query returns the Name column values in Sample.Person as ordinary
data and as xml tagged data:

SELECT Name,XMLFOREST(Name) AS ExportName
     FROM Sample.Person
A sample row of the data returned would appear as follows. Here the tag
defaults to the name of the column:

Name                    ExportName
Emerson,Molly N.   <NAME>Emerson,Molly N.</NAME>

The following example specifies multiple columns:

SELECT XMLFOREST(Home_City,
                 Home_State AS Home_State,
                 AVG(Age) AS AvAge) AS ExportData
FROM Sample.Person
The Home_City field specifies no tag; the tag is generated from the column name
in all capital letters: <HOME_CITY>. The Home_State field’s AS clause is
optional. It is specified here because specifying the tag name allows you to
control the case of the tag: <Home_State>, rather than <HOME_STATE>. The AVG
(Age) AS clause is mandatory, because the value is an aggregate, not a column
value, and thus has no column name. A sample row of the data returned would
appear as follows.

ExportData
<HOME_CITY>Chicago</HOME_CITY><Home_State>IL</Home_State>
<AvAge>48.0198019801980198</AvAge>

See Also
XMLAGG function
XMLELEMENT function
XMLCONCAT function
SELECT statement

 #}}}
*YEAR*  #{{{

A date/time function that returns the year in a given date expression.
Synopsis

YEAR(date-expression)
{fn YEAR(date-expression)}

Arguments

date-expression  An expression that is the name of a column, the result of
                 another scalar function, or a date or timestamp literal.

Description
YEAR takes a date integer or a datetime string and returns the year as a
integer. The date-expression can be date with the data type DATE or TIMESTAMP,
or a datetime string with the format:

yyyy-mm-dd hh:mm:ss

The year (yyyy) portion should be a four-digit integer in the range 1840
through 9999. There is, however, no range checking for user-supplied values.
Numbers outside this range, negative numbers, and fractions are returned as
specified. Two digit years are not expanded to four digits.
Note:
For compatibility with Caché internal representation of dates, it is strongly
recommended that all year values be expressed as four-digit integers within the
range of 1840 through 9999.
The TO_DATE and TO_CHAR SQL functions support  Julian dates, which can be used
to represent years before 1840. Caché ObjectScript does not provide functions
supporting such Julian dates.
YEAR returns zero when the year portion is a string of one or more zeroes (for
example '0' or '0000'), or a nonnumeric value. YEAR interprets the initial
numeric string encountered as the year value, so omitting the year portion of
the date string ('-mm-dd hh:mm:ss'), or omitting the date portion ('hh:mm:ss')
results in the first number encountered ('-mm' or 'hh') being treated as the
year value. Thus, some placeholder should be supplied for an unknown year
value; for compatibility with Caché, 9999 is generally the preferred value.
The year format default is four-digit years. To change this year display
default, use the SET OPTION command with the YEAR_OPTION option.
The elements of a datetime string can be returned using the following SQL
scalar functions: YEAR, MONTH, DAY, DAYOFMONTH, HOUR, MINUTE, SECOND. The same
elements can be returned by using the DATEPART or DATENAME function. DATEPART
and DATENAME perform value and range checking on year values.
This function can also be invoked from Caché ObjectScript using the following
method call:
$SYSTEM.SQL.YEAR(date-expression)
Examples
The following examples return the integer 2004. No validation is performed:

SELECT DISTINCT YEAR('2004-02-16 12:45:37') AS Year_Given
FROM Sample.Person

SELECT DISTINCT {fn YEAR(59590)} AS Year_Given
FROM Sample.Person
The following examples return the year as 0 because the year field contains a
nonnumeric placeholder. The separator character ( ) must be preceded by a some
character(s); otherwise the month is returned as the year value:
Asterisk as year placeholder:

SELECT DISTINCT {fn YEAR('*-02-16')} AS Year_Given
FROM Sample.Person
Space character as year placeholder:

SELECT DISTINCT YEAR(' -02-16') AS Year_Given
FROM Sample.Person
The following example returns the current year:

SELECT DISTINCT YEAR(GETDATE()) AS Year_Now
FROM Sample.Person
The following embedded SQL example returns the current year from two functions.
The CURRENT_DATE function returns data type DATE; the NOW function returns data
type TIMESTAMP. YEAR returns a four-digit year integer for both input data
types:

  &sql(SELECT
    {fn YEAR(CURRENT_DATE)},
    {fn YEAR({fn NOW()})}
  INTO :a,:b
  FROM Sample.Person)
  IF SQLCODE'=0 {
    WRITE !,"Error code ",SQLCODE }
  ELSE {
    WRITE !,"CURRENT_DATE year is: ",a
    WRITE !,"NOW year is: ",b }
See Also

  • SQL functions: DATENAME DATEPART DAYOFYEAR QUARTER WEEK TO_DATE
  • Caché ObjectScript function: $ZDATE


 #}}}

==============================================================================
  vim:tw=78:fo=tcq2:ts=8:ft=help:norl:fdm=marker:fmr={{{,}}}:cms=\ #%s  

