*cache_functions.txt*	For Vim version 7.2.  Last change: 2009 Nov 11


                	  VIM REFERENCE MANUAL 
                               adopted by 
                     Andriy Diulin <diulin at gmail dot com>
		          Caché manual pages
			      Functions

For instructions on installing this file, type
	:help add-local-help
|add-local-help| inside Vim.

Abbreviations #{{{
|$ASCII|          *$A*         function 
|$CHAR|           *$C*         function 
|$DATA|           *$D*         function 
|$EXTRACT|        *$E*         function 
|$FIND|           *$F*         function 
|$FNUMBER|        *$FN*        function 
|$GET|            *$G*         function 
|$INCREMENT|      *$I*         function (with arguments) or $IO special variable (no arguments).
|$INUMBER|        *$IN*        function 
|$JUSTIFY|        *$J*         function (with arguments) or $JOB special variable (no arguments).
|$LENGTH|         *$L*         function 
|$LISTBUILD|      *$LB*        function 
|$LISTDATA|       *$LD*        function 
|$LISTFIND|       *$LF*        function 
|$LISTFROMSTRING| *$LFS*       function 
|$LISTGET|        *$LG*        function 
|$LIST|           *$LI*        function 
|$LISTLENGTH|     *$LL*        function 
|$LISTSAME|       *$LS*        function 
|$LISTTOSTRING|   *$LTS*       function 
|$LISTVALID|      *$LV*        function 
|$NEXT|           *$N*         function 
|$NAME|           *$NA*        function 
|$NCONVERT|       *$NC*        function 
|$NUMBER|         *$NUM*       function 
|$ORDER|          *$O*         function 
|$PIECE|          *$P*         function (with arguments) or $PRINCIPAL special variable (no arguments).
|$QUERY|          *$Q*         function (with arguments) or $QUIT special variable (no arguments).
|$QLENGTH|        *$QL*        function 
|$QSUBSCRIPT|     *$QS*        function 
|$RANDOM|         *$R*         function 
|$REVERSE|        *$RE*        function 
|$SELECT|         *$S*         function (with arguments) or $STORAGE special variable (no arguments).
|$SCONVERT|       *$SC*        function 
|$STACK|          *$ST*        function (with arguments) or $STACK special variable (no arguments).
|$TEXT|           *$T*         function (with arguments) or $TEST special variable (no arguments).
|$TRANSLATE|      *$TR*        function 
|$VIEW|           *$V*         function 
|$WASCII|         *$WA*        function 
|$WCHAR|          *$WC*        function 
|$WEXTRACT|       *$WE*        function 
|$WFIND|          *$WF*        function 
|$WLENGTH|        *$WL*        function 
|$WREVERSE|       *$WRE*       function 
|$ZBOOLEAN|       |$ZB|        function (with arguments) or $ZB special variable (no arguments, no abbreviation).
|$ZCYC|           *$ZC*        function (with argument) or $ZCHILD special variable (no arguments).
|$ZCONVERT|       *$ZCVT*      function 
|$ZDATE|
*$ZD*        function 
|$ZDATEH|         *$ZDH*       function 
|$ZDATETIME|      *$ZDT*       function 
|$ZDATETIMEH|     *$ZDTH*      function 
|$ZF|             |$ZF|        function s (no abbreviation). See also $ZF(-1), $ZF(-2), $ZF(-3), $ZF(-4), $ZF(-5), and $ZF(-6) function s.
|$ZHEX|           *$ZH*        function (with arguments) or $ZHOROLOG special variable (no arguments).
|$ZISWIDE|        *$ZIS*       function 
|$ZLASCII|        *$ZLA*       function 
|$ZLCHAR|         *$ZLC*       function 
|$ZPREVIOUS|      *$ZP*        function (with argument) or $ZPARENT special variable (no arguments).
|$ZSEARCH|        *$ZSE*       function 
|$ZTIME|          *$ZT*        function (with arguments) or $ZTRAP special variable (no arguments).
|$ZTIMEH|         *$ZTH*       function 
|$ZUTIL|          *$ZU*        function s
|$ZWASCII|        *$ZWA*       function 
|$ZWCHAR|         *$ZWC*       function 
#}}}

*$ASCII*  #{{{

Converts a character to a numeric code.
Synopsis

$ASCII(expression,position)
$A(expression,position)

Parameters

expression  The character to be converted.

position    Optional  The position of a character within a character string,
            counting from 1. The default is 1.

Description
$ASCII returns the character code value for a single character specified in 
expression. This character can be an 8-bit (extended ASCII) character or a
16-bit (Unicode) character. The returned value is a positive integer.
The expression parameter may evaluate to a single character or to a string of
characters. If expression evaluates to a string of characters, you can include
the optional position parameter to indicate which character you want to
convert.
Parameters
expression
An expression that evaluates to a quoted string of one or more characters. The
expression can be specified as the name of a variable, a numeric value, a
string literal, or any valid Caché ObjectScript expression. If expression
yields a string of more than one character, use position to select the desired
character. If you omit position for a character string, $ASCII returns the
numeric code for the first character. $ASCII returns -1 if the expression
evaluates to a null string.
position
The position must be specified as a nonzero positive integer. It may be signed
or unsigned. You can use a noninteger numeric value in position; however, Caché
ignores the fractional portion and only considers the integer portion of the
numeric value. If you do not include position, $ASCII returns the numeric value
of the first character in expression. $ASCII returns -1 if the integer value of
position is larger than the number of characters in expression or less than 1.
Examples
The following example returns 87, the ASCII numeric value of the character W.

   WRITE $ASCII("W")
The following example returns 960, the numeric equivalent for the Unicode
character "pi".

   WRITE $ASCII($CHAR(959+1))
The following example returns 84, the ASCII numeric equivalent for the first
character in the variable Z.

  SET Z="TEST"
  WRITE $ASCII(Z)
The following example returns 83, the ASCII numeric equivalent for the third
character in the variable Z.

   SET Z="TEST"
   WRITE $ASCII(Z,3)
The following example returns a -1 because the second argument specifies a
position greater than the number of characters in the string.

   SET Z="TEST"
   WRITE $ASCII(Z,5)
The following example uses $ASCII in a FOR loop to convert all of the
characters in variable x to their ASCII numeric equivalents. The $ASCII
reference includes the position parameter, which is updated for each execution
of the loop. When position reaches a number that is greater than the number of
characters in x, $ASCII returns a value of -1, which terminates the loop.

  SET x="abcdefghijklmnopqrstuvwxyz"
  FOR i=1:1 {
    QUIT:$ASCII(x,i)=-1
    WRITE !,$ASCII(x,i)
    }
  QUIT
The following example generates a simple checksum for the string X. When $CHAR
(CS) is concatenated with the string, the checksum of the new string is always
zero. Therefore, validation is simplified.

CXSUM
  SET x="Now is the time for all good men to come to the aid of their party"
  SET CS=0
  FOR i=1:1:$LENGTH(x) {
    SET CS=CS+$ASCII(x,i)
    WRITE !,"Checksum is:",CS
    }
  SET CS=128-CS#128
  WRITE !,"Final checksum is:",CS
The following example converts a lowercase or mixed-case alphabetic string to
all uppercase.

ST
  SET String="ThIs Is a MiXeDCAse stRiNg"
  WRITE !,"Input: ",String
  SET Len=$LENGTH(String),Nstring=" "
  FOR i=1:1:Len { DO CNVT }
  QUIT
CNVT
  SET Char=$EXTRACT(String,i),Asc=$ASCII(Char)
  IF Asc>96,Asc<123 {
    SET Char=$CHAR(Asc-32)
    SET Nstring=Nstring_Char
    }
  ELSE {
    SET Nstring=Nstring_Char
    }
  WRITE !,"Output: ",Nstring
  QUIT
Notes
Unicode Support
The $ASCII function supports both 8-bit and 16-bit characters. For 8-bit
characters, it returns the numeric values 0 through 255. For 16-bit (Unicode)
characters it returns numeric codes up to 65535.
The Unicode value for a character is usually expressed as a 4-digit number in
hexadecimal notation, using the digits 0-9 and the letters A-F (for 10 through
15, respectively). However, standard functions in the Caché ObjectScript
language generally identify characters according to ASCII numeric codes, which
are base-10 decimal values, not hexadecimal.
Hence, the $ASCII function supports Unicode encoding by returning the decimal
Unicode value of the inputted character, instead of the hexadecimal value that
the Unicode standard recommends. This way, the function remains backward
compatible, while also supporting Unicode. To convert a decimal number to
hexadecimal, use the $ZHEX function.
Surrogate Pairs
$ASCII does not recognize surrogate pairs. A surrogate pair is a pair of 16-bit
Unicode characters that together encode a single ideographic character.
Surrogate pairs are used to represent some Chinese characters and to support
the Japanese JIS2004 standard. You can use the $WISWIDE function to determine
if a string contains a surrogate pair. The $WASCII function recognizes and
correctly parses surrogate pairs. $ASCII and $WASCII are otherwise identical.
However, because $ASCII is generally faster than $WASCII, $ASCII is preferable
for all cases where a surrogate pair is not likely to be encountered.
Note:
$WASCII should not be confused with $ZWASCII, which always parses characters in
pairs.
Related Functions
The $CHAR function is the inverse of $ASCII. You can use it to convert an
integer code to a character.
$ASCII converts a single character to an integer. To convert a 16-bit (wide)
character string to an integer use $ZWASCII. To convert a 32-bit (long)
character string to an integer use $ZLASCII. To convert a 64-bit (quad)
character string to an integer use $ZQASCII. To convert a 64-bit character
string to an IEEE floating-point number ($DOUBLE data type) use $ZDASCII.
See Also

  • READ command
  • WRITE command
  • $CHAR function
  • $WASCII function
  • $WISWIDE function
  • $ZLASCII function
  • $ZWASCII function
  • $ZQASCII function
  • $ZDASCII function


 #}}}
*$BITCOUNT*  #{{{

Returns the number of bits in a bitstring.
Synopsis

$BITCOUNT(bitstring,bitvalue)

Parameters

bitstring  The name of a bitstring. Can be a local variable, a process-private
           global, or a global.

bitvalue   Optional  The value (0 or 1) to count within the bitstring.

Description
The $BITCOUNT function counts the number of bits within a bitstring. A
bitstring is a string which is interpreted by the system as a series of bits.
You can create a bitstring using $BIT or $BITLOGIC. There is also general
information on bitstring functions available.
$BITCOUNT(bitstring) returns the number of bits in bitstring.
$BITCOUNT(bitstring, bitvalue) returns the number of bits of type bitvalue (0
or 1) in bitstring.
The maximum bitstring length is 262,104 bits (32763 x 8).
Examples
If bitstring= [0,0,1,1,0], then the result of $BITCOUNT(bitstring) is 5:

  SET $BIT(a,1) = 0
  SET $BIT(a,2) = 0
  SET $BIT(a,3) = 1
  SET $BIT(a,4) = 1
  SET $BIT(a,5) = 0
  WRITE !,$BITCOUNT(a)
If bitstring = [0,0,1,1,0], then the result of $BITCOUNT(bitstring,0) would be
3.

  SET $BIT(a,1) = 0
  SET $BIT(a,2) = 0
  SET $BIT(a,3) = 1
  SET $BIT(a,4) = 1
  SET $BIT(a,5) = 0
  WRITE !,"number of zero bits:",$BITCOUNT(a,0)
  WRITE !,"number of one bits: ",$BITCOUNT(a,1)
See Also

  • $BIT function
  • $BITFIND function
  • $BITLOGIC function
  • $FACTOR function
  • $ZBOOLEAN function


 #}}}
*$BITFIND*  #{{{

Returns the position of the specified bit value within a bitstring.
Synopsis

$BITFIND(bitstring,bitvalue,position,direction)

Parameters

bitstring  The name of a bitstring. Can be a local variable, a process-private
           global, or a global.

bitvalue   The value (0 or 1) to search for within the bitstring.

position   Optional  The bit position from which the search begins. Search is
           inclusive of this position.

           Optional  A direction flag. Available values are 1 and -1. 1 =
           Search forward (left to right) from the beginning of the bitstring
direction  (or from position) towards the end (this is the default). -1 =
           Search backward from the end of the bitstring (or from position)
           towards the beginning.

Description
$BITFIND(bitstring,bitvalue) returns the position of the first occurrence of
the specified bitvalue (0 or 1) within the bitstring bitstring.
$BITFIND(bitstring,bitvalue,position) returns the position of the first
occurrence at or after position of the specified bitvalue in bitstring.
If the desired bit value is not found, or if position is greater than the
number of bits within the bitstring, the return value is 0.
There is also general information on bitstring functions available.
Examples
If bitstring = [0,0,1,1,0], then the result of $BITFIND(bitstring,1) would be
3.

  // Set a to [0,0,1,1,0]
  SET $BIT(a,1) = 0
  SET $BIT(a,2) = 0
  SET $BIT(a,3) = 1
  SET $BIT(a,4) = 1
  SET $BIT(a,5) = 0
  // Find first 1 bit within a
  WRITE !,$BITFIND(a,1)
If bitstring = [0,0,1,1,0], when searching from position 3, the first 1 bit is
bit-3 (because search is inclusive of the position bit) and the first 0 bit is
bit-5.

  // Set a to [0,0,1,1,0]
  SET $BIT(a,1) = 0
  SET $BIT(a,2) = 0
  SET $BIT(a,3) = 1
  SET $BIT(a,4) = 1
  SET $BIT(a,5) = 0
  // Find first 1 bit from position 3
  WRITE !,"found 1 bit at position:",$BITFIND(a,1,3)
  // Find first 0 bit from position 3
  WRITE !,"found 0 bit at position:",$BITFIND(a,0,3)
See Also

  • $BIT function
  • $BITCOUNT function
  • $BITLOGIC function
  • $FACTOR function
  • $ZBOOLEAN function


 #}}}
*$BIT*  #{{{

Returns and or sets the bit value of a specified position in a bitstring.
Synopsis

$BIT(bitstring,position)
SET $BIT(bitstring,position) = value

Parameters

bitstring  The name of a bitstring. Can be a local variable, a process-private
           global, or a global.

position   The bit position of the returned value.

Description
There are several forms of the $BIT function. For general information on $BIT
and other bitstring functions, see below.
$BIT(bitstring,position) returns the bit value (0 or 1) at the specified
position, position, in the given bitstring expression bitstring. If bitstring
is a null string or if position is less than 1 or greater than the length of
the bitstring, the function returns 0.
SET $BIT(bitstring,position) = value performs an atomic bit set on the
bitstring specified by bitstring. If value is true, then the bit at position 
position is set. If value is false, the bit is cleared. If the bitstring is
shorter than the specified position, it is padded with 0 bits to the specified
position. The bitstring parameter does not support .. property syntax.
Example
If bitstring=[0,0,1,1], then the result of $BIT(bitstring,2) would be 0.

  // Set a to [0,0,1,1]
  SET $BIT(a,1) = 0
  SET $BIT(a,2) = 0
  SET $BIT(a,3) = 1
  SET $BIT(a,4) = 1
  // Test bit 2 within a
  WRITE !,$BIT(a,2)
  // Write the bitstring
  WRITE !,$BIT(a,1),$BIT(a,2),$BIT(a,3),$BIT(a,4)
General Information on Bitstring Functions
Bitstring functions manipulate encoded bit-based data. Although a bitstring can
be used with any Caché ObjectScript command or function, it is generally
meaningful only within the context of the bit functions.
The $BIT bitstring functions perform atomic operations. Therefore, no locking
is required when performing bitstring operations.
The $BIT bitstring functions perform internal compression of bitstrings.
Therefore, the actual data length of a bitstring and its physical space
allocation may differ. $BIT bitstring functions use the data length of
bitstrings. In most circumstances, the physical space allocation should be
invisible to the user. bitstring compression is invisible to users of the $BIT
functions.
However, because this compressed binary representation is optimized for each
bitstring, one cannot assume that two "identical" bitstrings (which were
created differently) have identical internal representations. Caché selects
from four separate bitstring internal representations to optimize for both
sparse bitstrings and non-sparse bitstrings. Therefore, while matching
operations on individual bits yield predictable results, comparisons of entire
bitstrings may not.
$BIT bitstring functions support a maximum bitstring length of 262,104 bits
(32763 x 8) for Caché. (Unlike with certain InterSystems legacy products, it is
not an error in Caché to perform an operation on a bit that is beyond the
bitstring length.)
Bits in a bitstring are numbered with the first (leftmost) bit as position 1.
All bitstring comparisons are performed left-to-right.
In the examples, bitstrings are shown within matching square brackets ([...]),
with the bits delimited by commas. For example, a bitstring of four 1 bits is
shown as [1,1,1,1], with the least significant bits to the right.
In all the bitstring functions, variables named bitstring are bitstrings that
can be specified as values, variables, or expressions.
Note:
The $BIT functions replace the earlier $ZBIT functions. New code should only
use the $BIT functions; the $ZBIT functions will continue to be supported for
legacy applications. The $BIT functions and the $ZBIT functions are
incompatible; $BIT functions compress bitstrings, $ZBIT functions do not.
Therefore, the two types of bitstring functions should not be used on the same
bitstring. Attempting to do so results in an <INVALID BIT STRING> error.
See Also

  • $BITCOUNT function
  • $BITFIND function
  • $BITLOGIC function
  • $FACTOR function
  • $ZBOOLEAN function


 #}}}
*$BITLOGIC*  #{{{

Performs bit-wise operations on bitstrings.
Synopsis

$BITLOGIC(bitstring_expression,length)

Parameters

                      A bitstring expression consisting of one or more
                      bitstrings and the logical operators &, |, and ~. A
                      bitstring can be specified as a local variable, a
bitstring_expression  process-private global, a global, or the constant "". The
                      null string ("") has a bitstring length of 0. The 
                      bitstring_expression parameter does not support ..
                      property syntax.

                      Optional  The length, in bits, of the resulting
length                bitstring. If length is not specified it defaults to the
                      length of the longest bitstring in bitstring_expression.

Description
$BITLOGIC evaluates a bit-wise operation on one or more bitstring values, as
specified by bitstring_expression, and returns the resulting bitstring.
A bitstring is an encoded (compressed) string which is interpreted as a series
of bits. Only bitstrings created using $BIT, $FACTOR, or $BITLOGIC, or the null
string (""), should be supplied to the $BITLOGIC function. Typically,
bitstrings are used for index operations. Refer to general information on
bitstring functions in $BIT for further details.
$BITLOGIC is incompatible with any of the legacy $ZBIT bitstring functions, and
should not be used in combination with them.
Bitstring Optimization
The most basic $BITLOGIC operation is $BITLOGIC(a). Seemingly, this operation
does not do anything: bitstring a is input and the same bitstring a is output.
However, $BITLOGIC performs bitstring compression which it optimizes by
selecting from several compression algorithms. Therefore, if bitstring a has
undergone substantial changes since its creation, passing it through $BITLOGIC
can result in re-optimization of the bitstring. Refer to $BIT for further
details.
For example, following a large number of delete operations an index bitstring
may have become a sparse bitstring, consisting wholly or mainly of zeros.
Passing this index bitstring through $BITLOGIC may result in substantial
performance improvements.
Bitstring Logical Operators
$BITLOGIC can evaluate only the bitstring operators listed in the following
table:

Operator         Meaning

&         AND

|         OR

^         XOR (exclusive OR)

~         NOT (one’s complement)

The bitstring_expression can contain a single bitstring (~A), two bitstrings (A
&B), or more than two bitstrings (A&B|C), up to the current maximum of 31
bitstrings. Evaluation is performed left-to-right. Logical operations may be
grouped by parentheses within the bitstring_expression, following standard
Caché ObjectScript order of operations. If a variable used within $BITLOGIC is
undefined, it is treated as a null string ("").
$BITLOGIC treats a null string as a bitstring of indefinite length, in which
all bits are set to 0’s.
Note:
When $BITLOGIC is supplied more than two bitstring operands, it must create
bitstring temporaries to hold the intermediate results. Under some extreme
circumstances (many bitstrings and/or extremely large bitstrings), it can
exhaust the space allocated to hold such temporaries. Bitstring pair operations
do not have this limitation, and are thus preferable for large bitstring
operations.
The NOT (~) operator can be used as a unary operator (for example, ~A), or can
be used in combination with other operators (for example, A&~B). It performs
the one’s complement operation on a string, turning all 1’s to 0’s and all 0’s
to 1’s. Multiple NOT operators can be used (for example, ~~~A).
The length Argument
If length is not specified, it defaults to the length of the longest bitstring
in bitstring_expression.
If length is specified, it specifies the logical length of the resulting
bitstring.

  • If length is larger than one or more of the bitstrings in 
    bitstring_expression, those bitstrings are zero-filled to that length
    before bitstring logic operations are performed.
  • If length is smaller than one or more of the bitstrings in 
    bitstring_expression, those bitstrings are truncated to that length before
    bitstring logic operations are performed.
  • If length is 0, a bitstring of length 0 (a null string) is returned.

Examples
The following example creates some simple bitstrings and demonstrates the use
of $BITLOGIC on them:

   // Set a to [1,1]
   SET $BIT(a,1) = 1
   SET $BIT(a,2) = 1
   // Set b to [0,1]
   SET $BIT(b,1) = 0
   SET $BIT(b,2) = 1
   WRITE !,"bitstring a=",$BIT(a,1),$BIT(a,2)
   WRITE !,"bitstring b=",$BIT(b,1),$BIT(b,2)
   SET c = $BITLOGIC(~b)
   WRITE !,"The one's complement of b=",$BIT(c,1),$BIT(c,2)
   // Find the intersection (AND) of a and b
   SET c = $BITLOGIC(a&b)   // c should be [0,1]
   WRITE !,"The AND of a and b=",$BIT(c,1),$BIT(c,2)
   SET c = $BITLOGIC(a&~b)   // c should be [1,0]
   WRITE !,"The AND of a and ~b=",$BIT(c,1),$BIT(c,2)
   // Find the union (OR) of a and b
   SET c = $BITLOGIC(a|b)   // c should be [1,1]
   WRITE !,"The OR of a and b=",$BIT(c,1),$BIT(c,2)
   SET c = $BITLOGIC(a^b)   // c should be [1,0]
   WRITE !,"The XOR of a and b=",$BIT(c,1),$BIT(c,2)
   QUIT
The following example shows the results of specifying a length greater than the
input bitstring. The string is zero-filled before the logic operation is
performed.

   // Set a to [1,1]
   SET $BIT(a,1) = 1
   SET $BIT(a,2) = 1
   WRITE !,"bitstring a=",$BIT(a,1),$BIT(a,2)
   SET c = $BITLOGIC(~a,7)
   WRITE !,"~a (length 7)="
   WRITE $BIT(c,1),$BIT(c,2),$BIT(c,3),$BIT(c,4)
   WRITE $BIT(c,5),$BIT(c,6),$BIT(c,7),$BIT(c,8)
Here the one’s complement (~) of 11 is 0011111. Bits 3 through 7 were set to
zero before the ~ operation was performed. This example also displays an eighth
bit, which is beyond the specified string length and thus unaffected by the 
$BITLOGIC operation. It is, of course, displayed as 0.
The following example shows the results of specifying a length less than the
input bitstring. The bitstring is truncated to the specified length before
logical operations are performed. All bits beyond the specified length default
to 0.

   // Set a to [1,1,1]
   SET $BIT(a,1) = 1
   SET $BIT(a,2) = 1
   SET $BIT(a,3) = 1
   WRITE !,"bitstring a=",$BIT(a,1),$BIT(a,2),$BIT(a,3)
   SET c = $BITLOGIC(a,2)
   WRITE !," a (length 2)="
   WRITE $BIT(c,1),$BIT(c,2),$BIT(c,3),$BIT(c,4)
   SET c = $BITLOGIC(~a,2)
   WRITE !,"~a (length 2)="
   WRITE $BIT(c,1),$BIT(c,2),$BIT(c,3),$BIT(c,4)
The following example shows that when length is not specified, it defaults to
the length of the longest bitstring. Shorter bitstrings are zero-filled before
the logical operation is performed.

   // Set a to [1,1,1]
   SET $BIT(a,1) = 1
   SET $BIT(a,2) = 1
   SET $BIT(a,3) = 1
   // Set b to [1,1]
   SET $BIT(b,1) = 1
   SET $BIT(b,2) = 1
   SET c = $BITLOGIC(a&~b)
   WRITE !,"  a&~b="
   WRITE $BIT(c,1),$BIT(c,2),$BIT(c,3)
   SET c = $BITLOGIC(a&~b,3)
   WRITE !,"a&~b,3="
   WRITE $BIT(c,1),$BIT(c,2),$BIT(c,3)
Here the two $BITLOGIC operations (with and without a length argument) both
return the same value: 001.
See Also

  • $BIT function
  • $BITCOUNT function
  • $BITFIND function
  • $FACTOR function
  • $ZBOOLEAN function
  • Operators in Using Caché ObjectScript


 #}}}
*$CASE*  #{{{

Compares expressions and returns the value of the first matching case.
Synopsis

$CASE(target,case:value,case:value,...,:default)

Parameters

target   A literal or expression the value of which is to be matched against
         cases.

case     A literal or expression the value of which is to be matched with the
         results of the evaluation of target.

value    The value to be returned upon a successful match of the corresponding 
         case.

default  Optional  The value to be returned if no case matches target.

Description
The $CASE function compares target to a list of cases (literals or
expressions), and returns the value of the first matching case. An unlimited
number of case:value pairs can be specified. Cases are matched in the order
specified (left-to-right); matching stops when the first exact match is
encountered.
If there is no matching case, default is returned. If there is no matching case
and no default is specified, Caché issues an <ILLEGAL VALUE> error.
Caché permits specifying $CASE with no case:value pairs. It always returns the 
default value, regardless of the target value.
Parameters
target
$CASE evaluates this expression once, then matches the result to each case in
left-to-right order.
case
A case can be a literal or an expression; matching of literals is substantially
more efficient than matching expressions, because literals can be evaluated at
compile time. Each case must be paired with a value. An unlimited number of 
case and value pairs may be specified.
value
A value can be a literal or an expression. Using $CASE as an argument of a GOTO
command or a DO command restricts value as follows:

  • When using a $CASE statement with a GOTO command, each value must be a
    valid tag. It cannot be an expression.
  • When using a $CASE statement with a DO command, each value must be a valid 
    DO argument. These DO arguments can include parameters.

default
The default is specified like a case:value pair, except that there is no case
specified between the comma (used to separate pairs) and the colon (used to
pair items). The default is optional. If specified, it is always the final
parameter in a $CASE function. The default value follows the same GOTO and DO
restrictions as the value parameter.
If there is no matching case and no default is specified, Caché issues an
<ILLEGAL VALUE> error.
Example
The following example takes a number and returns corresponding name for a day
of the week. Note that a default value  entry error is provided:

  SET daynum=3
  WRITE $CASE(daynum,
              1:"Sunday",2:"Monday",
              3:"Tuesday",4:"Wednesday",
              5:"Thursday",6:"Friday",
              7:"Saturday",:"entry error")
The following example takes a numeric input and writes out the appropriate
explanatory string:

  READ "Input a number 1-3: ",x
  SET multi=$CASE(x,1:"single",2:"double",3:"triple",:"input error")
  WRITE multi

The following example tests whether the character input is a letter or some
other character:

  READ "Input a letter: ",x
  SET chartype=$CASE(x?1A,1:"letter",:"other")
  WRITE chartype

The following example specifies no case:value pairs. It return the default
string  not defined :

  SET dummy=3
  WRITE $CASE(dummy,:"not defined")
See Also

  • DO command
  • GOTO command
  • IF command
  • $SELECT function


 #}}}
*$CHANGE*  #{{{

Performs MultiValue substring replacement.
Synopsis

$CHANGE(string,subout,subin,occurrences,begin)

Parameters

             The string in which substring substitutions are made. Any
string       expression that resolves to a valid variable. string may be a
             dynamic array.

subout       The substring to be replaced. Any expression that resolves to a
             valid string or numeric.

subin        The substring to be inserted in place of subout. Any expression
             that resolves to a valid string or numeric.

             Optional  A positive integer specifying the number of occurrences
             of subout to replace with subin. If omitted, all occurrences are
occurrences  replaced. If used with begin, you can specify an occurrences value
             of -1 indicating that all occurrences of subout from the begin
             point to the end of the string are to be replaced.

             Optional  An integer specifying which occurrence of subout to
begin        begin replacement with. If omitted, or specified as 0 or 1,
             replacement begins with the first occurrence of subout.

Description
The $CHANGE function invokes the Caché MVBasic CHANGE function, and returns the
resulting value to the Caché ObjectScript environment. Specify parameter values
in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.

 #}}}
*$CHAR*  #{{{

Converts the integer value of an expression to the corresponding ASCII or
Unicode character.
Synopsis

$CHAR(expression,...)
$C(expression,...)

Parameter

expression  The integer value to be converted.

Description
$CHAR returns the character that corresponds to the decimal (base-10) integer
value specified by expression. This character can be an 8-bit (ASCII)
character, or a 16-bit (Unicode) character. For 8-bit characters, the value in 
expression must evaluate to a positive integer in the range 0 to 255. For
16-bit characters, specify integers in the range 256 through 65535 (hex FFFF).
Values larger than 65535 return an empty string. Values from 65536 (hex 10000)
through 1114111 (hex 10FFFF) are used to represent Unicode surrogate pairs;
these characters can be returned using $WCHAR.
You can specify expression as a comma-separated list, in which case $CHAR
returns the corresponding character for each expression in the list.
Parameter
expression
The expression can be an integer value, the name of a variable that contains an
integer value, or any valid Caché ObjectScript expression that evaluates to an
integer value. To return characters for multiple integer values, specify a
comma-separated list of expressions.
Examples
The following example uses $CHAR in a FOR loop to output the characters for all
ASCII codes in the range 65 to 90. These are the uppercase alphabetic
characters.

  FOR i=65:1:90 {
     WRITE !,$CHAR(i) }
The following two examples show the use of multiple expression values. The
first returns  AB and the second returns  AaBbCcDdEeFfGgHhIiJjKk :

  WRITE $CHAR(65,66),!
  FOR i=65:1:75 {
     WRITE $CHAR(i,i+32) }
The following example shows the use of a multibyte character. The character
corresponding to the integer 960 is the symbol for pi:

  WRITE $CHAR(960)
Notes
$CHAR with the WRITE Command
When you use $CHAR to write characters with the WRITE command, the output
characters reset the positions of the special variables $X and $Y. This is true
even for the NULL character (ASCII 0), which is not the same as a null string
(""). As a rule, you should use $CHAR with caution when writing nonprinting
characters, because such characters may produce unpredictable cursor
positioning and screen behavior.
Numeric Values in $CHAR Arguments
You can use signed numeric values for expression. Caché ignores negative
numbers and only evaluates positive or unsigned numbers. In the following
example, the $CHAR with signed integers returns only the first and third
expression, ignoring the second expression, which is a negative integer.

  WRITE !,$CHAR(65,66,67)
  WRITE !,$CHAR(+65,-66,67)
ABC
AC
You can use floating point numeric values for expression. Caché ignores the
fractional portion of the argument and only considers the integer portion. In
the following example, $CHAR ignores the fractional portion of the number and
produces the character represented by character code 65, an uppercase A.

   WRITE $CHAR(65.5)
Unicode Support
$CHAR supports Unicode characters when represented by decimal (base-10)
integers.
The Unicode value for a character is usually expressed as a 4-digit number in
hexadecimal notation, using the digits 0-9 and the letters A-F. However,
standard functions in the Caché ObjectScript language generally identify
characters according to ASCII codes, which are decimal values, not hexadecimal.
Hence, the $CHAR function supports Unicode encoding by returning a character
based on the decimal Unicode value that was input, not the more standard
hexadecimal value. To convert a decimal number to hexadecimal, use the $ZHEX
function.
Surrogate Pairs
$CHAR does not recognize surrogate pairs. A surrogate pair is a pair of 16-bit
Unicode characters that together encode a single ideographic character.
Surrogate pairs are used to represent some Chinese characters and to support
the Japanese JIS2004 standard. You can use the $WISWIDE function to determine
if a string contains a surrogate pair. The $WCHAR function recognizes and
correctly parses surrogate pairs. $CHAR and $WCHAR are otherwise identical.
However, because $CHAR is generally faster than $WCHAR, $CHAR is preferable for
all cases where a surrogate pair is not likely to be encountered.
Note:
$WCHAR should not be confused with $ZWCHAR, which always parses characters in
pairs.
Functions Related to $CHAR
The $ASCII function is the inverse of $CHAR. You can use it to convert a
character to its equivalent numeric value. $ASCII converts all characters,
including Unicode characters. In addition, all Caché platforms support the
related functions, $ZLCHAR and $ZWCHAR. They are similar to $CHAR, but operate
on a word (two bytes) or a long word (four bytes). You can use $ZISWIDE to
determine if there are any multibyte ( wide ) characters in the expression of 
$CHAR.
See Also

  • READ command
  • WRITE command
  • $ASCII function
  • $WCHAR function
  • $WISWIDE function
  • $ZHEX function
  • $ZLCHAR function
  • $ZWCHAR function
  • $X special variable
  • $Y special variable


 #}}}
*$DATA*  #{{{

Checks if a variable contains data.
Synopsis

$DATA(variable,target)
$D(variable,target)

Parameters

          The variable whose status is to be checked. A local or global
variable  variable, subscripted or unsubscripted. The variable may be
          undefined. variable may be specified as a multidimensional object
          property with the syntax obj.property.

target    Optional  A variable into which $DATA returns the current value of 
          variable.

Description
You can use $DATA to test whether a variable contains data before attempting an
operation on it. $DATA returns status information about the specified variable.
The variable parameter can be the name of any variable (local variable,
process-private global, or global) or object property, and can include a
subscripted array element.
The possible status values that may be returned are as follows:

Status                                  Meaning
Value

0       The variable is undefined. Any reference would cause an <UNDEFINED>
        error.

1       The variable exists and contains data, but has no descendants. Note
        that the null string ("") qualifies as data.

        The variable identifies an array element that has descendants (contains
        a downward pointer to another array element) but does not contain data.
10      Any direct reference to such a variable will result in an <UNDEFINED>
        error. For example, if $DATA(y) returns 10, set x=y will produce an
        <UNDEFINED> error.

        The variable identifies an array element that has descendants (contains
11      a downward pointer to another array element) and contains data.
        Variables of this type can be referenced in expressions.

Note:
Status values 1 and 11 indicate only the presence of data, not the type of
data.
For more information on <UNDEFINED> errors, refer to the $ZERROR special
variable.
Parameters
variable
The variable can be a local variable, a process-private global, or a global. It
can be a multidimensional object property. It can be a subscripted array
element within a variable or property. If a global variable, it can include an
extended global reference. If a subscripted global variable, it can be a naked
global reference.
target
An optional parameter. Specify the name of a local variable, a process-private
global, or a global. This target variable does not need to be defined. If 
target is specified, $DATA writes the current data value of variable into 
target. If variable is undefined, the target value remains unchanged.
Examples
This example writes a selected range of records from the ^client array, a
sparse array consisting of three levels. The first level contains the client’s
name, the second the client’s address, and the third the client’s accounts,
account numbers, and balances. A client can have up to four separate accounts.
Because ^client is a sparse array there may be undefined elements at any of the
three levels. The contents for a typical record might appear as follows:

^client(5) John Jones
^client(5,1) 23 Bay Rd./Boston/MA 02049
^client(5,1,1) Checking/45673/1248.00
^client(5,1,2) Savings/27564/3270.00
^client(5,1,3) Reserve Credit/32456/125.00
^client(5,1,4) Loan/81263/460.00

The code below provides a separate subroutine to handle the output for each of
the three array levels. It uses the $DATA function at the start of each
subroutine to test the current array element.
The $DATA=0 test in Level1, Level2, and Level3 tests whether the current array
element is undefined. If TRUE, it causes the code to QUIT and revert to the
previous level.
The $DATA=10 test in Level1 and Level2 tests whether the current array element
contains a pointer to a subordinate element, but no data. If TRUE, it causes
the code to write out a  No Data message. The code then skips to the FOR loop
processing for the next lower level. There is no $DATA=10 test in Level3
because there are no elements subordinate to this level.
The WRITE commands in Level2 and Level3 use the $PIECE function to extract the
appropriate information from the current array element.

Start  Read !,"Output how many records: ",n
  Read !,"Start with record number: ",s
  For i=s:1:s+(n1) {
    If $Data(^client(i)) {
      If $Data(^client(i))=10 {
        Write !," Name: No Data"
      }
      Else {
        Write !," Name: " ,^client(i)
      }
      If $Data(^client(i,1)) {
        If $Data(^client(i,1))=10 {
                            Write !,"Address: No Data"
        }
        Else {
            Write !,"Address: ",$Piece(^client(i,1),"/",1)
            Write " , ",$Piece(^client(i,1),"/",2)
          Write " , ",$Piece(^client(i,1),"/",3)
        }
      }
      For j=1:1:4 {
        If $Data(^client(i,1,j)) {
             Write !,"Account: ",$Piece(^client(i,1,j),"/",1)
          Write " #: ",$Piece(^client(i,1,j),"/",2)
          Write " Balance: ",$Piece(^client(i,1,j),"/",3)
        }
      }
    }
  }
  Write !,"Finished."
  Quit

When executed, this code might produce output similar to the following:

Output how many records: 3
Start with record number: 10
Name: Jane Smith
Address: 74 Hilltop Dr., Beverly, MA 01965
Account: Checking #: 34218 Balance: 876.72
Account: Reserve Credit #: 47821 Balance: 1200.00
Name: Thomas Brown
Address: 46 Huron Ave., Medford, MA 02019
Account: Checking #: 59363 Balance: 205.45
Account: Savings #: 41792 Balance: 1560.80
Account: Reserve Credit #: 64218 Balance: 125.52
Name: Sarah Copley
Address: No Data
Account: Checking #: 30021 Balance: 762.28

In the following example, a multidimensional property is used as the variable
value. This example returns the names of all defined namespaces to the target
parameter:

  SET obj = ##class(%ResultSet).%New("%SYS.Namespace:List")
  DO obj.Execute()
  WRITE $DATA(obj.Data,targ),!                // returns 0
  SET targ="blank"
  WHILE targ'="" {
     DO obj.Next()
     WRITE $DATA(obj.Data,targ)               // returns 10
     WRITE " ",$DATA(obj.Data("Nsp"),targ),!  // returns 1
     IF targ'="" {
     WRITE "Namespace: ",targ,! }
     }
   WRITE !,"Done!"
A similar program returns the same information using the $GET function.
Notes
Naked Global References
$DATA sets the naked indicator when used with a global variable. The naked
indicator is set even if the specified global variable in not defined (Status
Value = 0).
Subsequent references to the same global variable can use a naked global
reference, as shown in the following example:

   IF $DATA(^A(1,2,3))#2 {
     SET x=^(3)  }

For further details on using $DATA with global variables and naked global
references, see Using Multidimensional Storage (Globals) in Using Caché Globals
.
Global References in a Networked Environment
Using $DATA to repeatedly reference a global variable that is not defined (for
example, $DATA(^x(1)) where ^x is not defined) always requires a network
operation to test if the global is defined on the ECP server.
Using $DATA to repeatedly reference undefined nodes within a defined global
variable (for example, $DATA(^x(1)) where any other node in ^x is defined) does
not require a network operation once the relevant portion of the global (^x) is
in the client cache.
For further details, refer to Developing Distributed Applications in the 
Caché Distributed Data Management Guide.
Functions Related to $DATA
For related information, see $GET and $ORDER. Since $ORDER selects the next
element in an array that contains data, it avoids the need to perform $DATA
tests when looping through array subscripts.
See Also

  • KILL command
  • SET command
  • $GET function
  • $ORDER function
  • $ZUTIL(18) Undefined Variable Behavior function
  • Using Multidimensional Storage (Globals) in Using Caché Globals


 #}}}
*$DECIMAL*  #{{{

Returns a number converted to a Caché floating point value.
Synopsis

$DECIMAL(num,digits)

Parameters

num     The numeric value to be converted. Commonly this is an IEEE floating
        point number.

        Optional  An integer that specifies the number of significant digits to
        return. $DECIMAL rounds the return value to that number of digits,
        using the IEEE floating point rounding algorithm. Valid values are 1
digits  through 38, and 0. If digits is greater than the number of digits the
        value is returned unchanged. If digits is 0, no rounding is performed
        on num unless it has more than 20 significant digits (see below for
        details on 0 value).

Description
$DECIMAL returns a floating point number converted to the Caché floating point
data type. This function is used to convert a fractional number in IEEE
double-precision format to the corresponding fractional number in Caché format.
This is the inverse of the operation performed by the $DOUBLE function.
The Caché SQL data types DOUBLE and DOUBLE PRECISION represent IEEE floating
point numbers; the FLOAT data type represents standard Caché fractional
numbers.
IEEE floating point numbers are represented internally using 53 binary bits.
Because most fractional decimal numbers have no exact binary representation, a
fractional number in $DOUBLE format will usually differ slightly from its 
$DECIMAL conversion. Standard Caché fractional numbers have a precision of 18
decimal digits on all supported Caché system platforms. When an IEEE floating
point number is displayed as a fractional number the binary bits are often
converted to a fractional number with far more than 18 decimal digits. This 
does not mean that IEEE floating point numbers are more precise than standard
Caché fractional numbers.
The num value can be specified as a number or a numeric string. It is resolved
to canonical form (leading and trailing zeros removed, multiple plus and minus
signs resolved, etc.) before $DECIMAL conversion. Specifying a non-numeric
string to num returns 0. Specifying a mixed-numeric string (for example
"7dwarves" or "7.5.4") to num truncates the input value at the first
non-numeric character then converts the numeric portion.
Default rounding is done as follows:

  • Fractional Numbers: If digits is not specified and num has more than 19
    significant digits, $DECIMAL rounds the fractional portion so that the
    resulting number is 19 digits (or fewer, if the rounding results in
    trailing zeros). $DECIMAL always rounds to the nearest fractional value
    with the greater absolute value.
  • Very Large Integer Numbers: If digits is not specified and num has more
    than 19 significant integer digits to the left of the decimal point, 
    $DECIMAL rounds so that the resulting integer has 19 significant digits,
    with the remaining integer digits represented by zeros.
  • Very Small Fractional Numbers less than 1: If digits is not specified and 
    num is a fractional number with more than 19 zeroes to the right of the
    decimal point before the significant value, $DECIMAL preserves the zeros
    and then rounds so that the significant portion of the fraction is rounded
    to 19 significant digits.
  • Integers with Very Small Fractional Numbers: If digits is not specified and
    num is a number contains a non-zero integer portion with more than 19
    zeroes to the right of the decimal point before a significant value, 
    $DECIMAL rounds to the integer.

The digits argument can be used to round the return value to a specified number
of digits. Trailing zeros are always deleted. If digits is a positive integer,
rounding is done using the IEEE rounding standard. If num has more than 38
significant digits (and digits=38) $DECIMAL rounds the fractional portion of
the number at the 38th digit and represents all of the following num digits
with zeros. If digits is greater than 38, an <ILLEGAL VALUE> error is
generated.
If digits is 0, the number is cast to string collation; this is equivalent to 
(+num)_"". If num is 20 digits or less, digits=0 is the same as digits=20.
However, if digits is 0 and num is more than 20 digits, special rounding (not
IEEE rounding) is performed, as follows. Rounding is performed to return 20
digits. Special rounding is then performed on the 20th digit if it rounds to a
0 or a 5. In the case when the 20th digit would round up to a 0 or a 5, Caché
rounds it down to a 9 or a 4, respectively. In the case when the 20th digit
would round down to a 0 or a 5, Caché rounds it up to a 1 or a 6, respectively.
Other 20th digit values are returned unchanged. This rounding algorithm is used
to provide correct numeric collation and avoid rounding inconsistencies.
Integer Divide
With certain values, Caché floating point and IEEE double numbers yield a
different integer divide product. For example:

  WRITE !,"Integer divide operations:"
  WRITE !,"Cache  \: ",$DECIMAL(4.1)\.01  // 410
  WRITE !,"Double \: ",$DOUBLE(4.1)\.01   // 409
For further details on arithmetic operations involving IEEE double numbers,
refer to the article Numeric Computing in Caché.
INF and NAN
If num is INF, a <MAXNUMBER> error is generated. If num is NAN, an <ILLEGAL
VALUE> error is generated. These invalid values are shown in the following
example:

  SET i=$DOUBLE("INF")
  SET n=$DOUBLE("NAN")
  WRITE $DECIMAL(i),!
  WRITE $DECIMAL(n)

Examples
The following example demonstrates that $DECIMAL has no effect when applied to
a fractional number that is already in Caché format:

  SET x=$DECIMAL($ZPI)
  SET y=$ZPI
    IF x=y { WRITE !,"Identical:"
             WRITE !,"Cache $DECIMAL: ",x
             WRITE !,"Native Cache:   ",y }
   ELSE { WRITE !,"Different:"
          WRITE !,"Cache $DECIMAL: ",x
          WRITE !,"Native Cache:   ",y }
The following example returns the value of pi as a $DOUBLE value and as a
standard Caché numeric value. This example shows that equality operations
should not be attempted between $DOUBLE and standard Caché numbers, and that
equivalence cannot be restored by using $DECIMAL to convert IEEE back to Caché:

  SET x=$DECIMAL($ZPI)
  SET y=$DOUBLE($ZPI)
  SET z=$DECIMAL(y)
  IF x=y { WRITE !,"Cache & IEEE Same" }
  ELSEIF x=z { WRITE !,"Cache & IEEE-to-Cache same" }
  ELSE { WRITE !,"All three different"
         WRITE !,"Cache decimal: ",x
         WRITE !,"IEEE float:    ",y
         WRITE !,"IEEE to Cache: ",z }
The following example returns the $DECIMAL conversion of pi as a $DOUBLE value.
These conversions are rounded by different digits argument values:

  SET x=$DOUBLE($ZPI)
  WRITE !,$DECIMAL(x)
   /* returns 3.141592653589793116 (19 digits) */
  WRITE !,$DECIMAL(x,1)
   /* returns 3 */
  WRITE !,$DECIMAL(x,8)
   /* returns 3.1415927 (note rounding) */
  WRITE !,$DECIMAL(x,12)
   /* returns 3.14159265359 (note rounding) */
  WRITE !,$DECIMAL(x,18)
   /* returns 3.14159265358979312 */
  WRITE !,$DECIMAL(x,19)
   /* returns 3.141592653589793116 (19 digits) */
  WRITE !,$DECIMAL(x,20)
   /* returns 3.141592653589793116 (19 digits) */
  WRITE !,$DECIMAL(x,21)
   /* returns 3.141592653589793116 (19 digits) */
  WRITE !,$DECIMAL(x,0)
   /* returns 3.1415926535897931159 (20 digits) */
See Also

  • ZZDUMP command
  • $DOUBLE function
  • $FNUMBER function
  • $NUMBER function
  • Data Types in Caché SQL Reference
  • Operators in Using Caché ObjectScript


 #}}}
*$DOUBLE*  #{{{

Returns a number converted to a 64-bit floating point value.
Synopsis

$DOUBLE(num)

Parameters

num  The numeric value to be converted. You can also specify the strings  NAN 
     and  INF (and their variants).

Description
$DOUBLE returns a number converted to the IEEE double-precision (64 bit)
floating point data type. This type of floating point number can contain up to
20 digits. If num has more than 20 digits, $DOUBLE rounds the fractional
portion to the appropriate number of digits. If the integer portion of num is
more than 20 digits, $DOUBLE rounds the integer to 20 significant digits and
represents the additional digits with zeros.
$DOUBLE converts a Caché floating point number to an IEEE double-precision
floating point number. $DECIMAL performs the inverse operation, converting an
IEEE double-precision floating point number to a standard Caché floating point
number.
$DOUBLE generates floating point numeric values that accord with the IEEE
floating point standard. It is primarily intended for interchange and
compatibility with applications that use this data type standard. IEEE floating
point numbers are represented using binary notation. They have a precision of
53 binary bits, which corresponds to 15.95 decimal digits. (Note that the
binary representation does not correspond exactly to a decimal fraction.) IEEE
floating point numbers have greater min/max value range than standard Caché
floating point numbers. However, standard Caché floating point numbers have a
greater degree of precision. In most cases, standard Caché floating point
numbers are preferable.
Note:
A Caché numeric string literal that exceeds the min/max range supported by
Caché floating point data types (for example,  1E128 ) is automatically
converted to an IEEE double-precision floating point number. This conversion is
only performed on numeric literals; it is not performed on the results of
mathematical operations. This automatic conversion can be controlled on a
per-process basis using $ZUTIL(68,45) or system-wide using $ZUTIL(69,45).
Because numbers generated by $DOUBLE are converted to a binary representation
that does not correspond exactly to decimal digits, equality comparisons
between $DOUBLE values and standard Caché floating point number values may
yield unexpected results and should generally be avoided. Comparisons between 
$DOUBLE values and standard Caché floating point number values are performed
exactly, without rounding. Arithmetic operations involving a $DOUBLE value and
a standard Caché number return a $DOUBLE value. Caché handles conversions to/
from $DOUBLE numeric representations and comparisons between numeric
representations; these operations are, therefore, the same on all platforms.
However, arithmetic operations involving $DOUBLE values are governed by the
underlying operating system, and thus may occasionally differ between
platforms. For further details on arithmetic operations involving IEEE double
numbers, refer to the article Numeric Computing in Caché.
The num value can be specified as a number or a numeric string. It is resolved
to canonical form (leading and trailing zeros removed, multiple plus and minus
signs resolved, etc.) before $DOUBLE conversion. Specifying a non-numeric
string to num returns 0. Specifying a mixed-numeric string (for example
"7dwarves" or "7.5.4") to num truncates the input value at the first
non-numeric character then converts the numeric portion.
The ZZDUMP command returns a different datatype value for list items that were
generated using $DOUBLE.
The Caché SQL data types DOUBLE and DOUBLE PRECISION represent IEEE floating
point numbers; the FLOAT data type represents standard Caché floating point
numbers.
Integer Divide
With certain values, Caché floating point and IEEE double numbers yield a
different integer divide product. For example:

  WRITE !,"Divide operations:"
  WRITE !,"Cache  /: ",4.1/.01           // 410
  WRITE !,"Double /: ",$DOUBLE(4.1)/.01  // 410
  WRITE !,"Integer divide operations:"
  WRITE !,"Cache  \: ",4.1\.01           // 410
  WRITE !,"Double \: ",$DOUBLE(4.1)\.01  // 409
Platform Independence
Standard Caché floating point numbers ($DECIMAL numbers) have a precision of 18
decimal digits. This precision is consistent across all system platforms that
Caché supports.
IEEE double-precision floating point numbers ($DOUBLE numbers) have a standard
internal representation that is platform-independent. Conversions and
comparisons between $DOUBLE and $DECIMAL numbers are consistent across all
system platforms that Caché supports. However, other computations on $DOUBLE
numbers may show slight differences based on the system platform.
INF and NAN
Following the IEEE standard, $DOUBLE can return the strings INF (infinity) and
NAN (not a number). INF can be positive or negative (INF and -INF); NAN is
always unsigned. While these are valid IEEE return values, they are not actual
numbers.
INF and NAN as Input Values
One way to cause $DOUBLE to return INF and NAN is to specify the corresponding
string as the num input value. These input strings are not case-sensitive, and
can take leading plus and minus signs (INF resolves signs, NAN ignores signs).
To return NAN, specify  NAN ,  sNAN ,  +NAN ,  -NAN . To return INF, specify  
INF ,  +INF ,  Infinity . To return -INF, specify  -INF ,  +-INF .
$ZUTIL(68,70) and $ZUTIL(69,70)
The $ZUTIL(68,70) and $ZUTIL(69,70) functions control how $DOUBLE responds to a
numeric conversion that cannot be resolved. $ZUTIL(68,70) controls this
behavior for the current process. $ZUTIL(69,70) controls this behavior
systemwide.
If these functions are set to 0, $DOUBLE returns INF and NAN when it cannot
resolve a conversion. If these functions are set to 1, $DOUBLE generates
standard Caché error codes when it cannot resolve a conversion. The default is
1.
Returning INF and NAN
$DOUBLE can return INF and NAN when you specify an extremely large number, or
when you specify an unresolvable arithmetic operation. These values are only
returned when the current process is set using $ZUTIL(68,70,0), or the system
is set using $ZUTIL(69,70,0).
Extremely large floating point numbers are not supported. The current maximum
supported value for the DOUBLE data type is 1.0E308. The minimum supported
value for the DOUBLE data type is 1.0E-323. A num value smaller than this
returns 0.
Note:
In earlier versions of Caché the maximum supported value for the DOUBLE data
type was 1.79769e145. The minimum supported value for the DOUBLE data type was
either 2.22508e-308 (normal) or 4.9e-324 (denormalized).
The following table shows the value returned or error generated by unresolvable
arithmetic operations:

   Input Value     $ZUTIL(68,70,0)  $ZUTIL(68,70,1)

> 1.0E308          INF              <MAXNUMBER>

< 1.0E-323         0                0

1/$DOUBLE(0)       INF              <DIVIDE>

1/$DOUBLE( 0)       INF             <DIVIDE>

$DOUBLE(1)/0       INF              <DIVIDE>

$DOUBLE(0)/0       NAN              <ILLEGAL VALUE>

$ZLOG($DOUBLE(0))   INF             <DIVIDE>

Comparing INF and NAN
INF can be compared as if it were a numerical value. Thus INF = INF, INF '=  
INF,  INF =  INF, and INF >  INF.
NAN cannot be compared as if it were a numerical value. Because NAN (Not A
Number) cannot be meaningfully compared using numerical operators, Caché
operations (such as equal to, less than, or greater than) that attempt to
compare $DOUBLE( NAN ) to another $DOUBLE( NAN ) fail. Comparisons with NAN <=
or >= are a special case, which is described in  Less-Than Or Equal,
Greater-Than Or Equal in the article Numeric Computing in Caché.
$LISTSAME does consider a $DOUBLE( NAN ) list element to be identical to
another $DOUBLE( NAN ) list element.
Caché does not distinguish between different NAN representations (NAN, sNAN,
etc.). Caché considers all NANs to be the same, regardless of their binary
representation.
$ISVALIDNUM, $INUMBER, and $FNUMBER
These Caché ObjectScript functions provide support for $DOUBLE numbers.
$ISVALIDNUM supports INF and NAN. Although these strings are not numbers, 
$ISVALIDNUM returns 1 for these values, just as if they were numbers. When 
$DOUBLE is specified with a non-numeric string, for example $DOUBLE(""), Caché
returns a value of 0. For this reason, $ISVALIDNUM($DOUBLE("")) returns 1,
because 0 is a number.
$INUMBER and $FNUMBER provide a  D format option that supports $DOUBLE values.
$INUMBER converts a numeric to a IEEE floating point number. $FNUMBER  D 
support includes case conversion of INF and NAN, and choosing whether 
$DOUBLE(-0) should return 0 or -0.
INF and NAN with Operators
You can perform arithmetic and logical operations on INF and NAN. Use of
operators with INF and NAN is not recommended; if such an operation is
performed, the following are the results:
Arithmetic operators:

Addition     Subtraction  Multiplication  Division (/, \, or # operators)

NAN+NAN=NAN  NAN-NAN=NAN  NAN*NAN=NAN     NAN/NAN=NAN

NAN+INF=NAN  NAN-INF=NAN  NAN*INF=NAN     NAN/INF=NAN

             INF-NAN=NAN                  INF/NAN=NAN

INF+INF=INF  INF-INF=NAN  INF*INF=INF     INF/INF=NAN

Logical operators:

Equality (=)   NAN  INF

NAN            0    0

INF            0    1

Less Than (<) or Greater Than (>)  NAN  INF

NAN                                0    0

INF                                0    0

Other operators, such as pattern matching and concatenation, treat NAN and INF
as three-character alphabetic strings.
For further details on arithmetic and logical comparison operations involving
IEEE double numbers, refer to the article Numeric Computing in Caché.
INF and NAN Examples
$DOUBLE returns an INF value (or a -INF for negative numbers) when the numeric
value exceeds the available precision, as shown in the following example:

  SET rtn=$ZUTIL(68,70,0)
  SET x=$DOUBLE(1.2e300)
  WRITE !,"Double: ",x
  WRITE !,"Is number? ",$ISVALIDNUM(x)
  SET y= $DOUBLE(x*x)
  WRITE !,"Double squared: ",y
  WRITE !,"Is number? ",$ISVALIDNUM(y)
$DOUBLE returns a NAN (not a number) value when the numeric value is invalid.
For example, when an arithmetic expression involves two INF values, as shown in
the following example. (An arithmetic expression involving a single INF value
returns INF.)

  SET rtn=$ZUTIL(68,70,0)
  SET x=$DOUBLE(1.2e500)
  WRITE !,"Double: ",x
  WRITE !,"Is number? ",$ISVALIDNUM(x)
  SET y= $DOUBLE(x-x)
  WRITE !,"Double INF minus INF: ",y
  WRITE !,"Is number? ",$ISVALIDNUM(y)
Examples
The following example returns floating point numbers of 20 digits:

   WRITE !,$DOUBLE(999.12345678987654321)
   WRITE !,$DOUBLE(.99912345678987654321)
   WRITE !,$DOUBLE(999123456789.87654321)
The following example returns the value of pi as a $DOUBLE value and as a
standard Caché numeric value. This example shows that equality operations
should not be attempted between $DOUBLE and standard Caché numbers, and that
the number of digits returned is greater for standard Caché numbers:

  SET x=$ZPI
  SET y=$DOUBLE($ZPI)
  IF x=y { WRITE !,"Same" }
  ELSE { WRITE !,"Different"
         WRITE !,"standard:   ",x
         WRITE !,"IEEE float: ",y }
The following examples show that a floating point number is not necessarily
equivalent to a numeric string of the same value:

  SET x=123.4567891234560
  SET y=123.4567891234567
  IF x=$DOUBLE(x) { WRITE !,"Same" }
  ELSE { WRITE !,"Different" }
  IF y=$DOUBLE(y) { WRITE !,"Same" }
  ELSE { WRITE !,"Different" }

  SET x=1234567891234560
  SET y=1234567891234567
  IF x=$DOUBLE(x) { WRITE !,"Same" }
  ELSE { WRITE !,"Different" }
  IF y=$DOUBLE(y) { WRITE !,"Same" }
  ELSE { WRITE !,"Different" }
See Also

  • ZZDUMP command
  • $DECIMAL function
  • $FNUMBER function
  • $NUMBER function
  • $ZUTIL(68,70)  Set $DOUBLE INF and NAN behavior function
  • $ZUTIL(69,70)  Set $DOUBLE INF and NAN behavior system-wide function
  • Data Types in Caché SQL Reference
  • Operators in Using Caché ObjectScript


 #}}}
*$EXTRACT*  #{{{

Returns or replaces a substring, using a character count.
Synopsis

$EXTRACT(string,from,to)
$E(string,from,to)

SET $EXTRACT(string,from,to)=value
SET $E(string,from,to)=value

Parameters

string  An expression that evaluates to the target string from which the
        substring is to be extracted.

        Optional  The starting position within the target string from which to
        extract a character or the beginning of a range of characters.
        Different values are used for the two-parameter form 
        $EXTRACT(string,from), and the three-parameter form 
        $EXTRACT(string,from,to):
        Without to: Specifies a single character. Specify either an expression
        that evaluates to a positive integer (counting from 1), an asterisk
        (which specifies the last character of the string), or an asterisk
from    followed by an expression that evaluates to a negative integer (which
        specifies a start position counting backwards from the last character
        of the string). A zero (0) or negative number returns the empty string.
        With to: Specifies the start of a range of characters. Either specify
        an expression that evaluates to a positive integer (counting from 1) or
        an asterisk followed by an expression that evaluates to a negative
        integer (which specifies a start position counting backwards from the
        last character of the string). A zero (0) or negative number evaluates
        as 1.

        Optional  The end position (inclusive) for a range of characters to be
        extracted, counting from the beginning or end of string. Specify either
to      a positive integer (counting from 1), an asterisk (which specifies the
        last character of the string), or an asterisk followed by a negative
        integer (which specifies an end position counting backwards from the
        last character of the string).

Description
$EXTRACT can be used in two ways:

  • To return a substring from string. The substring is determined by a
    specified character position in string. This uses the 
    $EXTRACT(string,from,to) syntax.
  • To replace a substring within string. The replacement substring may be the
    same length, longer, or shorter than the original substring. The substring
    is determined by a specified character position in string. This uses the 
    SET $EXTRACT(string,from,to)=value syntax.

$EXTRACT returns or replaces a substring from a specified position in string.
The nature of this substring depends on the parameters used.

  • $EXTRACT(string) extracts the first character in the string.
  • $EXTRACT(string,from) extracts a single character in the position specified
    by from. The from value can be an integer count from the beginning of the
    string, an asterisk specifying the last character of the string, or an
    asterisk with a negative integer specifying a count backwards from the end
    of the string.
    In the following example, variable mystr contains the string  ABCD , and
    variables are defined for positive and negative integers. The $EXTRACT
    functions return  B (the second character),  D (the final character), then
     A (3 characters before the final character):
   
       SET mystr="ABCD"
       SET pnum=2
       SET nnum=-3
       WRITE !,$EXTRACT(mystr,pnum)    // "B"
       WRITE !,$EXTRACT(mystr,*)       // "D"
       WRITE !,$EXTRACT(mystr,*+nnum)  // "A"
  • $EXTRACT(string,from,to) extracts the range of characters starting with the
    from position and ending with the to position. For example, if variable 
    var2 contains the string  1234Alabama567 , the following $EXTRACT functions
    both return the string  Alabama :
   
       SET var2="1234Alabama567"
       WRITE !,$EXTRACT(var2,5,11)
       WRITE !,$EXTRACT(var2,*-9,*-3)

You can also use the $EXTRACT function with the SET command to change the
values of specified characters within a string. For example:

   SET var1="ABCD"
   SET $EXTRACT(var1,2)="Z"
   WRITE var1
returns  AZCD .
Parameters
string
The string value can be a variable name, a numeric value, a string literal, or
any valid Caché ObjectScript expression.
from
The from parameter can specify a single character, or the beginning of a range
of characters. The from value must be a positive integer, an asterisk (*), or
an asterisk and a negative number. A from asterisk value with a negative number
may include or omit blank spaces; all of the following are permissible: *-3, 
* -3, * - 3.
The handling of 0 and negative number values differs for $EXTRACT(string,from),
and $EXTRACT(string,from,to).
If the from integer value is greater than the number of characters in the
string, $EXTRACT returns a null string. If the from asterisk negative value is
equal to or greater than the number of characters in the string, $EXTRACT
returns a null string.
If from is used with the to parameter, from identifies the start of the range
to be extracted and must be less than the value of to. If from equals to, 
$EXTRACT returns the single character at the specified position. If from is
greater than to, $EXTRACT returns a null string. If used with the to parameter,
a from value less than 1 (zero, or a negative number) is treated as if it were
the number 1.
to
The to parameter must be used with the from parameter. It must be a positive
integer, an asterisk (*), or an asterisk followed by a negative integer. If the
to value is an integer greater than or equal to the from value, $EXTRACT
returns the specified substring. If the to value is an asterisk, $EXTRACT
returns the substring beginning with the from character through the end of the
string. If to is an integer greater than the length of the string, $EXTRACT
also returns the substring beginning with the from character through the end of
the string. If to is less than from, $EXTRACT returns a null string.
$EXTRACT Examples
The following example returns  D , the fourth character in the string:

   SET x="ABCDEFGHIJK"
   WRITE $EXTRACT(x,4)
The following example returns  K , the last character in the string:

   SET x="ABCDEFGHIJK"
   WRITE $EXTRACT(x,*)
In the following example, all the $EXTRACT functions return  J the next-to-last
character in the string:

   SET n=-1
   SET m=1
   SET x="ABCDEFGHIJK"
   WRITE !,$EXTRACT(x,*-1)
   WRITE !,$EXTRACT(x,*-m)
   WRITE !,$EXTRACT(x,*+n)
   WRITE !,$EXTRACT(x,*-1,*-1)
Note that a minus or plus sign is needed between the asterisk and the integer
variable.
The following example shows that the one-argument format is equivalent to the
two-argument format when the from value is  1 . Both $EXTRACT functions return
 H .

   SET x="HELLO"
   WRITE !,$EXTRACT(x)
   WRITE !,$EXTRACT(x,1)
The following example returns a substring  THIS IS which is composed of the
first through seventh characters.

   SET x="THIS IS A TEST"
   WRITE $EXTRACT(x,1,7)
The following example also returns the substring  THIS IS . When the from
variable contains a value less than 1, $EXTRACT treats that value as 1. Thus,
the following example returns a substring composed of the first through seventh
characters.

   SET X="THIS IS A TEST"
   WRITE $EXTRACT(X,-1,7)
The following example returns the last four characters of the string:

   SET X="THIS IS A TEST"
   WRITE $EXTRACT(X,*-3,*)
The following example also returns the last four characters of the string:

   SET X="THIS IS A TEST"
   WRITE $EXTRACT(X,*-3,14)
$EXTRACT with SET
You can use $EXTRACT with the SET command to replace a specified character or
range of characters with another value.
The simplest form of SET $EXTRACT is a one-for-one substitution:

   SET foo="ABZD"
   SET $EXTRACT(foo,3)="C"
   WRITE foo
yields  ABCD .
You can also extract a string and replace it with a string of a different
length. For example, the following command extracts the string  Rhode Island 
from foo and replaces it with the string  Texas , with no padding.

   SET foo="Deep in the heart of Rhode Island"
   SET $EXTRACT(foo,22,33)="Texas"
   WRITE foo
yields "Deep in the heart of Texas".
You can extract a string and set it to the null string, removing the extracted
characters from the string:

   SET foo="ABCzzzzzD"
   SET $EXTRACT(foo,4,8)=""
   WRITE foo
yields  ABCD .
If you specify to larger than the string, $EXTRACT pads with blank spaces:

   SET foo="ABCD"
   SET $EXTRACT(foo,8)="X"
   WRITE foo
yields  ABCD^^^X (here a blank space is shown using  ^ ).
If you specify from larger than to, no replacement occurs:

   SET foo="ABCD"
   SET $EXTRACT(foo,4,3)="X"
   WRITE foo
yields  ABCD .
SET $EXTRACT Examples
The following example changes the value of x from  ABCD to  ZBCD :

   SET x="ABCD"
   SET $EXTRACT(x,1)="Z"
   WRITE x
The following example replaces  ABCD with  GHIJ .

   SET x="ABCD"
   SET $EXTRACT(x,1,4)="GHIJ"
   WRITE x
In the following example, assume that variable x does not exist.

   KILL x
   SET $EXTRACT(x,1,4)="ABCD"
   WRITE x
The SET command creates variable x and assigns it the value  ABCD .
You can also use SET $EXTRACT to add or remove character positions in a target
variable.
To add character positions, specify a from value or a from,to range that
exceeds the length of the target variable. For example, if x contains  ABCD, 
the following $EXTRACT function inserts the value  Z in the tenth position:

   SET x="ABCD"
   SET $EXTRACT(x,10)="Z"
   WRITE x
Because 10 exceeds the number of characters in x, SET $EXTRACT fills the
intervening positions (that is, position 5 through 9) with spaces. As a result,
x now contains the value  ABCD^^^^^Z , where ^ indicates a space.
The following example inserts the value  Y in the eleventh position, but no
additional characters in positions 12 and 13.

   SET x="ABCD"
   SET $EXTRACT(x,11,13)="Y"
   WRITE x
As a result, the original x value ( ABCD ) is changed to  ABCD^^^^^^Y and x now
has a length of 11. (If the assigned value  Y were three characters, instead of
just one, positions 12 and 13 would be filled as well.)
To remove character positions, extract a character or range and replace it with
the null string. The following results in a two-character string with the value
 AD :

   SET x="ABCD"
   SET $EXTRACT(x,2,3)=""
   WRITE x
The following example shortens a character string by extracting a from,to range
larger than the number of values in the replacement string.

   SET x="ABCDEFGH"
   SET $EXTRACT(x,3,6)="Z"
   WRITE x
inserts the value  Z in the third position and removes positions 4, 5 and 6.
Variable x now contains the value  ABZGH and has a length of 5.
Notes
$EXTRACT and Unicode
The $EXTRACT function operates on characters, not bytes. Therefore, Unicode
strings are handled the same as ASCII strings, as shown in the following
example using the Unicode character for  pi ($CHAR(960)):

   SET a="QT PIE"
   SET b="QT "_$CHAR(960)
   SET a1=$EXTRACT(a,-33,4)
   SET a2=$EXTRACT(a,4,4)
   SET a3=$EXTRACT(a,4,99)
   SET b1=$EXTRACT(b,-33,4)
   SET b2=$EXTRACT(b,4,4)
   SET b3=$EXTRACT(b,4,99)
   WRITE !,"ASCII form returns ",!,a1,!,a2,!,a3
   WRITE !,"Unicode form returns ",!,b1,!,b2,!,b3
Surrogate Pairs
$EXTRACT does not recognize surrogate pairs. A surrogate pair is a pair of
16-bit Unicode characters that together encode a single ideographic character.
Surrogate pairs are used to represent some Chinese characters and to support
the Japanese JIS2004 standard. You can use the $WISWIDE function to determine
if a string contains a surrogate pair. The $WEXTRACT function recognizes and
correctly parses surrogate pairs. $EXTRACT and $WEXTRACT are otherwise
identical. However, because $EXTRACT is generally faster than $WEXTRACT, 
$EXTRACT is preferable for all cases where a surrogate pair is not likely to be
encountered.
$EXTRACT in DTM Modes
In the DTM and DTM-J modes, $EXTRACT supports two additional arguments, as
follows:

$EXTRACT(string,from,to,replace,pad)

The optional replace argument replaces the substring specified by from and to
with the replace substring, and returns the result. The original string is not
changed.
The optional pad argument specifies a padding character. This is used when the 
from argument specifies a position beyond the end of string. The returned
string is padded to the location specified by from followed by the replace
substring. The pad value may be any single character; a non-numeric character
must be enclosed in quotes. To specify a quote character as the pad character
literal, double it.
You can set DTM mode using $ZUTIL(55,2) for DTM or $ZUTIL(55,7) for DTM-J.
The following example shows the four-argument replace syntax:

   SET x="ABCDEFGH"
   DO $ZUTIL(55,2)
   WRITE $EXTRACT(x,3,6,"##")
     /* returns "AB##GH"  */

The following example use the four-argument syntax to append the replace
string:

   SET x="ABCDEFGH"
   DO $ZUTIL(55,2)
   WRITE $EXTRACT(x,1,0,"##")
     /* returns "##ABCDEFGH"  */

The following example shows the five-argument pad and replace syntax:

   SET x="ABCDEFGH"
   DO $ZUTIL(55,2)
   WRITE $EXTRACT(x,12,16,"##","*")
     /* returns "ABCDEFGH***##"  */

Note:
When using four-argument or five-argument syntax, the $EXTRACT from and to
arguments do not support asterisk syntax.
SET $EXTRACT cannot be used with four-argument or five-argument syntax.
$EXTRACT Compared with $PIECE and $LIST
$EXTRACT determines a substring by counting characters from the beginning of a
string. $EXTRACT takes as input any ordinary character string. $PIECE and $LIST
both work on specially prepared strings.
$PIECE determines a substring by counting user-defined delimiter characters
within the string.
$LIST determines an element from an encoded list by counting elements (not
characters) from the beginning of the list. $LIST cannot be used on ordinary
strings, and $EXTRACT cannot be used on encoded lists.
See Also

  • SET command
  • $FIND function
  • $LENGTH function
  • $PIECE function
  • $WEXTRACT function
  • $WFIND function
  • $WISWIDE function
  • $ZEXP function
  • $ZLN function


 #}}}
*$FACTOR*  #{{{

Converts integer to bitstring.
Synopsis

$FACTOR(num,scale)

Parameters

       An expression that evaluates to a number. num is converted to a positive
num    integer before bitstring conversion. A negative number is converted to a
       positive number (its absolute value). A fractional number is rounded to
       an integer.

scale  Optional  An integer used as a power-of-ten exponent (scientific
       notation) multiplier for num. The default is 0.

Description
$FACTOR returns the binary bitstring that corresponds to the supplied integer.
If you specify a fractional number as num, $FACTOR rounds this number to an
integer, and then returns the binary bitstring that corresponds to this
integer. When rounding numbers, Caché rounds the fraction .5 up to the next
highest integer.
If you specify a negative number, $FACTOR takes the absolute value of the
number, then performs the conversion to a binary bitstring .
The binary string returned specifies bit positions starting from position 1
(left-to-right). This corresponds to the bitstrings used by the various $BIT
functions.
Parameters
num
A number (or an expression that evaluates to a number). $FACTOR applies the 
scale parameter (if supplied), converts this number to an integer by rounding,
and then returns the corresponding bitstring. num can be positive or negative.
If num is a mixed numeric string (for example  7dwarves or  5.6.8 ) $FACTOR
converts the numeric part of the string (in our example, 7 and 5.6) until it
encounters a non-numeric character. If num is zero, or rounds to zero, or is
the null string (""), or a non-numeric string, $FACTOR returns an empty string.
The $DOUBLE values INF,  INF, and NAN return the empty string.
scale
An integer that specifies the scientific notation exponent to apply to num. For
example, if scale is 2, then scale represents 10 exponent 2, or 100. This scale
value is multiplied by num. For example, $FACTOR(7,2) returns the bitstring
that corresponds to the integer 700. This multiplication is done before
rounding num to an integer. By default, scale is 0.
Examples
The following example show the conversion of the integers 1 through 9 to
bitstrings:

   SET x=1
   WHILE x<10 {
   WRITE !,x,"="
   FOR i=1:1:8 {
     WRITE $BIT($FACTOR(x),i) }
   SET x=x+1 }
The following example show the conversion of a negative number. $FACTOR takes
the absolute value of the number:

  ZZDUMP $FACTOR(8.5)   /* returns binary 9 */
  ZZDUMP $FACTOR(-8.5)  /* returns binary 9 */
The following example show the bitstring returned when the scale parameter is
specified:

 SET x=2.7
   WRITE !,x," scaled then rounded to an integer:",!!
   FOR i=1:1:12 {
     WRITE $BIT($FACTOR(x),i) }
   WRITE " binary = ",$NORMALIZE(x,0)," decimal",!
 SET scale=1
   SET y=x*(10**scale)
   FOR i=1:1:12 {
     WRITE $BIT($FACTOR(x,scale),i) }
   WRITE " binary = ",$NORMALIZE(y,0)," decimal",!
 SET scale=2
   SET y=x*(10**scale)
   FOR i=1:1:12 {
     WRITE $BIT($FACTOR(x,scale),i) }
   WRITE " binary = ",$NORMALIZE(y,0)," decimal"
See Also

  • $BIT function
  • $BITCOUNT function
  • $BITFIND function
  • $BITLOGIC function
  • $DOUBLE function


 #}}}
*$FIND*  #{{{

Finds a substring by value and returns an integer specifying its end position
in the string.
Synopsis

$FIND(string,substring,position)
$F(string,substring,position)

Parameters

           The target string that is to be searched. It can be a variable name,
string     a numeric value, a string literal, or any valid Caché ObjectScript
           expression that resolves to a string.

           The substring that is to be searched for. It can be a variable name,
substring  a numeric value, a string literal, or any valid Caché ObjectScript
           expression that resolves to a string.

position   Optional  A position within the target string at which to start the
           search. It must be a positive integer.

Description
$FIND returns an integer specifying the end position of a substring within a
string. $FIND searches string for substring. $FIND is case sensitive. If 
substring is found, $FIND returns the integer position of the first character
following substring. If substring is not found, $FIND returns a value of 0.
Because $FIND returns the position of the character following the substring,
when substring is a single character that matches the first character of string
$FIND returns 2. When substring is the null string (""), $FIND returns 1.
You can include the position option to specify a starting position for the
search. If position is greater than the number of characters in string, $FIND
returns a value of 0.
Examples
For example, if variable var1 contains the string  ABCDEFG and variable var2
contains the string  BCD, the following $FIND returns the value 5, indicating
the position of the character ( E ) that follows the var2 string:

   SET var1="ABCDEFG",var2="BCD"
   WRITE $FIND(var1,var2)
The following example returns 4, the position of the character immediately to
the right of the substring  FOR .

   SET X="FOREST"
   WRITE $FIND(X,"FOR")
In the following examples, $FIND searches for a substring that is not in string
, for a null substring, and for a substring that is the first character of 
string. The examples return 0, 1, and 2, respectively:

   WRITE !,$FIND("aardvark","z")  ; returns 0
   WRITE !,$FIND("aardvark","")   ; returns 1
   WRITE !,$FIND("aardvark","a")  ; returns 2
The following examples show what happens when string is a null string:

   WRITE !,$FIND("","z")  ; returns 0
   WRITE !,$FIND("","")   ; returns 1
The following example returns 14, the position of the character immediately to
the right of the first occurrence of  R after the seventh character in X.

   SET X="EVERGREEN FOREST",Y="R"
   WRITE $FIND(X,Y,7)
In the following example, $FIND begins its search after the last character in
string. It returns zero (0):

   SET X="EVERGREEN FOREST",Y="R"
   WRITE $FIND(X,Y,20)
The following example uses name indirection to return 6, the position of the
character immediately to the right of the substring  THIS :

   SET Y="x",x="""THIS IS A TEST"""
   WRITE $FIND(@Y,"THIS")
For more information, refer to Indirection in Using Caché ObjectScript.
Notes
$FIND, $EXTRACT, $PIECE, and $LIST

  • $FIND locates a substring by value and returns a position.
  • $EXTRACT locates a substring by position and returns the substring value.
  • $PIECE locates a substring by a delimiter character or delimiter string,
    and returns the substring value.
  • $LIST operates on specially encoded strings. It locates a substring by
    substring count and returns the substring value.

The $FIND, $EXTRACT, $LENGTH, and $PIECE functions operate on standard
character strings. The various $LIST functions operate on encoded character
strings, which are incompatible with standard character strings. The sole
exception is the one-argument and two-argument forms of $LIST, which take an
encoded character string as input, but output a single element value as a
standard character string.
Surrogate Pairs
$FIND does not recognize surrogate pairs. A surrogate pair is a pair of 16-bit
Unicode characters that together encode a single ideographic character.
Surrogate pairs are used to represent some Chinese characters and to support
the Japanese JIS2004 standard. You can use the $WISWIDE function to determine
if a string contains a surrogate pair. The $WFIND function recognizes and
correctly parses surrogate pairs. $FIND and $WFIND are otherwise identical.
However, because $FIND is generally faster than $WFIND, $FIND is preferable for
all cases where a surrogate pair is not likely to be encountered.
See Also

  • $EXTRACT function
  • $LENGTH function
  • $LIST function
  • $PIECE function
  • $WEXTRACT function
  • $WFIND function
  • $WISWIDE function


 #}}}
*$FNUMBER*  #{{{

Formats a numeric value with a specified format; optionally rounds to a
specified precision.
Synopsis

$FNUMBER(inumber,format,decimal)
$FN(inumber,format,decimal)

Parameters

         The number that is to be formatted. It can be a numeric value, the
inumber  name of a numeric variable, or any valid Caché ObjectScript expression
         that evaluates to a numeric value.

         A format specification of how the number is to be formatted. Specified
         as a quoted string consisting of zero or more format codes, in any
format   order. Format codes are described below. Note that some format codes
         are incompatible and result in an error. For default formatting, with
         or without the decimal parameter, you can specify the empty string
         ("").

decimal  Optional  The number of decimal digits to be included in the returned
         number.

Description
$FNUMBER returns the number specified by inumber in the specified format.
Parameters
format
The possible format codes are as follows. You can specify them singly or in
combination.

Code                                 Description

      Returns a nonnegative number prefixed by the PlusSign property of the
+     current locale ( + by default). If the number is negative, it returns the
      number prefixed by the MinusSign property of the current locale ( - by
      default).

      Returns a negative number without prefixing it by the MinusSign property
-     of the current locale. Otherwise, it returns the number without any
      leading sign.

      Returns the number with the value of the NumericGroupSeparator property
,     of the current locale ( , by default) inserted every NumericGroupSize (3
      by default) numeral to the left of the decimal point. Combining  . and  ,
       formats results in a <FUNCTION> error.

.     Always returns the number using European formatting. Combining  . and  , 
      formats results in a <FUNCTION> error.

      $DOUBLE special formatting. This code has two effects:
       D specifies that $DOUBLE(-0) should return -0; otherwise, $DOUBLE(-0)
D     returns 0. However,  -D overrides the negative sign and returns 0.
      You can specify  D or  d for this code; a returned INF or NAN will be
      expressed in the corresponding uppercase or lowercase letters. The
      default is upper case.

      E-notation (scientific notation). Returns the number in scientific
      notation. If you omit the decimal number of fractional digits, 6 is used
      as the default. You can specify  E or  e for this code; the returned
E     value will contain the corresponding uppercase or lowercase symbol. The
      exponent portion of the returned value is two digits in length with a
      leading sign, unless three exponent digits are required.  E and  G are
      incompatible and result in a <FUNCTION> error.

      E-notation or fixed decimal notation. If the number of fractional digits
      that would result from conversion to scientific notation is larger than
      the decimal value (or the default of 6 decimal digits), the number is
      returned in scientific notation. For example, $FNUMBER(1234.99,"G",2)
      returns 1.23E+03. If the number of fractional digits that would result
G     from conversion to scientific notation is equal to or smaller than the 
      decimal value (or the default of 6 decimal digits), the number is
      returned in fixed decimal (standard) notation. For example, 
      $FNUMBER(1234.99,"G",3) returns 1235. You can specify  G or  g for this
      code; the returned scientific notation value will contain the
      corresponding uppercase  E or lowercase  e .  E and  G are incompatible
      and result in a <FUNCTION> error.

      Leading sign. Sign, if present, must precede the numerical portion of 
L     inumber. Parentheses are not permitted. This code cannot be used with the
       P or  T format codes; attempting to do so results in a <SYNTAX> or
      <FUNCTION> error. Leading sign is the default format.

      Parentheses sign. Returns a negative number in parentheses and without a
      leading MinusSign locale property value. Otherwise, it returns the number
P     without parentheses, but with a leading and trailing space character.
      This code cannot be used with the  + ,  - ,  L , or  T format codes;
      attempting to do so results in a <SYNTAX> error.

      Trailing sign. Returns the number with a trailing sign if a prefix sign
      would otherwise have been generated. However, it does not force a
      trailing sign. To produce a trailing sign for a nonnegative number
      (positive or zero), you must also specify the  + format code. To produce
      a trailing sign for a negative number, you must not specify the  - format
T     code. The trailing sign used is determined by the PlusSign and MinusSign
      properties of the current locale respectively. A trailing space
      character, but no sign, is inserted in the case of a nonnegative number
      with  + omitted or in the case of a negative number with  - specified.
      Parentheses are not permitted. This code cannot be used with the  L or  P
       format codes; attempting to do so results in a <SYNTAX> or <FUNCTION>
      error.

The $DOUBLE function can return the values INF (infinite) and NAN (not a
number). INF can take a negative sign; format codes represent INF as if it were
a number. For example: +INF, INF-, (INF). NAN does not take a sign; the only
format code that affects NAN is  d , which returns it in lowercase letters. The
 E and  G codes have no effect on INF and NAN values.
decimal
Rounding is performed before the number is truncated or zero filled. It can be
specified as a positive integer value, the name of an integer variable, or any
valid Caché ObjectScript expression that evaluates to a positive integer. If
the decimal value is 0, the number is returned as an integer, with no decimal
point. If the decimal value is greater than the number of decimal digits in the
number, the remaining positions are zero filled. If inumber itself is less than
1, $FNUMBER inserts a leading zero before the decimal point.
You can specify the decimal parameter to control the number of fractional
digits returned, after rounding is performed. The decimal parameter must
evaluate to an integer. For example, assume that variable c contains the number
6.25198.

   SET c="6.25198"
   SET x=$FNUMBER(c,"+",3)
   SET y=$FNUMBER(c,"+",8)
   WRITE !,x,!,y
The first $FNUMBER returns +6.252 and the second returns +6.25198000. Zero fill
is performed if the decimal parameter exceeds the number of fractional digits
in the number.
Examples
The following examples show how the different formatting designations can
affect the behavior of $FNUMBER. These examples assume that the current locale
is the default locale.
The following example shows the effects of sign codes on a positive number:

   SET a=1234
   WRITE $FNUMBER(a,""),!   ; returns 1234
   WRITE $FNUMBER(a,"+"),!  ; returns +1234
   WRITE $FNUMBER(a,"-"),!  ; returns 1234
   WRITE $FNUMBER(a,"L"),!  ; returns 1234
   WRITE $FNUMBER(a,"T"),!  ; returns 1234 (with a trailing space)
   WRITE $FNUMBER(a,"T+"),! ; returns 1234+
The following example shows the effects of sign codes on a negative number:

   SET b=-1234
   WRITE $FNUMBER(b,""),!  ; returns -1234
   WRITE $FNUMBER(b,"+"),! ; returns -1234
   WRITE $FNUMBER(b,"-"),! ; returns 1234
   WRITE $FNUMBER(b,"L"),! ; returns -1234
   WRITE $FNUMBER(b,"T"),! ; returns 1234-
The following example shows the effects of the  P format code on positive and
negative numbers. This example writes asterisks before and after the number to
show that a positive number is returned with a leading and a trailing blank:

  WRITE "*",$FNUMBER(-123,"P"),"*",!  ; returns *(123)*
  WRITE "*",$FNUMBER(123,"P"),"*",!   ; returns * 123 *
The following example returns 1,234,567.81; $FNUMBER inserts a comma every 3
numerals to the left of the decimal point of C.

   SET C=1234567.81
   WRITE $FNUMBER(C,",")
The following example returns 1.234.567,81; $FNUMBER inserts European
formatting to C.

   SET D=1234567.81
   WRITE $FNUMBER(D,".")
The following example returns 124,329.00; $FNUMBER inserts a comma and adds a
decimal point and two zeros to the value of C.

    SET C=124329
    WRITE $FNUMBER(C,",",2)
Notes
Decimal Separator
$FNUMBER uses the DecimalSeparator property value for the current locale ( . by
default) as the delimiter character between the integer part and the fractional
part of fnumber. When the  . format code is specified, this delimiter is a  , 
regardless of the current locale.
To determine the DecimalSeparator character for your locale, invoke the
following method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
Numeric Group Separator and Size
$FNUMBER uses the NumericGroupSeparator property value from the current locale
( , by default) as the delimiter between groups of digits in the integer part
of fnumber. The size of these groups is determined by the NumericGroupSize
property of the current locale ( 3 by default). When the  . format code is
specified, this delimiter is a  . and appears every three digits regardless of
the current locale.
To determine the NumericGroupSeparator character and NumericGroupSize number
for your locale, invoke the following methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("NumericGroupSeparator"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("NumericGroupSize")
Differences between $FNUMBER and $INUMBER
Most format codes have similar meanings in the $FNUMBER and $INUMBER functions,
but the exact behavior triggered by each code differs by function because of
the nature of the validations and conversions being performed.
In particular, the  - and  + format codes do not have quite the same meaning
for $FNUMBER as they do for $INUMBER. With $FNUMBER,  - and  + are not mutually
exclusive, and  - only affects the MinusSign (by suppressing it), and  + only
affects the PlusSign (by inserting it). With $INUMBER,  - and  + are mutually
exclusive.  - means no sign is permitted, and  + means there must be a sign.
See Also

  • $DOUBLE function
  • $JUSTIFY function
  • $INUMBER function
  • $ISVALIDNUM function
  • $NORMALIZE function
  • $NUMBER function
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$GET*  #{{{

Returns the data value of a specified variable.
Synopsis

$GET(variable,default)
$G(variable,default)

Parameters

          A local or global variable, subscripted or unsubscripted. The
variable  variable may be undefined. variable may be specified as a
          multidimensional object property with the syntax obj.property.

default   Optional  The value to be returned if the variable is undefined. If a
          variable, it must be defined.

Description
$GET returns the data value of a specified variable. The handling of undefined
variables depends on whether you specify a default parameter.

  • $GET(variable) returns the value of the specified variable, or the null
    string if the variable is undefined. The variable parameter value can be
    the name of any variable, including a subscripted array element (either
    local or global).
  • $GET(variable,default) provides a default value to return if the variable
    is undefined. If the variable is defined, $GET returns its value.

Parameters
variable
The variable whose data value is to be returned. It can be a local variable or
a global variable, either subscripted or unsubscripted. It can be a
multidimensional object property. The variable does not need to be a defined
variable. The variable can be defined and set to the null string (""). If a
global variable, it can contain an extended global reference. If a subscripted
global variable, it can be specified using a naked global reference. Even when
referencing an undefined subscripted global variable, variable resets the naked
indicator, affecting future naked global references, as described below.
default
The data value to be returned if variable is undefined. It can any expression,
including a local variable or a global variable, either subscripted or
unsubscripted. If a variable, it must be defined variable; if default is an
undefined variable, $GET issues an <UNDEFINED> error, even when variable is
defined. If a global variable, it can contain an extended global reference. If
a subscripted global variable, it can be specified using a naked global
reference. If present, default resets the naked indicator, affecting future
naked global references, as described below.
Examples
In the following example, the variable test is defined and the variable xtest
is undefined. (The ZWRITE command is used because it explicitly returns a null
string value.)

   KILL xtest
   SET test="banana"
   SET tdef=$GET(test),tundef=$GET(xtest)
   ZWRITE tdef    ; $GET returned value of test
   ZWRITE tundef  ; $GET returned null string for xtest
   WRITE !,$GET(xtest,"none")
     ; $GET returns default of "none" for undefined variable
In the following example, a multidimensional property is used as the variable
value. This example returns the names of all defined namespaces:

  SET obj = ##class(%ResultSet).%New("%SYS.Namespace:List")
  DO obj.Execute()
  WRITE !,$GET(obj.Data,"none") // returns "none"
  SET x=1
  WHILE x'="" {
     DO obj.Next()
     SET x=$GET(obj.Data("Nsp"))
     IF x'="" {
     WRITE !,"Namespace: ",x }
   }
   WRITE !,"Done!"
A similar program returns the same information using the $DATA function.
Notes
$GET Compared to $DATA
$GET provides an alternative to $DATA tests for both undefined variables ($DATA
=0) and array nodes that are downward pointers without data ($DATA=10). If the
variable is either undefined or a pointer array node without data, $GET returns
a null string ("") without an undefined error. For example, you can recode the
following lines:

   IF $DATA(^client(i))=10 {
      WRITE !!,"Name: No Data"
      GOTO Level1+3
   }

as:

   IF $GET(^client(i))="" {
      WRITE !!,"Name: No Data"
      GOTO Level1+3
   }

Note that $DATA tests are more specific than $GET tests because they allow you
to distinguish between undefined elements and elements that are downward
pointers only. For example, the lines:

  IF $DATA(^client(i))=0 { QUIT }
  ELSEIF $DATA(^client(i))=10 {
    WRITE !!,"Name: No Data"
    GOTO Level1+3
  }

could not be recoded as:

   IF $GET(^client(i))="" { QUIT }
   ELSEIF $GET(^client(i))="" {
      WRITE !!,"Name: No Data"
      GOTO Level1+3
   }

The two lines perform different actions depending on whether the array element
is undefined or a downward pointer without data. If $GET were used here, only
the first action (QUIT) would ever be performed. You could use $DATA for the
first test and $GET for the second, but not the reverse ($GET for the first
test and $DATA for the second).
Defaults with $GET and $SELECT
$GET(variable,default) allows you to return a default value when a specified
variable is undefined. The same operation can be performed using a $SELECT
function.
However, unlike $SELECT, the second argument in $GET is always evaluated.
The fact that $GET always evaluates both of its arguments is significant if 
variable and default both make subscripted global references and thus both
modify the naked indicator. Because the arguments are evaluated in
left-to-right sequence, the naked indicator is set to the default global
reference, regardless of the whether $GET returns the default value. For
further details on using $GET with global variables and the naked indicator,
see Using Multidimensional Storage (Globals) in Using Caché Globals.
Handling Undefined Variables
$GET defines handling behavior if a specified variable is undefined. The basic
form of $GET returns a null string ("") if the specified variable is undefined.
$DATA tests if a specified variable is defined. It returns 0 if the variable is
undefined.
The $ZUTIL(18) function defines handling behavior for all undefined variables
for the current process. The $ZUTIL(69,0) function defines handling behavior
for all undefined variables system-wide. Setting $ZUTIL(18) or $ZUTIL(69,0) has
no effect on $GET or $DATA handling of specified variables.
See Also

  • $DATA function
  • $SELECT function
  • $ZUTIL(18) Set Undefined Variable Handling function
  • $ZUTIL(69,0) Set Undefined Variable Handling System-wide function
  • Using Multidimensional Storage (Globals) in Using Caché Globals


 #}}}
*$INCREMENT*  #{{{

Adds a specified increment to the existing value of a local or global variable.
Synopsis

$INCREMENT(variable,num)
$I(variable,num)

Parameters

          The variable whose value is to be incremented. It can specify a local
          variable, a process private global, or a global variable and can be
variable  either subscripted or unsubscripted. The variable need not be
          defined. If the variable is not defined, or is set to the null string
          (""), $INCREMENT treats it as having an initial value of zero and
          increments accordingly. A literal value cannot be specified here.

          Optional  The numeric increment you want to add to variable. The
          value can be a number (integer or non-integer, positive or negative),
          a string containing a number, or any expression which evaluates to a
num       number. Leading and trailing blanks and multiple signs are evaluated.
          A string is evaluated until the first nonnumeric character is
          encountered. The null string ("") is evaluated as zero.
          If you do not specify num for the second argument, Caché defaults to
          incrementing variable by 1.

Description
$INCREMENT resets the value of a variable by adding a specified increment to
the existing value of the variable and returning the incremented value. This is
shown in the following example:

  SET a=7
  SET result=$INCREMENT(a)
  WRITE !,result   /* result is 8 (a+1)        */
  WRITE !,a        /* variable a is also now 8 */
The variable parameter can be a local variable, a process private global, or a
global variable. It can be subscripted or unsubscripted. It cannot be a
literal. If this variable is not defined, or set to a null string, it is
treated as having a value of zero.
The num parameter can be a positive number, incrementing the value of the
variable, or a negative number, decrementing the value of the variable. If you
do not specify an increment, Caché uses the default increment of one (1).
You can use the $GET function to return the current value of a variable.
$INCREMENT performs this increment as an atomic operation, which does not
require the use of the LOCK command.
If multiple processes simultaneously increment the same global through 
$INCREMENT, each process receives a unique, increasing number (or decreasing
number if num is negative). In some situations, certain numbers may be skipped
due to timing issues. For further details on using $INCREMENT with global
variables, see Using Multidimensional Storage (Globals) in Using Caché Globals.
Caché does not restore the original, non-incremented value if $INCREMENT is in
a transaction that is rolled back.
Incrementing Strings
$INCREMENT is generally used for incrementing a variable containing a numeric
value. However, it does accept a variable containing a string. The following
rules apply when using $INCREMENT on a string:

  • A null string ("") is treated as having a value of zero.
  • A numeric string ("123" or "+0012.30") is treated as having that numeric
    value. The string is converted to canonical form: leading and trailing
    zeros and the plus sign are removed.
  • A mixed numeric/nonnumeric string ("12AB" or "1,000") is treated as the
    numeric value up to the first nonnumeric character and then truncated at
    that point. (Note that a comma is a nonnumeric character.) The resulting
    numeric substring is converted to canonical form: leading and trailing
    zeros and the plus sign are removed.
  • A nonnumeric string ("ABC" or "$12") is treated as having a value of zero.
  • Scientific notation conversion is performed. For example, if strvar="3E2", 
    $INCREMENT treats it as having a value of 300.
  • Arithmetic operations are not performed. For example, if strvar="3+7", 
    $INCREMENT will truncate the string at the plus sign (treating it as a
    nonnumeric character) and increment strvar to 4.
  • Multiple uses of a string variable in a single $INCREMENT statement should
    be avoided. For example, avoid concatenating a string variable to the
    increment of that variable: strvar_$INCREMENT(strvar). This returns
    unpredictable results.

Examples
The following example increments the value of myvar by n. Note that myvar does
not have to be a prior defined variable:

   SET n=4
   KILL myvar
   SET VAL=$INCREMENT(myvar,n)       ; returns 4
   WRITE !,myvar
   SET VAL=$INCREMENT(myvar,n)       ; returns 8
   WRITE !,myvar
   SET VAL=$INCREMENT(myvar,n)       ; returns 12
   WRITE !,myvar
The following example adds incremental values to the process private variable ^
||xyz using $INCREMENT. The one-argument form of $INCREMENT increments by 1;
the two-argument form increments by the value specified in the second argument.
In this case, the second argument is a non-integer value.

   KILL ^||xyz
   WRITE !,$INCREMENT(^||xyz)       ; returns 1
   WRITE !,$INCREMENT(^||xyz)       ; returns 2
   WRITE !,$INCREMENT(^||xyz)       ; returns 3
   WRITE !,$INCREMENT(^||xyz,3.14)  ; returns 6.14
The following example shows the effects of incrementing by zero (0) and
incrementing by a negative number:

   KILL xyz
   WRITE !,$INCREMENT(xyz,0)  ; initialized as zero
   WRITE !,$INCREMENT(xyz,0)  ; still zero
   WRITE !,$INCREMENT(xyz)    ; increments by 1 (default)
   WRITE !,$INCREMENT(xyz)    ; increments by 1 (=2)
   WRITE !,$INCREMENT(xyz,-1) ; decrements by -1 (=1)
   WRITE !,$INCREMENT(xyz,-1) ; decrements by -1 (=0)
   WRITE !,$INCREMENT(xyz,-1) ; decrements by -1 (=-1)
The following example shows the effects of incrementing using mixed (numeric
and nonnumeric) num strings and the null string:

   KILL xyz
   WRITE !,$INCREMENT(xyz,"")
           ; null string initializes to 0
   WRITE !,$INCREMENT(xyz,2)
           ; increments by 2
   WRITE !,$INCREMENT(xyz,"")
           ; null string increments by 0 (xyz=2)
   WRITE !,$INCREMENT(xyz,"3A4")
           ; increments by 3 (rest of string ignored)
   WRITE !,$INCREMENT(xyz,"A4")
           ; nonnumeric string evaluates as zero (xyz=5)
   WRITE !,$INCREMENT(xyz,"1E2")
           ; increments by 100 (scientific notation)
Notes
$INCREMENT and $ZINCREMENT
$INCREMENT and $ZINCREMENT have the same syntax and effects. You can use 
$ZINCREMENT in any situation in which you would use $INCREMENT.
$INCREMENT and Global Variables
You can use $INCREMENT on a global variable or a subscript node of a global
variable. You can access a global variable mapped to another namespace using an
extended global reference. You can access a subscripted global variable using a
naked global reference.
Caché evaluates parameters in left-to-right order. If num (the amount to
increment) is a subscripted global, Caché uses this global reference to set the
naked indicator, affecting all subsequent naked global references.
Locking and Simultaneous Global Increments
$INCREMENT and $ZINCREMENT do not perform a lock operation when they increment 
variable nor does using the LOCK command on variable prevent $INCREMENT from
incrementing or decrementing its value. For example, suppose process 1 executes
a lock on ^COUNTER:

   LOCK ^COUNTER

Then suppose, process 2 increments ^COUNTER:

   SET x=$INCREMENT(^COUNTER,VAL)

Process 2 is not prevented from incrementing ^COUNTER by the lock held by
process 1.
The two processes are not guaranteed their own unique ^COUNTER values unless
both are using $INCREMENT.
$INCREMENT and Transaction Processing
The common usage for $INCREMENT is to increment a counter before adding a new
entry to a database. $INCREMENT provides a way to do this very quickly,
avoiding the use of the LOCK command.
The trade off for this is that the counter is not locked. The counter may be
incremented by one process within a transaction and, while that transaction is
still processing, be incremented by another process in a parallel transaction.
In the event either transaction (or any other transaction that uses $INCREMENT)
must be rolled back (with the TROLLBACK command), counter increments are
ignored. The counter variables are not decremented since it is not clear
whether the resulting counter value would be valid. In all likelihood, such a
rollback would be disastrous for other transactions.
For further details on using $INCREMENT in a distributed database environment,
refer to  The $INCREMENT Function and Application Counters in the Developing
Distributed Applications chapter of the Caché Distributed Data Management Guide
.
See Also

  • TROLLBACK command
  • $GET function
  • $ZINCREMENT function
  • Using ObjectScript for Transaction Processing in Using Caché ObjectScript


 #}}}
*$INUMBER*  #{{{

Validates a numeric value and converts it to internal format.
Synopsis

$INUMBER(fnumber,format,erropt)
$IN(fnumber,format,erropt)

Parameters

         The numeric value to be converted to the internal format. It can be a
fnumber  numeric or string value, a variable name, or any valid Caché
         ObjectScript expression.

         A format specification indicating which external numeric formats are
         valid representations of numbers. Specified as a quoted string
format   consisting of zero or more format codes, in any order. Format codes
         are described below. Note that some format codes are incompatible and
         result in an error. For default formatting, with or without the erropt
         parameter, you can specify the empty string ("").

erropt   Optional  The expression returned if fnumber is considered invalid
         based on format.

Description
The $INUMBER function validates the numeric value fnumber using the formats
specified in format. It then converts it to the internal Caché format.
If fnumber does not correspond to the specified format and you have not
specified erropt, Caché generates an <ILLEGAL VALUE> error. If you have
specified erropt, an invalid numeric value returns the erropt string.
Parameters
format
The possible format codes are as follows. You can specify them singly or in
combination to instruct $INUMBER to adhere strictly to the format rules. If no
format codes are entered, $INUMBER will be as flexible as possible in
validating fnumber (see Null Format Provides Maximum Flexibility for more
information).

Code                                 Description

      Mandatory sign. The fnumber value must have a explicit sign. Even the
      number 0 must be signed (+0 or -0). The sign can be either leading or
+     trailing, unless restricted by either an  L or a  T format code.
      Parentheses cannot be used. The only value that does not require a sign
      is NAN, which can be specified with or without a sign when using code  D+
       .

-     Unsigned. No sign may be present in fnumber.

      $DOUBLE numbers. This code converts fnumber to an IEEE floating point
      number. This is equivalent to $DOUBLE(fnumber). If  D is specified, you
      can input the quoted strings  INF and  NAN as an fnumber value. INF and
D     NAN can be specified in any combination of uppercase and lowercase
      letters, with or without leading or trailing signs or enclosing
      parentheses. (Signs are accepted, but ignored, for NAN.) The variant
      forms INFINITY and SNAN are also supported.

E or  E-notation (scientific notation). This code allows you to specify fnumber
G     as a string in scientific notation format. This code permits, but does
      not require, that you specify fnumber in scientific notation.

P     Negative numbers must be enclosed in parentheses. Nonnegative numbers
      must be unsigned, and may have or omit leading and trailing spaces.

L     Leading sign. Sign, if present, must precede the numerical portion of 
      fnumber. Parentheses are not permitted.

T     Trailing sign. Sign, if present, must follow the numerical portion of 
      fnumber. Parentheses are not permitted.

      Expects fnumber to use the format specified by properties in the current
,     locale. The NumericGroupSeparator ( , by default) may or may not appear
      in fnumber, but if present, it must consistently appear every
      NumericGroupSize (3 by default) digits to the left of the decimal point.

      Requires European numeric group separators ( . ) and European decimal
      symbols ( , ) regardless of the current locale. It also requires the use
.     of the PlusSign and MinusSign from the default locale ( + and  - 
      respectively). Periods are optional, but if present must consistently
      appear every three digits (the value of the NumericGroupSeparator
      property of the default locale) to the left of the decimal comma.

When “+”, “-” and “P” Format Codes are Absent
When format does not include any of the  + ,  - , or  P codes, then fnumber may
contain any one of the following:

  • No sign or parentheses.
  • Either the PlusSign locale property ( + by default) or the MinusSign locale
    property ( - by default) but not both. The position of this sign is
    determined by the  L or the  T format code if specified.
  • Leading and trailing parentheses.

When “L”, “T” and “P” Format Codes are Absent
When format does not include any of the  L ,  T , or  P format codes, any sign
present in fnumber may be either leading or trailing (but not both).
When “,” and “.” Format Codes are Absent
When format does not include either the  , or  . format codes, fnumber may
optionally have NumericGroupSeparator symbols appear anywhere to the left or
right of the DecimalSeparator, if any. However, each NumericGroupSeparator must
have at least one digit to its immediate left and one to its immediate right.
Mutually Exclusive Format Codes
Some format codes conflict with each other. Each of the following pairs of
format codes are mutually exclusive and result in an error:

  •  -+ results in a <FUNCTION> error
  •  -P or  +P result in a <SYNTAX> error
  •  TP or  LP result in a <SYNTAX> error
  •  TL results in a <FUNCTION> error
  •  ,. results in a <FUNCTION> error

A <FUNCTION> error is also generated if you specify an invalid format code
character.
Null Format Provides Maximum Flexibility
You can specify format as a null string. This is called a null format. When a
null format is specified, $INUMBER accepts a fnumber value with any one of the
following sign conventions:

  • No sign or parentheses.
  • Either a leading or trailing MinusSign, but not both.
  • Either a leading or trailing PlusSign, but not both.
  • Leading and trailing parentheses.

When a null format is specified, fnumber may optionally have
NumericGroupSeparator symbols appear anywhere to the left or right of the
DecimalSeparator, if any. However, each NumericGroupSeparator must have at
least one digit to its immediate left and one to its immediate right. Sign
rules are flexible, and leading and trailing blanks and zeros are ignored.
Thus, the following two commands:

   WRITE !,$INUMBER("+1,23,456,7.8,9,100","")
   WRITE !,$INUMBER("0012,3456,7.891+","")
are both valid and return the same number, formatted according to the default
locale. However,

   WRITE $INUMBER("1,23,,345,7.,8,9,","")

is invalid because of the adjacent commas, the adjacent period and comma, and
the trailing comma. It generates an <ILLEGAL VALUE> error.
Behavior Common to All Formats
Regardless of the specified format codes, $INUMBER always ignores leading and
trailing blank spaces or zeros, but considers fnumber to be invalid if it has
any of the following characteristics:

  • Both a PlusSign and a MinusSign
  • More than one PlusSign or MinusSign
  • Parentheses and a PlusSign
  • Parentheses and a MinusSign
  • More than one DecimalSeparator
  • Embedded Spaces
  • Any characters other than the following:
      □ Numeric digits
      □  ( 
      □  ) 
      □ Leading or trailing spaces
      □ The DecimalSeparator specified by the current locale (if format does
        not include  . )
      □ The NumericGroupSeparator specified by the current locale (if format
        does not include  . )
      □ The PlusSign property specified by the current locale (if format does
        not include  . )
      □ The MinusSign property specified by the current locale (if format does
        not include  . )
      □  . (if format includes  . )
      □  , (if format includes  . )
      □  + (if format includes  . )
      □  - (if format includes  . )
  • The strings  INF and  NAN (and their variants) if format includes  D .

Examples
These examples illustrate how different formats affect the behavior of $INUMBER
. All of these examples assume the current locale is the default locale.
In the following example, $INUMBER accepts a leading minus sign because of the
 L format code and returns -123456789.12345678:

   WRITE $INUMBER("-123,4,56,789.1234,5678","L")
In the following example, $INUMBER generates an <ILLEGAL VALUE> error because
the sign is leading but the  T format code specifies that trailing signs must
be used:

   WRITE $INUMBER("-123,4,56,789.1234,5678","T")
In the following example, the first $INUMBER succeeds and returns a negative
number. The second $INUMBER generates an <ILLEGAL VALUE> error because fnumber
includes a sign but the  P format code specifies that negative numbers must be
enclosed in parentheses rather than signed:

   WRITE !,$INUMBER("(123,4,56,789.1234,5678)","P")
   WRITE !,$INUMBER("-123,4,56,789.1234,5678","P")
In the following example, $INUMBER generates an <ILLEGAL VALUE> error because a
sign is present but the  - format code specifies that numbers must be unsigned:

   WRITE $INUMBER("-123,4,56,789.1234,5678","-")
In the following example, $INUMBER fails but does not generate an error due to
the illegal use of a sign, but instead returns as its value the string  ERR 
specified as the erropt:

   WRITE $INUMBER("-123,4,56,789.1234,5678","-","ERR")
The following example returns -23456789.123456789; $INUMBER accepts the
specified fnumber as valid because the leading sign follows the formatting
specified by  L and the strict spacing of commas every three digits to the left
of the decimal place with no commas to its right follows the strict formatting
specified by the  , code:

   WRITE $INUMBER("-23,456,789.123456789","L,")
In the following example, the  E code permits conversion of a scientific
notation string to a number. Note that all format codes support scientific
notation as a numeric literal, but only  E (or  G ) support scientific notation
as a string. This example uses variables and concatenation to provide the
scientific notation string values:

   SET num=1.234
   SET exp=-14
   WRITE $INUMBER(1.234E-14,"E","E-lit-err"),!
   WRITE $INUMBER(num_"E"_exp,"E","E-string-err"),!
   WRITE $INUMBER(1.234E-14,"L","L-lit-err"),!
   WRITE $INUMBER(num_"E"_exp,"L","L-string-err"),!
The following example compares the values returned by  L code and a  D code for
a fractional number and for the constant pi. The  D code converts to an IEEE
floating point ($DOUBLE) number:

   WRITE $INUMBER(1.23E-23,"L"),!
   WRITE $INUMBER(1.23E-23,"D"),!
   WRITE $INUMBER($ZPI,"L"),!
   WRITE $INUMBER($ZPI,"D"),!
Notes
Differences between $INUMBER and $FNUMBER
Most format codes have similar meanings in the $INUMBER and $FNUMBER functions,
but the exact behavior triggered by each code differs by function because of
the nature of the validations and conversions being performed.
In particular, the  - and  + format codes do not have quite the same meaning
for $INUMBER as they do for $FNUMBER. With $FNUMBER,  - and  + are not mutually
exclusive, and  - only affects the MinusSign (by suppressing it), and  + only
affects the PlusSign (by inserting it). With $INUMBER,  - and  + are mutually
exclusive.  - means no sign is permitted, and  + means there must be a sign.
Decimal Separator
$INUMBER uses the DecimalSeparator property value for the current locale ( . by
default) as the delimiter character between the integer part and the fractional
part of fnumber. When the  . format code is specified, this delimiter is a  , 
regardless of the current locale.
To determine the DecimalSeparator character for your locale, invoke the
following method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
Numeric Group Separator and Size
$INUMBER uses the NumericGroupSeparator property value from the current locale
( , by default) as the delimiter between groups of digits in the integer part
of fnumber. The size of these groups is determined by the NumericGroupSize
property of the current locale ( 3 by default). When the  . format code is
specified, this delimiter is a  . and appears every three digits regardless of
the current locale.
To determine the NumericGroupSeparator character and NumericGroupSize number
for your locale, invoke the following methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("NumericGroupSeparator"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("NumericGroupSize")
See Also

  • $DOUBLE function
  • $FNUMBER function
  • $ISVALIDNUM function
  • $NORMALIZE function
  • $NUMBER function
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ISOBJECT*  #{{{

Returns whether an expression is an object reference.
Synopsis

$ISOBJECT(expr)

Parameters

expr  A Caché ObjectScript expression.

Description
$ISOBJECT returns 1 if expr is an object reference. $ISOBJECT returns 0 if expr
is not an object reference.
$ISOBJECT returns  1 if expr is a reference to an invalid object. Invalid
objects should not occur in normal operations; an invalid object could be
caused, for example, by recompiling the class while instances of the class are
active.
To remove an object reference, set the variable to the null string (""). The
obsolete %Close() method cannot be used to remove an object reference. %Close()
performs no operation and always returns successful completion. Do not use
%Close() when writing new code.
Parameters
expr
Any Caché ObjectScript expression.
Examples
The following example shows the values returned by $ISOBJECT for an object
reference and a non-object reference (in this case, a string reference):

  SET a="certainly not an object"
  SET o=##class(%Library.ResultSet).%New()
  WRITE !,"nonobject: ",$ISOBJECT(a)
  WRITE !,"objref o: ",$ISOBJECT(o)
The following example shows how to remove an object reference. The %Close()
method does not change the object reference. Setting an object reference to the
null string deletes the object reference:

  SET o=##class(%Library.ResultSet).%New()
  WRITE !,"objref o: ",$ISOBJECT(o)
  DO o.%Close()  ; this is a no-op
  WRITE !,"objref o: ",$ISOBJECT(o)
  SET o=""
  WRITE !,"objref o: ",$ISOBJECT(o)
See Also

  • $SYSTEM special variable


 #}}}
*$ISVALIDDOUBLE*  #{{{

Validates a $DOUBLE numeric value and returns a boolean; optionally provides
range checking.
Synopsis

$ISVALIDDOUBLE(num,scale,min,max)

Description
The $ISVALIDDOUBLE function validates whether num is IEEE double-precision
floating point number and returns a boolean value. It optionally performs a
range check using min and max values, which are automatically converted to IEEE
numbers. The scale parameter is used during range checking to specify how many
fractional digits to compare. A boolean value of 1 means that num is a properly
formed $DOUBLE number and passes the range check, if one is specified.
Parameters
num
The number to be validated may be an integer, a fractional number, a number in
scientific notation (with the letter  E or  e ). It may be a string,
expression, or variable that resolves to a number. It may be signed or
unsigned, and may contain leading or trailing zeros. Validation fails (
$ISVALIDDOUBLE returns 0) if:

  • num contains any characters other than the digits 0 9, a leading + or  
    sign, a decimal point (.), and a letter  E or  e .
  • num contains more than one + or  sign, decimal point, or letter  E or  e .
  • The optional + or  sign is not the first character of num.
  • The letter  E or  e indicating a base-10 exponent is not followed by an
    integer in a numeric string. With a number,  E not followed by an integer
    results in a <SYNTAX> error.
  • num is the null string.

If num is INF,  INF, or NAN $ISVALIDDOUBLE returns 1.
scale
The scale parameter is used during range checking to specify how many
fractional digits to compare. Specify an integer value for scale; any
fractional digits in the scale value are ignored. You can specify a scale value
larger than the number of fractional digits specified in the other parameters.
You can specify a scale value of  1; all other negative scale values result in
a <FUNCTION> error.
A nonnegative scale value causes num to be rounded to that number of fractional
digits before performing min and max range checking. A scale value of 0 causes 
num to be rounded to an integer value (3.9 = 4) before performing range
checking. A scale value of  1 causes num to be truncated to an integer value
(3.9 = 3) before performing range checking. To compare all specified digits
without rounding or truncating, omit the scale parameter. A scale value that is
nonnumeric or the null string is equivalent to a scale value of 0.
Rounding is performed for all scale values except  1. A value of 5 or greater
is always rounded up.
The scale parameter value causes evaluation using rounded or truncated versions
of the num value. The actual value of the num variable is not changed by 
$ISVALIDDOUBLE processing.
If you omit the scale parameter, retain the comma as a place holder.
min and max
You can specify a minimum allowed value, a maximum allowed value, neither, or
both. If specified, the num value (after the scale operation) must be greater
than or equal to the min value, and less than or equal to the max value. The
values are converted to IEEE floating point numbers before being used for range
checking. A null string as a min or max value is equal to zero. If a value does
not meet these criteria, $ISVALIDDOUBLE returns 0.
The NAN value is always valid, regardless of the min or max value.
If you omit a parameter, retain the comma as a place holder. For example, when
omitting scale and specifying min or max, or when omitting min and specifying 
max. Trailing commas are ignored.
Examples
In the following example, each invocation of $ISVALIDDOUBLE returns 1 (valid
number):

   WRITE !,$ISVALIDDOUBLE(0)        ; All integers OK
   WRITE !,$ISVALIDDOUBLE(4.567)    ; Fractional numbers OK
   WRITE !,$ISVALIDDOUBLE("4.567")  ; Numeric strings OK
   WRITE !,$ISVALIDDOUBLE(-.0)      ; Signed numbers OK
   WRITE !,$ISVALIDDOUBLE(+004.500) ; Leading/trailing zeroes OK
   WRITE !,$ISVALIDDOUBLE(4E2)      ; Scientific notation OK
In the following example, each invocation of $ISVALIDDOUBLE returns 0 (invalid
number):

   WRITE !,$ISVALIDDOUBLE("")      ; Null string is invalid
   WRITE !,$ISVALIDDOUBLE("4,567") ; Commas are not permitted
   WRITE !,$ISVALIDDOUBLE("4A")    ; Invalid character
In the following example, each invocation of $ISVALIDDOUBLE returns 1 (valid
number), even though INF (infinity) and NAN (Not A Number) are, strictly
speaking, not numbers:

   WRITE !,$ISVALIDDOUBLE($DOUBLE($ZPI))  ; DOUBLE numbers OK
   WRITE !,$ISVALIDDOUBLE($DOUBLE("INF")) ; DOUBLE INF OK
   WRITE !,$ISVALIDDOUBLE($DOUBLE("NAN")) ; DOUBLE NAN OK
The following example shows the use of the min and max parameters. All of the
following return 1 (number is valid and also passes the range check):

   WRITE !,$ISVALIDDOUBLE(4,,3,5)    ; scale can be omitted
   WRITE !,$ISVALIDDOUBLE(4,2,3,5)   ; scale can be larger than
                                     ; number of fractional digits
   WRITE !,$ISVALIDDOUBLE(4,0,,5)    ; min or max can be omitted
   WRITE !,$ISVALIDDOUBLE(4,0,4,4)   ; min and max are inclusive
   WRITE !,$ISVALIDDOUBLE(-4,0,-5,5) ; negative numbers
   WRITE !,$ISVALIDDOUBLE(4.00,2,04,05) ; leading/trailing zeros
   WRITE !,$ISVALIDDOUBLE(.4E3,0,3E2,400) ; base-10 exponents expanded
The following example shows the use of the scale parameter with min and max.
All of the following return 1 (number is valid and also passes the range
check):

   WRITE !,$ISVALIDDOUBLE(4.55,,4.54,4.551)
     ; When scale is omitted, all digits of num are checked.
   WRITE !,$ISVALIDDOUBLE(4.1,0,4,4.01)
     ; When scale=0, num is rounded to an integer value
     ; (0 fractional digits) before min & max check.
   WRITE !,$ISVALIDDOUBLE(3.85,1,3.9,5)
     ; num is rounded to 1 fractional digit,
     ; (with values of 5 or greater rounded up)
     ; before min check.
   WRITE !,$ISVALIDDOUBLE(4.01,17,3,5)
     ; scale can be larger than number of fractional digits.
   WRITE !,$ISVALIDDOUBLE(3.9,-1,2,3)
     ; When scale=-1, num is truncated to an integer value
Notes
$ISVALIDDOUBLE and $ISVALIDNUM Compared
The $ISVALIDDOUBLE and $ISVALIDNUM functions both validate numbers and return a
boolean value (0 or 1).

  • Both functions accept as valid numbers the INF,  INF, and NAN values
    returned by $DOUBLE. $ISVALIDDOUBLE also accepts as valid numbers the not
    case-sensitive strings  NAN and  INF , as well as the variants  Infinity 
    and  sNAN , and any of these strings beginning with a single plus or minus
    sign. $ISVALIDNUM rejects all of these strings as invalid, and returns 0.
   
       WRITE !,$ISVALIDNUM($DOUBLE("NAN"))    ; returns 1
       WRITE !,$ISVALIDDOUBLE($DOUBLE("NAN")) ; returns 1
       WRITE !,$ISVALIDNUM("NAN")             ; returns 0
       WRITE !,$ISVALIDDOUBLE("NAN")          ; returns 1
  • Both functions parse signed and unsigned integers (including  0),
    scientific notation numbers (with  E or  e ), real numbers (123.45) and
    numeric strings ( 123.45 ).
  • Neither function recognizes the NumericGroupSeparator character (American
    format: comma (,); European format: period (.) or apostrophe (')). For
    example, both reject the string  123,456 as an invalid number.
  • Both functions parse multiple leading signs (+ and  ) for numbers. Neither
    accepts multiple leading signs in a quoted numeric string.

See Also

  • $DOUBLE function
  • $FNUMBER function
  • $INUMBER function
  • $ISVALIDNUM function
  • $NORMALIZE function
  • $NUMBER function
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ISVALIDNUM*  #{{{

Validates a numeric value and returns a boolean; optionally provides range
checking.
Synopsis

$ISVALIDNUM(num,scale,min,max)

Parameters

num    The numeric value to be validated. It can be a numeric or string value,
       a variable name, or any valid Caché ObjectScript expression.

scale  Optional  The number of significant fractional digits for min and max
       range comparisons.

min    Optional  The minimum permitted numeric value.

max    Optional  The maximum permitted numeric value.

Description
The $ISVALIDNUM function validates num and returns a boolean value. It
optionally performs a range check using min and max values. The scale parameter
is used during range checking to specify how many fractional digits to compare.
A boolean value of 1 means that num is a properly formed number and passes the
range check, if one is specified.
Parameters
num
The number to be validated may be an integer, a real number, or a scientific
notation number (with the letter  E or  e ). It may be a string, expression, or
variable that resolves to a number. It may be signed or unsigned, and may
contain leading or trailing zeros. Validation fails ($ISVALIDNUM returns 0) if:

  • num is the empty string ("").
  • num contains any characters other than the digits 0 9, a leading + or  
    sign, a decimal point (.), and a letter  E or  e .
  • num contains more than one + or  sign, decimal point, or letter  E or  e .
  • The optional + or  sign is not the first character of num.
  • The letter  E or  e indicating a base-10 exponent is not followed by an
    integer in a numeric string.

With the exception of $ISVALIDNUM, specifying a base-10 number with a
non-integer exponent in any expression results in a <SYNTAX> error. For
example, WRITE 7E3.5.
If a base-10 exponent is greater than 308 (308  (number of integers - 1)), a
<MAXNUMBER> error results. For example, $ISVALIDNUM('1E309') and 
$ISVALIDNUM('111E307') both generate a <MAXNUMBER> error.
The scale parameter value causes evaluation using rounded or truncated versions
of the num value. The actual value of the num variable is not changed by 
$ISVALIDNUM processing.
If num is the INF,  INF, or NAN value returned by $DOUBLE, $ISVALIDNUM returns
1.
scale
The scale parameter is used during range checking to specify how many
fractional digits to compare. Specify an integer value for scale; fractional
digits in the scale value are ignored. You can specify a scale value larger
than the number of fractional digits specified in the other parameters. You can
specify a scale value of  1; all other negative scale values result in a
<FUNCTION> error.
A nonnegative scale value causes num to be rounded to that number of fractional
digits before performing min and max range checking. A scale value of 0 causes 
num to be rounded to an integer value (3.9 = 4) before performing range
checking. A scale value of  1 causes num to be truncated to an integer value
(3.9 = 3) before performing range checking. To compare all specified digits
without rounding or truncating, omit the scale parameter. A scale value that is
nonnumeric or the null string is equivalent to a scale value of 0.
Rounding is performed for all scale values except  1. A value of 5 or greater
is always rounded up.
If you omit the scale parameter, retain the comma as a place holder.
When rounding numbers, be aware that IEEE floating point numbers and standard
Caché fractional numbers differ in precision. $DOUBLE IEEE floating point
numbers are encoded using binary notation. They have a precision of 53 binary
bits, which corresponds to 15.95 decimal digits of precision. (Note that the
binary representation does not correspond exactly to a decimal fraction.)
Because most decimal fractions cannot be exactly represented in this binary
notation, an IEEE floating point number may differ slightly from the
corresponding standard Caché floating point number. Standard Caché fractional
numbers have a precision of 18 decimal digits on all supported Caché system
platforms. When an IEEE floating point number is displayed as a fractional
number, the binary bits are often converted to a fractional number with far
more than 18 decimal digits. This does not mean that IEEE floating point
numbers are more precise than standard Caché fractional numbers.
min and max
You can specify a minimum allowed value, a maximum allowed value, neither, or
both. If specified, the num value (after the scale operation) must be greater
than or equal to the min value, and less than or equal to the max value. A null
string as a min or max value is equal to zero. If a value does not meet these
criteria, $ISVALIDNUM returns 0.
If you omit a parameter, retain the comma as a place holder. For example, when
omitting scale and specifying min or max, or when omitting min and specifying 
max. Trailing commas are ignored.
If the num, min, or max value is a $DOUBLE number, then all three of these
numbers are treated as a $DOUBLE number for this range check. This prevents
unexpected range errors caused by the small generated fractional part of a 
$DOUBLE number.
Examples
In the following example, each invocation of $ISVALIDNUM returns 1 (valid
number):

   WRITE !,$ISVALIDNUM(0)        ; All integers OK
   WRITE !,$ISVALIDNUM(4.567)    ; Real numbers OK
   WRITE !,$ISVALIDNUM("4.567")  ; Numeric strings OK
   WRITE !,$ISVALIDNUM(-.0)      ; Signed numbers OK
   WRITE !,$ISVALIDNUM(+004.500) ; Leading/trailing zeroes OK
   WRITE !,$ISVALIDNUM(4E2)      ; Scientific notation OK
In the following example, each invocation of $ISVALIDNUM returns 0 (invalid
number):

   WRITE !,$ISVALIDNUM("")      ; Null string is invalid
   WRITE !,$ISVALIDNUM("4,567") ; Commas are not permitted
   WRITE !,$ISVALIDNUM("4A")    ; Invalid character
In the following example, each invocation of $ISVALIDNUM returns 1 (valid
number), even though INF (infinity) and NAN (Not A Number) are, strictly
speaking, not numbers:

   SET x=$ZUTIL(68,70,0)
   WRITE !,$ISVALIDNUM($DOUBLE($ZPI))  ; DOUBLE numbers OK
   WRITE !,$ISVALIDNUM($DOUBLE("INF")) ; DOUBLE INF OK
   WRITE !,$ISVALIDNUM($DOUBLE("NAN")) ; DOUBLE NAN OK
   WRITE !,$ISVALIDNUM($DOUBLE(1)/0)   ; generated INF OK
The following example shows the use of the min and max parameters. All of the
following return 1 (number is valid and also passes the range check):

   WRITE !,$ISVALIDNUM(4,,3,5)    ; scale can be omitted
   WRITE !,$ISVALIDNUM(4,2,3,5)   ; scale can be larger than
                                  ; number of fractional digits
   WRITE !,$ISVALIDNUM(4,0,,5)    ; min or max can be omitted
   WRITE !,$ISVALIDNUM(4,0,4,4)   ; min and max are inclusive
   WRITE !,$ISVALIDNUM(-4,0,-5,5) ; negative numbers
   WRITE !,$ISVALIDNUM(4.00,2,04,05) ; leading/trailing zeros
   WRITE !,$ISVALIDNUM(.4E3,0,3E2,400) ; base-10 exponents expanded
The following example shows the use of the scale parameter with min and max.
All of the following return 1 (number is valid and also passes the range
check):

   WRITE !,$ISVALIDNUM(4.55,,4.54,4.551)
     ; When scale is omitted, all digits of num are checked.
   WRITE !,$ISVALIDNUM(4.1,0,4,4.01)
     ; When scale=0, num is rounded to an integer value
     ; (0 fractional digits) before min & max check.
   WRITE !,$ISVALIDNUM(3.85,1,3.9,5)
     ; num is rounded to 1 fractional digit,
     ; (with values of 5 or greater rounded up)
     ; before min check.
   WRITE !,$ISVALIDNUM(4.01,17,3,5)
     ; scale can be larger than number of fractional digits.
   WRITE !,$ISVALIDNUM(3.9,-1,2,3)
     ; When scale=-1, num is truncated to an integer value
Notes
$ISVALIDNUM and $ISVALIDDOUBLE Compared
The $ISVALIDNUM and $ISVALIDDOUBLE functions both validate numbers and return a
boolean value (0 or 1).

  • Both functions accept as valid numbers the INF,  INF, and NAN values
    returned by $DOUBLE. $ISVALIDDOUBLE also accepts as valid numbers the not
    case-sensitive strings  NAN and  INF , as well as the variants  Infinity 
    and  sNAN , and any of these strings beginning with a single plus or minus
    sign. $ISVALIDNUM rejects all of these strings as invalid, and returns 0.
   
       WRITE !,$ISVALIDNUM($DOUBLE("NAN"))    ; returns 1
       WRITE !,$ISVALIDDOUBLE($DOUBLE("NAN")) ; returns 1
       WRITE !,$ISVALIDNUM("NAN")             ; returns 0
       WRITE !,$ISVALIDDOUBLE("NAN")          ; returns 1
  • Both functions parse signed and unsigned integers (including  0),
    scientific notation numbers (with  E or  e ), real numbers (123.45) and
    numeric strings ( 123.45 ).
  • Neither function recognizes the NumericGroupSeparator character (American
    format: comma (,); European format: period (.) or apostrophe (')). For
    example, both reject the string  123,456 as an invalid number.
  • Both functions parse multiple leading signs (+ and  ) for numbers. Neither
    accepts multiple leading signs in a quoted numeric string.

If a numeric string is too big to be represented by a Caché floating point
number, the default is to automatically convert it to an IEEE double-precision
number. However, such large numbers fail the $ISVALIDNUM test, as shown in the
following example:

  WRITE !,"E127 no IEEE conversion required"
  WRITE !,$ISVALIDNUM("9223372036854775807E127")
  WRITE !,$ISVALIDDOUBLE("9223372036854775807E127")
  WRITE !,"E128 automatic IEEE conversion"
  WRITE !,$ISVALIDNUM("9223372036854775807E128")
  WRITE !,$ISVALIDDOUBLE("9223372036854775807E128")
$ISVALIDNUM, $NORMALIZE, and $NUMBER Compared
The $ISVALIDNUM, $NORMALIZE, and $NUMBER functions all validate numbers. 
$ISVALIDNUM returns a boolean value (0 or 1). $NORMALIZE and $NUMBER return a
validated version of the specified number.
These three functions offer different validation criteria. Select the one that
best meets your needs.

  • All three functions parse signed and unsigned integers (including  0),
    scientific notation numbers (with  E or  e ), and numbers with a fractional
    part. However, $NUMBER can be set (using the  I format) to reject numbers
    with a fractional part (including scientific notation with a negative
    base-10 exponent). All three functions parse both numbers (123.45) and
    numeric strings ( 123.45 ).
  • Leading and trailing zeroes are stripped out by all three functions. The
    decimal character is stripped out unless followed by a nonzero value.
  • Numeric strings containing a NumericGroupSeparator: $NUMBER parses
    NumericGroupSeparator characters (American format: comma (,); European
    format: period (.) or apostrophe (')) and the decimal character (American
    format: period (.) or European format: comma (,)) based on its format
    parameter (or the default for the current locale). It accepts and strips
    out any number of NumericGroupSeparator characters. For example, in
    American format it validate  123,,4,56.99 as the number 123456.99. 
    $NORMALIZE does not recognize NumericGroupSeparator characters. It
    validates character-by-character until it encounters a nonnumeric
    character; for example, it validates  123,456.99 as the number 123. 
    $ISVALIDNUM rejects the string  123,456 as an invalid number.
  • Multiple leading signs (+ and  ) are interpreted by all three functions for
    numbers. However, only $NORMALIZE accepts multiple leading signs in a
    quoted numeric string.
  • Trailing + and  signs: All of the three functions reject trailing signs in
    numbers. However, in a quoted numeric string $NUMBER parses one (and only
    one) trailing sign, $NORMALIZE parses multiple trailing signs, and 
    $ISVALIDNUM rejects any string containing a trailing sign as an invalid
    number.
  • Parentheses: $NUMBER parses parentheses surrounding an unsigned number in a
    quoted string as indicating a negative number. $NORMALIZE and $ISVALIDNUM
    reject parentheses.
  • Numeric strings containing multiple decimal characters: $NORMALIZE
    validates character-by-character until it encounters the second decimal
    character. For example, in American format it validates  123.4.56 as the
    number 123.4. $NUMBER and $ISVALIDNUM reject any string containing more
    than one decimal character as an invalid number.
    Numeric strings containing other nonnumeric characters: $NORMALIZE
    validates character-by-character until it encounters an alphabetic
    character. It validates  123A456 as the number 123. $NUMBER and $ISVALIDNUM
    validate the entire string, they reject  123A456 as an invalid number.
  • The null string: $NORMALIZE parses the null string as zero (0). $NUMBER and
    $ISVALIDNUM reject the null string.

The $ISVALIDNUM and $NUMBER functions provide optional min/max range checking.
$ISVALIDNUM, $NORMALIZE, and $NUMBER all provide rounding of numbers to a
specified number of fractional digits. $ISVALIDNUM and $NORMALIZE can round
fractional digits, and round or truncate a number with a fractional part to
return an integer. For example, $NORMALIZE can round 488.65 to 488.7 or 489, or
truncate it to 488. $NUMBER can round both fractional digits and integer
digits. For example, $NUMBER can round 488.65 to 488.7, 489, 490 or 500.
See Also

  • $DOUBLE function
  • $FNUMBER function
  • $INUMBER function
  • $ISVALIDDOUBLE function
  • $NORMALIZE function
  • $NUMBER function
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$JUSTIFY*  #{{{

Returns the value of an expression right-aligned within the specified width.
Synopsis

$JUSTIFY(expression,width,decimal)
$J(expression,width,decimal)

Parameters

            The value that is to be right-aligned. It can be a numeric value, a
expression  string literal, the name of a variable, or any valid Caché
            ObjectScript expression.

            The number of characters within which expression is to be
width       right-aligned. It can be a positive integer value, the name of an
            integer variable, or any valid Caché ObjectScript expression that
            evaluates to a positive integer.

            Optional  The position at which to place the decimal point within
decimal     the width. It can be a positive integer value, the name of an
            integer variable, or any valid Caché ObjectScript expression that
            evaluates to a positive integer.

Description
$JUSTIFY returns the value specified by expression right-aligned within the
specified width. You can include the decimal parameter to decimal-align numbers
within width. If you omit the decimal option, $JUSTIFY truncates all trailing
zeroes for fractional digits.
$JUSTIFY is especially useful for outputting formatted values with the WRITE
command.
Parameters
width
If the value of width is greater than the number of characters in expression
(the usual case), $JUSTIFY right aligns the value of expression by inserting
the necessary number of space characters to its left. If the width is equal to
or less than the number of characters in the value of expression, $JUSTIFY
returns the full value of the expression with no truncation.
decimal
The decimal point position is calculated as the number of digits from the end
of width. $JUSTIFY zero fills any positions remaining between the end of the 
expression value and the end of width. If the expression value itself is less
than 1, $JUSTIFY inserts a leading zero before the decimal point. Note that 
decimal also causes $JUSTIFY to round the expression value to fit the number of
digits.
The decimal parameter is meaningful only if the expression evaluates to a
number. If expression evaluates to a string, $JUSTIFY replaces it with a
numeric string right justified within width. This numeric string starts with
one zero to the left of the decimal, and continuing after the decimal with
trailing zeros of the number specified in decimal. Unlike string values, the
$DOUBLE values INF, -INF, and NAN are returned unchanged by $JUSTIFY,
regardless of the decimal value.
Examples
Assume the following variables var1=250.50 and var2=875.00. These commands:

   SET var1=250.50,var2= 875.00
   WRITE !,$JUSTIFY(var1,20,2),!,$JUSTIFY(var2,20,2)
   WRITE !,$JUSTIFY("_________",20)
   WRITE !,$JUSTIFY("TOTAL",9),$JUSTIFY(var1+var2,11,2)
return the following lines:

               250.50
               875.00
              _______
TOTAL         1125.50

The starting position for width is determined by the current $X value.
If this code had omitted the decimal option for the output numbers, the lines
would appear as follows:

               250.5
                 875
             _______
TOTAL        1125.50

See Also

  • $FNUMBER function
  • $X special variable


 #}}}
*$LENGTH*  #{{{

Returns the number of characters or delimited substrings in a string.
Synopsis

$LENGTH(expression,delimiter)
$L(expression,delimiter)

Parameters

expression  The target string. It can be a numeric value, a string literal, the
            name of any variable, or any valid expression.

            Optional  A string that demarcates separate substrings in the
delimiter   target string. It must be a string literal, but can be of any
            length. The enclosing quotation marks are required.

Description
$LENGTH returns the number of characters in a specified string or the number of
delimited substrings in a specified string, depending on the parameters used.
Note that length counts the number of characters; an 8-bit character and a
16-bit wide character are both counted as one character.

  • $LENGTH(expression) returns the number of characters in the string. If the
    expression is a null string, $LENGTH returns a 0. If expression is a
    numeric expression, it is converted to canonical form before determining
    its length. If expression is a string numeric expression, no conversion is
    performed. If expression is the $DOUBLE values INF, -INF, or NAN, the
    lengths returned are 3, 4, and 3, respectively.
  • $LENGTH(expression,delimiter) returns the number of substrings within the
    string. $LENGTH returns the number of substrings separated from one another
    by the indicated delimiter. This number is always equal to the number of
    delimiters in the string, plus one.
    If the delimiter is the null string, $LENGTH returns a 0. If the delimiter
    is any other valid string literal and the string is a null string, $LENGTH
    returns a 1.

Examples
In the following example, both $LENGTH functions return 4, the number of
characters in the string.

   SET roman="test"
   WRITE !,$LENGTH(roman)," characters in: ",roman
   SET greek=$CHAR(964,949,963,964)
   WRITE !,$LENGTH(greek)," characters in: ",greek
In the following example, the first $LENGTH returns 5. This is the length of
74000, the canonical version of the specified number. The second $LENGTH
returns 8, the length of the string  +007.4e4 .

   WRITE !,$LENGTH(+007.4e4)
   WRITE !,$LENGTH("+007.4e4")
In the following example, the first WRITE returns 11 the number of characters
in var1 (including, of course, the space character). The second WRITE returns
2, the number of substrings in var1 using the space character as the substring
delimiter.

   SET var1="HELLO WORLD"
   WRITE !,$LENGTH(var1)
   WRITE !,$LENGTH(var1," ")
The following example returns 3, the number of substrings within the string, as
delimited by the dollar sign ($) character.

   SET STR="ABC$DEF$EFG",DELIM="$"
   WRITE $LENGTH(STR,DELIM)
If the specified delimiter is not found in the string $LENGTH returns 1,
because the only substring is the string itself.
The following example returns a 0 because the string tested is the null string.

   SET Nstring = ""
   WRITE $LENGTH(Nstring)
The following example shows the values returned when a delimiter or its string
is the null string.

   SET String = "ABC"
   SET Nstring = ""
   SET Delim = "$"
   SET Ndelim = ""
   WRITE !,$LENGTH(String,Delim)   ; returns 1
   WRITE !,$LENGTH(Nstring,Delim)  ; returns 1
   WRITE !,$LENGTH(String,Ndelim)  ; returns 0
   WRITE !,$LENGTH(Nstring,Ndelim) ; returns 0
Notes
$LENGTH, $PIECE, and $LIST

  • $LENGTH with one argument returns the number of characters in a string.
    This function can be used with the $EXTRACT function, which locates a
    substring by position and returns the substring value.
  • $LENGTH with two arguments returns the number of substrings in a string,
    based on a delimiter. This function can be used with the $PIECE function,
    which locates a substring by a delimiter and returns the substring value.
  • $LENGTH should not be used on encoded lists created using $LISTBUILD or 
    $LIST. Use $LISTLENGTH to determine the number of substrings (list
    elements) in an encoded list string.

The $LENGTH, $FIND, $EXTRACT, and $PIECE functions operate on standard
character strings. The various $LIST functions operate on encoded character
strings, which are incompatible with standard character strings. The sole
exception is the one-argument and two-argument forms of $LIST, which take an
encoded character string as input, but outputs a single element value as a
standard character string.
Surrogate Pairs
$LENGTH does not recognize surrogate pairs. A surrogate pair is a pair of
16-bit Unicode characters that together encode a single ideographic character.
Surrogate pairs are used to represent some Chinese characters and to support
the Japanese JIS2004 standard. You can use the $WISWIDE function to determine
if a string contains a surrogate pair. The $WLENGTH function recognizes and
correctly parses surrogate pairs. $LENGTH and $WLENGTH are otherwise identical.
However, because $LENGTH is generally faster than $WLENGTH, $LENGTH is
preferable for all cases where a surrogate pair is not likely to be
encountered.
See Also

  • $EXTRACT function
  • $PIECE function
  • $WISWIDE function
  • $WLENGTH function


 #}}}
*$LISTBUILD*  #{{{

Builds a list of elements from the specified expressions.
Synopsis

$LISTBUILD(element,...)
$LB(element,...)

Parameter

element  Any expression, or comma-separated list of expressions.

Description
$LISTBUILD takes one or more expressions and returns a list with one element
for each expression.
The following functions can be used to create a list:

  • $LISTBUILD, which creates a list from multiple strings, one string per
    element.
  • $LISTFROMSTRING, which creates a list from a single string containing
    multiple delimited elements.
  • $LIST, which extracts a sublist from an existing list.
  • The null string ("") is also considered to be a valid list.

You can use the $LISTVALID function to determine if an expression is a valid
list.
$LISTBUILD is used with the other $LIST functions: $LISTDATA, $LISTFIND, 
$LISTGET, $LISTNEXT, $LISTLENGTH, $LISTSAME, and $LISTTOSTRING. The results of 
$LISTBUILD are often best displayed using the ZZDUMP command. See ZZDUMP for
examples of $LISTBUILD involving non-printing characters and Unicode
characters.
Note:
$LISTBUILD and the other $LIST functions use an optimized binary representation
to store data elements. For this reason, equivalency tests may not work as
expected with some $LIST data. Data that might, in other contexts, be
considered equivalent, may have a different internal representation. For
example, $LISTBUILD(1) is not equal to $LISTBUILD( 1 ).
For the same reason, a list string value returned by $LISTBUILD should not be
used in character search and parse functions that use a delimiter character,
such as $PIECE and the two-argument form of $LENGTH. Elements in a list created
by $LISTBUILD are not marked by a character delimiter, and thus can contain any
character.
Examples
The following example produces the three-element list "Red,Blue,Green":

   SET X=$LISTBUILD("Red","Blue","Green")
   WRITE !,$LIST(X,1,3)
Notes
Omitting Elements
Omitting an element expression yields an element whose value is undefined. For
example, the following $LISTBUILD statements both produce a three-element list
whose second element has an undefined value. Omitting an element and specifying
an undefined variable for an element produces exactly the same result. In
either case, referencing the second element with the $LIST function will
produce a <NULL VALUE> error.

   KILL a
   SET list1=$LISTBUILD("Red",,"Green")
   SET list2=$LISTBUILD("Red",a,"Green")
   WRITE "List lengths:",$LISTLENGTH(list1)," ",$LISTLENGTH(list2),!
   IF list1=list2 {WRITE "they're identical"}
   ELSE {WRITE "they're not identical"}
However, the following produces a three-element list whose second element is a
null string. No error condition occurs when referencing the second element.

   SET list3=$LISTBUILD("Red","","Green")
   WRITE "Element 2 value:",$LIST(list3,2)
If a $LISTBUILD element expression is undefined, the corresponding list element
has an undefined value. The following $LISTBUILD expressions produce the same
two-element list whose first element is "Red" and whose second element has an
undefined value:

   KILL z
   SET list4=$LISTBUILD("Red",)
   SET list5=$LISTBUILD("Red",z)
   SET z="abc"
   IF list4=list5 {WRITE "they're identical"}
   ELSE {WRITE "they're not identical"}
Providing No Parameters
Invoking the $LISTBUILD function with no parameters returns a list with one
element whose data value is undefined. This is not the same as a null string.
The following are all valid $LISTBUILD statements that create  empty lists:

  SET x=$LISTBUILD()
  SET y=$LISTBUILD(NULL)
  SET z=$LISTBUILD(,)    ; two null elements
  ZZDUMP x,y,z
The following are valid $LISTBUILD statements that create a list element that
contains data with null values:

  SET x=$LISTBUILD("")
  SET y=$LISTBUILD($CHAR(0))
  ZZDUMP x,y
Nesting Lists
An element of a list may itself be a list. For example, the following statement
produces a three-element list whose third element is the two-element list,
"Walnut,Pecan":

 SET X=$LISTBUILD("Apple","Pear",$LISTBUILD("Walnut","Pecan"))
 WRITE $LIST(X,3)
Concatenating Lists
The result of concatenating two lists with the Concatenate operator (_) is
another list. For example, the following two WRITE statements produce the same
list, "A,B,C":

   WRITE !,$LIST($LISTBUILD("A","B")_$LISTBUILD("C"),0,-1)
   WRITE !,$LIST($LISTBUILD("A","B","C"),0,-1)
For further details, see Operators in Using Caché ObjectScript.
A null string ("") is an empty list. For example, the following two expressions
each produce the same two-element list:

   WRITE !,$LISTBUILD("A","B")_""
   WRITE !,$LISTBUILD("A","B")
However, the following two expressions each produce a three-element list:

   WRITE !,$LISTBUILD("A","B")_$LISTBUILD("")
   WRITE !,$LISTBUILD("A","B")_$LISTBUILD()
Unicode
If one or more characters in a list element is a wide (Unicode) character, all
characters in that element are represented as wide characters. To ensure
compatibility across systems, $LISTBUILD always stores these bytes in
little-endian order, regardless of the hardware platform. Wide characters are
represented as byte strings. Therefore, when displayed using ZZDUMP, the ZZDUMP
length reflects the number of bytes, not the number of Unicode characters.
In the following example, ZZDUMP shows the first element as having a length of
ten (0A): four characters, each two bytes long, plus the ZZDUMP’s length and
data type bytes. The data type byte is 02 (Unicode string). Each character is
represented by two bytes in little-endian order. The second element has a
length of five (05): three characters, plus the length and data type bytes. The
data type byte is 01 (Binary string).

   SET z=$LISTBUILD($CHAR(987)_"ABC","ABC")
   ZZDUMP z

0000: 0A 02 DB 03 41 00 42 00 43 00 05 01 41 42 43    ..Û.A.B.C...ABC

See Also

  • ZZDUMP command
  • $LIST function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT
  • $LISTSAME function
  • $LISTTOSTRING function
  • $LISTVALID function


 #}}}
*$LISTDATA*  #{{{

Indicates whether the specified element exists and has a data value.
Synopsis

$LISTDATA(list,position)
$LD(list,position)

Parameters

list      An expression that evaluates to a valid list.

position  Optional  An expression interpreted as a position in the specified
          list. Either a positive, non-zero integer or -1.

Description
$LISTDATA checks for data in the requested element in a list and returns a
boolean value. $LISTDATA returns a value of 1 if the element indicated by the 
position parameter is in the list and has a data value. $LISTDATA returns a
value of a 0 if the element is not in the list or does not have a data value.
Parameters
list
A list is an encoded string containing multiple elements. A list must have been
created using $LISTBUILD or $LISTFROMSTRING, or extracted from another list
using $LIST.
You can use the $LISTVALID function to determine if an expression is a valid
list. If the expression in the list parameter does not evaluate to a valid
list, a <LIST> error occurs. If a valid list contains no data at the specified
position, $LISTDATA returns 0.
position
The integer position of the element in the list, counting from 1. If you omit
the position parameter, $LISTDATA evaluates the first element. If the value of
the position parameter is -1, it is equivalent to specifying the final element
of the list.
$LISTDATA returns 0 if position refers to a nonexistent list member. A position
of 0 always returns 0. If the value of position is less than -1, invoking the 
$LISTDATA function generates a <RANGE> error.
Examples
The following examples show the results of the various values of the position
parameter.
All of the following $LISTDATA statements return a value of 0:

   KILL Y
   SET X=$LISTBUILD("Red",,Y,"","Green")
   WRITE !,$LISTDATA(X,2) ; second element is undefined
   WRITE !,$LISTDATA(X,3) ; third element is killed variable
   WRITE !,$LISTDATA(X,0) ; the 0th position
   WRITE !,$LISTDATA(X,6) ; 6th position in 5-element list
The following $LISTDATA statements return a value of 1 for the same
five-element list:

   SET X=$LISTBUILD("Red",,Y,"","Green")
   WRITE !,$LISTDATA(X)    ; first position (by default)
   WRITE !,$LISTDATA(X,1)  ; first position specified
   WRITE !,$LISTDATA(X,4)  ; fourth position value=null string
   WRITE !,$LISTDATA(X,5)  ; fifth position
   WRITE !,$LISTDATA(X,-1) ; last (5th) position
All of the following $LISTDATA statements return a value of 0:

   WRITE !,$LISTDATA($LB())     ; null list
   WRITE !,$LISTDATA($LB(NULL)) ; null list
   WRITE !,$LISTDATA("")        ; null string is a valid list
                                ; but contain no data
   WRITE !,$LISTDATA($LB(,))    ; two-element null list
The following $LISTDATA statements return a value of 1:

  WRITE !,$LISTDATA($LB(""))       ; data is null string
  WRITE !,$LISTDATA($LB($CHAR(0))) ; data is non-display character
See Also

  • $LIST function
  • $LISTBUILD function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT
  • $LISTSAME function
  • $LISTTOSTRING function
  • $LISTVALID function


 #}}}
*$LISTFIND*  #{{{

Searches a specified list for the requested value.
Synopsis

$LISTFIND(list,value,startafter)
$LF(list,value,startafter)

Parameters

            An expression that evaluates to a valid list. A list is an encoded
list        string containing one or more elements. A list must be created
            using $LISTBUILD or $LISTFROMSTRING, or extracted from another list
            using $LIST.

value       An expression containing the desired element value.

            Optional  An integer expression interpreted as a list position. The
            search starts with the element after this position; thus 0 means to
startafter  start with position 1, 1 means to start with position 2. startafter
            =-1 is a valid value, but always returns no match. Only the integer
            portion of the startafter value is used.

Description
$LISTFIND searches the specified list for the first instance of the requested 
value. A match must be exact and consist of the full element value. Letter
comparisons are case-sensitive. Numbers are compared in canonical form. If an
exact match is found, $LISTFIND returns the position of the matching element.
If value is not found, $LISTFIND returns a 0.
The search begins with the element after the position indicated by the 
startafter parameter. If you omit the startafter parameter, $LISTFIND assumes a
startafter value of 0 and starts the search with the first element (element 1).
If no match is found, $LISTFIND returns a 0. $LISTFIND will also return a 0 if
the value of the startafter parameter refers to a nonexistent list member.
You can use the $LISTVALID function to determine if list is a valid list. If 
list is not a valid list, Caché generates a <LIST> error.
If the value of the startafter parameter is less than -1, invoking the 
$LISTFIND function generates a <RANGE> error.
Empty Strings and Empty Lists
The $LISTFIND function can be used to locate an empty string value, as shown in
the following example:

   SET x=$LISTBUILD("A","","C","D")
   WRITE $LISTFIND(x,"")   ; returns 2
$LISTFIND can be used with lists containing omitted elements, but cannot be
used to locate an omitted element. The following example finds a value in a
list with omitted elements:

   SET x=$LISTBUILD("A",,"C","D")
  WRITE $LISTFIND(x,"C")   ; returns 3
The following $LISTFIND example returns 1:

  WRITE $LISTFIND($LB(""),"")   ; returns 1
The following $LISTFIND examples returns 0:

  WRITE $LISTFIND("",""),!     ; returns 0
  WRITE $LISTFIND($LB(),""),!  ; returns 0
The following examples list consists of an empty list concatenated to a list
containing data. Appending the empty list changes the list position of elements
in the resulting concatenated list:

   SET x=$LISTBUILD("A","B","C","D")
   WRITE $LISTFIND(x,"B"),!         ; returns 2
   WRITE $LISTFIND(""_x,"B"),!      ; returns 2
   WRITE $LISTFIND($LB()_x,"B"),!   ; returns 3
   WRITE $LISTFIND($LB(,,,)_x,"B")  ; returns 6
However, concatenating a null string to value has no effect on $LISTFIND:

   SET x=$LISTBUILD("A","B","C","D")
   WRITE $LISTFIND(x,"B"),!      ; returns 2
   WRITE $LISTFIND(x,"B"_""),!   ; returns 2
   WRITE $LISTFIND(x,""_"B"),!   ; returns 2
Examples
The following example returns 2, the position of the first occurrence of the
requested string:

   SET x=$LISTBUILD("A","B","C","D")
   WRITE $LISTFIND(x,"B")
The following example returns 0, indicating the requested string was not found:

   SET x=$LISTBUILD("A","B","C","D")
   WRITE $LISTFIND(x,"E")
The following examples show the effect of using the startafter parameter. The
first example does not find the requested string and returns 0 because the
string occurs at the startafter position:

   SET x=$LISTBUILD("A","B","C","D")
   WRITE $LISTFIND(x,"B",2)
The second example finds the second occurrence of the requested string and
returns 4, because the first occurs before the startafter position:

   SET y=$LISTBUILD("A","B","C","A")
   WRITE $LISTFIND(y,"A",2)
The $LISTFIND function only matches complete elements. Thus, the following
example returns 0 because no element of the list is equal to the string  B ,
though all of the elements contain  B :

   SET mylist = $LISTBUILD("ABC","BCD","BBB")
   WRITE $LISTFIND(mylist,"B")
The following numeric examples all return 0, because numbers are converted to
canonical form before matching. In these cases, the string numeric value and
the canonical form number do not match:

   SET y=$LISTBUILD("1.0","+2","003","2*2")
   WRITE $LISTFIND(y,1.0),!
   WRITE $LISTFIND(y,+2),!
   WRITE $LISTFIND(y,003),!
   WRITE $LISTFIND(y,4)
The following numeric examples match because numeric values are compared in
their canonical forms:

   SET y=$LISTBUILD(7.0,+6,005,2*2)
   WRITE $LISTFIND(y,++7.000),!   ; returns 1
   WRITE $LISTFIND(y,0006),!      ; returns 2
   WRITE $LISTFIND(y,8-3),!       ; returns 3
   WRITE $LISTFIND(y,--4.0)       ; returns 4
The following examples all return 0, because the specified startafter value
results in no match:

   SET y=$LISTBUILD("A","B","C","D")
   WRITE $LISTFIND(y,"A",1),!
   WRITE $LISTFIND(y,"B",2),!
   WRITE $LISTFIND(y,"B",99),!
   WRITE $LISTFIND(y,"B",-1)
The following example shows how $LISTFIND can be used to find a nested list.
Note that Caché treats a multi-element nested list as a single list element
with a list value:

   SET y=$LISTBUILD("A",$LB("x","y"),"C","D")
   WRITE $LISTFIND(y,$LB("x","y"))
See Also

  • $LIST function
  • $LISTBUILD function
  • $LISTDATA function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT
  • $LISTSAME function
  • $LISTTOSTRING function
  • $LISTVALID function


 #}}}
*$LISTFROMSTRING*  #{{{

Creates a list from a string.
Synopsis

$LISTFROMSTRING(string,delimiter)
$LFS(string,delimiter)

Parameters

           A string to be converted into a Caché list. This string contains one
string     or more elements, separated by a delimiter. The delimiter does not
           become part of the resulting Caché list.

           Optional  The delimiter used to separate substrings (elements) in 
delimiter  string. Specify delimiter as a quoted string. If no delimiter is
           specified, the default is the comma (,) character.

Description
$LISTFROMSTRING takes a quoted string containing delimited elements and returns
a list. A list represents data in an encoded format which does not use
delimiter characters. Thus a list can contain all possible characters, and is
ideally suited for bitstring data. Lists are handled using the Caché
ObjectScript $LIST functions.
Parameters
string
A string literal (enclosed in quotation marks), a numeric, or a variable or
expression that evaluates to a string. This string can contain one or more
substrings (elements), separated by a delimiter. The string data elements must
not contain the delimiter character (or string), because the delimiter
character is not included in the output list.
delimiter
A character (or string of characters) used to delimit substrings within the
input string. It can be a numeric or string literal (enclosed in quotation
marks), the name of a variable, or an expression that evaluates to a string.
Commonly, a delimiter is a designated character which is never used within
string data, but is set aside solely for use as a delimiter separating
substrings. A delimiter can also be a multi-character string, the individual
characters of which can be used within string data.
If you specify no delimiter, the default delimiter is the comma (,) character.
You cannot specify a null string ("") as a delimiter; attempting to do so
results in a <STRINGSTACK> error.
Example
The following example takes a string of names which are separated by a blank
space, and creates a list:

   SET namestring="Deborah Noah Martha Bowie"
   SET namelist=$LISTFROMSTRING(namestring," ")
   WRITE !,"1st element: ",$LIST(namelist,1)
   WRITE !,"2nd element: ",$LIST(namelist,2)
   WRITE !,"3rd element: ",$LIST(namelist,3)
See Also

  • $LISTTOSTRING function
  • $LISTBUILD function
  • $LIST function
  • $PIECE function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT function
  • $LISTSAME function
  • $LISTVALID function


 #}}}
*$LISTGET*  #{{{

Returns an element in a list, or a specified default value if the requested
element is undefined.
Synopsis

$LISTGET(list,position,default)
$LG(list,position,default)

Parameters

list      An expression that evaluates to a valid list.

position  Optional  An expression interpreted as a position in the specified
          list.

default   Optional  An expression that provides the value to return if the list
          element has an undefined value.

Description
$LISTGET returns the requested element in the specified list. If the value of
the position parameter refers to a nonexistent member or identifies an element
with an undefined value, the specified default value is returned.
The $LISTGET function is identical to the one- and two-argument forms of the 
$LIST function except that, under conditions that would cause $LIST to produce
a <NULL VALUE> error, $LISTGET returns a default value. See the description of
the $LIST function for more information on conditions that generate <NULL
VALUE> errors.
Parameters
list
A list can be created using $LISTBUILD or $LISTFROMSTRING, or extracted from
another list using $LIST. The null string ("") is also treated as a valid list.
You can use $LISTVALID to determine if list is a valid list. An invalid list
causes $LISTGET to generate a <LIST> error.
position
The position parameter evaluates to an integer. Caché truncates a fractional
number to its integer portion. A value of 1 returns the first element of the
list. If position is omitted, $LISTGET returns the first element of the list.
If the value of position is an integer higher than the number of elements in
the list, or is 0, $LISTGET returns the default value. If the value of position
is -1, it is equivalent to specifying the last element of the list. If the
value of position is less than -1, invoking the $LISTGET function generates a
<RANGE> error.
default
You must specify a position parameter value to specify a default value. If you
omit the default parameter, the null string ("") is returned as the default
value.
Examples
The $LISTGET functions in the following example return the value of the list
element specified by position (the position default is 1):

   SET list=$LISTBUILD("A","B","C")
   WRITE !,$LISTGET(list)    ; returns "A"
   WRITE !,$LISTGET(list,1)  ; returns "A"
   WRITE !,$LISTGET(list,3)  ; returns "C"
   WRITE !,$LISTGET(list,-1) ; returns "C"
The $LISTGET functions in the following example both return a value upon
encountering the undefined 2nd element in the list. The first returns a
question mark (?), which the user defined as the default value. The second
returns a null string because a default parameter is not specified:

   WRITE "returns:",$LISTGET($LISTBUILD("A",,"C"),2,"?"),!
   WRITE "returns:",$LISTGET($LISTBUILD("A",,"C"),2)
The following example returns all of the element values in the list. Where a
value is omitted, it returns the default value:

   SET list=$LISTBUILD("a","b",,"d",,,"g")
   SET llen=$LISTLENGTH(list)
      FOR x=1:1:llen {
      WRITE $LISTGET(list,x,"no value"),!
      }
      WRITE "end of the list"
The $LISTGET functions in the following example both specify a position greater
than the last element in the three-element list. The first returns a null
string because the default parameter is not specified. The second returns the
user-specified default value,  ERR :

   SET list=$LISTBUILD("A","B","C")
   WRITE "returns:",$LISTGET(list,4),!
   WRITE "returns:",$LISTGET(list,4,"ERR")
The $LISTGET functions in the following example all return the default value:

   SET list=$LISTBUILD("A","B","C")
   WRITE $LISTGET(list,0,"no value"),!
   WRITE $LISTGET("",1,"no value"),!
   WRITE $LISTGET($LB(),1,"no value"),!
   WRITE $LISTGET($LB(NULL),1,"no value"),!
   WRITE $LISTGET($LB(,),1,"no value")
The following example returns the list value of null string; it does not return
the default value:

    WRITE "returns:",$LISTGET($LB(""),1,"no value")
See Also

  • $LIST function
  • $LISTBUILD function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTLENGTH function
  • $LISTNEXT
  • $LISTSAME function
  • $LISTTOSTRING function
  • $LISTVALID function


 #}}}
*$LIST*  #{{{

Returns or replaces elements in a list.
Synopsis

$LIST(list,position,end)
$LI(list,position,end)

SET $LIST(list,position,end)=value
SET $LI(list,position,end)=value

Parameters

          An expression that evaluates to a valid list. Because lists contain
list      encoding, list must be created using $LISTBUILD or $LISTFROMSTRING,
          or extracted from another list using $LIST.

          Optional  The starting position in the specified list. An expression
position  that evaluates to a non-zero integer. Use  1 to specify the last
          element in the list.

          Optional  The ending position in the specified list. An expression
end       that evaluates to an integer. Use  1 to specify the last element in
          the list.

Description
$LIST can be used in two ways:

  • To return an element (or elements) from list. Which element is determined
    by specifying a position element count. This uses the 
    $LIST(list,position,end) syntax.
  • To replace an element (or elements) within list. The replacement element
    may be the same length, longer, or shorter than the original element. The
    element is determined by specifying a position element count. This uses the
    SET $LIST(list,position,end)=value syntax.

$LIST returns (or replaces) list elements. The elements returned depend on the
parameters used.

  • $LIST(list) returns the first element in the list.
  • $LIST(list,position) returns the element indicated by the specified
    position. The position parameter must evaluate to an integer.
  • $LIST(list,position,end) returns a  sublist (an encoded list string)
    containing the elements of the list from the specified start position
    through the specified end position.

You can also use $LISTNEXT to sequentially return elements from a list.
Parameters
list
An encoded list string containing one or more elements. Lists can be created
using $LISTBUILD or $LISTFROMSTRING, or extracted from another list by using
the $LIST function. The following are valid list arguments:

   SET myList = $LISTBUILD("Red", "Blue", "Green", "Yellow")
   WRITE !,$LIST(myList,2)   ; prints Blue
   SET subList = $LIST(myList,2,4)
   WRITE !,$LIST(subList,2)  ; prints Green
In the following example, subList is not a valid list argument, because it is a
single element returned as an ordinary string, not an encoded list string:

   SET myList = $LISTBUILD("Red", "Blue", "Green", "Yellow")
   SET subList = $LIST(myList,2)
   WRITE $LIST(subList,1)

position
The position (element count) of the list element to return (or replace). List
elements are counted from 1. If position is omitted, the first element is
returned. If the value of position is 0 or greater than the number of elements
in the list, Caché issues a <NULL VALUE> error. If the value of position is
negative one ( 1), $LIST returns the final element in the list. If position is
a fractional number, it is truncated to its integer part.
If the end parameter is specified, position specifies the first element in a
range of elements. Even when only one element is returned (when position and 
end are the same number) this value is returned as an encoded list string.
Thus, $LIST(x,2) is not identical to $LIST(x,2,2).
end
The position of the last element in a range of elements, specified as an
integer. You must specify position to specify end. If end is a fractional
number, it is truncated to its integer part.
When end is specified, the value returned is an encoded list string. Because of
this encoding, such strings should only be processed by other $LIST functions.
If the value of end is:

  • greater than position, an encoded string containing a list of elements is
    returned.
  • equal to position, an encoded string containing the one element is
    returned.
  • less than position, the null string ("") is returned.
  • greater than the number of elements in list, it is equivalent to specifying
    the final element in the list.
  • negative one ( 1), it is equivalent to specifying the final element in the
    list.

When specifying end, you can specify a position value of zero (0). In this
case, 0 is equivalent to 1.
$LIST Errors
The following $LIST parameter values generate an error:

  • If the list parameter does not evaluate to a valid list, $LIST generates a
    <LIST> error. You can use the $LISTVALID function to determine if a list is
    valid.
  • If the list parameter evaluate to a valid list that contains a null value,
    or concatenates a list and a null value, $LIST generates a <NULL VALUE>
    error. All of the following are valid lists (according to $LISTVALID) for
    which $LIST generate a <NULL VALUE> error:
   
      WRITE $LIST(""),!
      WRITE $LIST($LB()),!
      WRITE $LIST($LB(NULL)),!
      WRITE $LIST($LB(,))
      WRITE $LIST($LB()_$LB("a","b","c"))

  • If the position parameter is 0 or a fractional number less than 1 and no 
    end parameter is used, $LIST generates a <NULL VALUE> error.
  • If the value of the position parameter refers to a nonexistent list member
    and no end parameter is used, $LIST generates a <NULL VALUE> error.
   
       SET list2=$LISTBUILD("Brown","Black")
       WRITE $LIST(list2,3) ; generates a NULL VALUE error

  • If the value of the position parameter identifies an element with an
    undefined value, and no end parameter is used, $LIST generates a <NULL
    VALUE> error.
   
       SET list3=$LISTBUILD("A",,"C")
       ZZDUMP $LIST(list3,2)  ; generates a NULL VALUE error

  • If the value of the position parameter or the end parameter is less than
    -1, $LIST generates a <RANGE> error.

SET $LIST
You can use $LIST with the SET command to replace a specified element in a list
with another element value. You can perform the following operations:

  • Replace one element value with a new value:
   
      SET $LIST(fruit,2)="orange"

  • Replace a range of element values with the same number of new values:
   
      SET $LIST(fruit,2,3)=$LISTBUILD("orange","banana")

  • Replace a range of element values with a larger or smaller number of new
    values:
   
      SET $LIST(fruit,2,3)=$LISTBUILD("orange","banana","peach")

  • Remove an element or a range of element values:
   
      SET $LIST(fruit,2,3)=""

The following example shows SET $LIST replacing the second element:

   SET fruit=$LISTBUILD("apple","onion","banana","pear")
   WRITE !,$LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,2)="orange"
   WRITE !,$LISTTOSTRING(fruit,"/")
The following example shows SET $LIST replacing the second and third elements:

   SET fruit=$LISTBUILD("apple","potato","onion","pear")
   WRITE !,$LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,2,3)=$LISTBUILD("orange","banana")
   WRITE !,$LISTTOSTRING(fruit,"/")
The following example shows SET $LIST replacing the second and third elements
with four elements:

   SET fruit=$LISTBUILD("apple","potato","onion","pear")
   WRITE !,$LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,2,3)=$LISTBUILD("orange","banana","peach","tangerine")
   WRITE !,$LISTTOSTRING(fruit,"/")
The following four examples show SET $LIST replacing the final element in the
list. Note that SET $LIST(x,-1) and SET $LIST(x,-1,-1) perform different
operations: SET $LIST(x,-1) replaces the value of the last element; 
SET $LIST(x,-1,-1) deletes the last element, then appends the specified list.
To replace the final element with a single value, use SET $LIST(x,-1):

   SET fruit=$LISTBUILD("apple","orange","banana","pear","potato")
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,-1)="peach"
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
To remove the final element of a list, use SET $LIST(x,-1,-1):

   SET fruit=$LISTBUILD("apple","orange","banana","pear","potato")
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,-1,-1)=""
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
To replace the final element with a list of elements, use SET $LIST(x,-1,-1):

   SET fruit=$LISTBUILD("apple","orange","banana","pear","potato")
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,-1,-1)=$LISTBUILD("peach","plum","quince")
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
To replace the final element with a sublist, use SET $LIST(x,-1):

   SET fruit=$LISTBUILD("apple","orange","banana","pear","potato")
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,-1)=$LISTBUILD("peach","plum","quince")
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
The following example shows SET $LIST removing elements from the list,
beginning with the third element through the end of the list:

   SET fruit=$LISTBUILD("apple","orange","onion","peanut","potato")
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
   SET $LIST(fruit,3,-1)=""
   WRITE !,"list length is ",$LISTLENGTH(fruit)," "
   WRITE $LISTTOSTRING(fruit,"/")
Examples
The following two WRITE statements both return  RED , the first element in the
list. The first writes the first element by default, the second writes the
first element because the position parameter is set to 1:

   WRITE !,$LIST($LISTBUILD("RED","BLUE","GREEN"))
   WRITE !,$LIST($LISTBUILD("RED","BLUE","GREEN"),1)
The following example returns  Blue , the second element in the list:

   SET X=$LISTBUILD("Red","Blue","Green")
   WRITE $LIST(X,2)
The following example returns  Red Blue , a two-element list string beginning
with the first element and ending with the second element in the list. ZZDUMP
is used rather than WRITE, because a list string contains special (nonprinting)
encoding characters:

   SET X=$LISTBUILD("Red ","Blue ","Green ")
   ZZDUMP $LIST(X,1,2)
The following example returns  Brown Black , a two-element list string that
begins with the third element and ends with the last element in the list:

   SET X=$LISTBUILD("Green ","White ","Brown ","Black ")
   SET LIST2=$LIST(X,3,-1)
   ZZDUMP LIST2
Notes
Two-Parameter and Three-Parameter $LIST
$LIST(list,1) is not equivalent to $LIST(list,1,1) because the former returns a
string, while the latter returns a single-element list string. Furthermore, the
first can receive a <NULL VALUE> error, whereas the second cannot; if there are
no elements to return, it returns a null string.
Unicode
If one Unicode character appears in a list element, that entire list element is
represented as Unicode (wide) characters. Other elements in the list are not
affected.
The following example shows two lists. The y list consists of two elements
which contain only ASCII characters. The z list consists of two elements: the
first element contains a Unicode character ($CHAR(960) = the pi symbol); the
second element contains only ASCII characters.

   SET y=$LISTBUILD("ABC"_$CHAR(68),"XYZ")
   SET z=$LISTBUILD("ABC"_$CHAR(960),"XYZ")
   WRITE !,"The ASCII list y elements: "
   ZZDUMP $LIST(y,1)
   ZZDUMP $LIST(y,2)
   WRITE !,"The Unicode list z elements: "
   ZZDUMP $LIST(z,1)
   ZZDUMP $LIST(z,2)
Note that Caché encodes the first element of z entirely in wide Unicode
characters. The second element of z contains no Unicode characters, and thus
Caché encodes it using narrow ASCII characters.
$LIST Compared with $EXTRACT and $PIECE
$LIST determines an element from an encoded list by counting elements (not
characters) from the beginning of the list.
$EXTRACT determines a substring by counting characters from the beginning of a
string. $EXTRACT takes as input an ordinary character string.
$PIECE determines a substring by counting user-defined delimiter characters
within the string. $PIECE takes as input an ordinary character string
containing multiple instances of a character (or string) intended for use as a
delimiter.
$LIST cannot be used on ordinary strings. $PIECE and $EXTRACT cannot be used on
encoded lists.
See Also

  • $LISTBUILD function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT
  • $LISTSAME function
  • $LISTTOSTRING function
  • $LISTVALID function


 #}}}
*$LISTLENGTH*  #{{{

Returns the number of elements in a specified list.
Synopsis

$LISTLENGTH(list)
$LL(list)

Parameter

      Any expression that evaluates to a list. A list can be created using 
list  $LISTBUILD or $LISTFROMSTRING, or extracted from another list using $LIST
      .

Description
$LISTLENGTH returns the number of elements in list. $LISTLENGTH counts as a
list element every designated list position, whether or not that position
contains data.
You can use the $LISTVALID function to determine if list is a valid list. If 
list is not a valid list, Caché generates a <LIST> error.
Examples
The following example returns 3, because there are 3 elements in the list:

   WRITE $LISTLENGTH($LISTBUILD("Red","Blue","Green"))
The following example also returns 3, even though the second element in the
list is omitted:

   WRITE $LISTLENGTH($LISTBUILD("Red",,"Green"))
The following examples all return 1. $LISTLENGTH makes no distinction between
an empty list element and a list element containing data:

  WRITE $LISTLENGTH($LB()),!
  WRITE $LISTLENGTH($LB(NULL)),!
  WRITE $LISTLENGTH($LB("")),!
  WRITE $LISTLENGTH($LB($CHAR(0))),!
  WRITE $LISTLENGTH($LB("John Smith"))
The following example returns 0. $LISTVALID considers the null string a valid
list, but it contains no list elements:

   WRITE $LISTLENGTH("")
The following example returns 3, because the two placeholder commas represent 3
null list elements:

   WRITE $LISTLENGTH($LB(,,))
$LISTLENGTH and Concatenation
Concatenating two lists always results in a $LISTLENGTH equal to the sum of the
lengths of the lists. This is true even when concatenating empty lists, or
concatenating a null string to a list.
The following example all return a list length of 3:

  WRITE $LISTLENGTH($LB()_$LB("a","b")),!
  WRITE $LISTLENGTH($LB("a")_$LB(NULL)_$LB("c")),!
  WRITE $LISTLENGTH($LB("")_$LB()_$LB(NULL)),!
  WRITE $LISTLENGTH(""_$LB("a","b","c")),!
  WRITE $LISTLENGTH($LB("a","b")_""_$LB("c"))
$LISTLENGTH and Nested Lists
The following example returns 3, because $LISTLENGTH does not recognize the
individual elements in a nested list, and treats it as a single list element:

   WRITE $LISTLENGTH($LB("Apple","Pear",$LB("Walnut","Pecan")))
The following examples all return 1, because $LISTLENGTH counts only the
outermost nested list:

   WRITE $LISTLENGTH($LB($LB($LB()))),!
   WRITE $LISTLENGTH($LB($LB($LB("Fred")))),!
   WRITE $LISTLENGTH($LB($LB("Barney"_$LB("Fred")))),!
   WRITE $LISTLENGTH($LB("Fred"_$LB("Barney"_$LB("Wilma"))))
See Also

  • $LIST function
  • $LISTBUILD function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTNEXT
  • $LISTSAME function
  • $LISTTOSTRING function
  • $LISTVALID function


 #}}}
*$LISTNEXT*  #{{{

Retrieves elements sequentially from a list.
Synopsis

$LISTNEXT(list,ptr,value)

Parameters

list   Any expression that evaluates to a list.

       A pointer to the next element in the list. You must specify ptr as a
       local variable initialized to 0. This value points to the beginning of 
ptr    list. Caché increments ptr using an internal address value algorithm (
       not a predictable integer counter). Therefore, the only value you can
       use to set ptr is 0. ptr cannot be a global variable or a subscripted
       variable.

       A local variable used to hold the data value of a list element. value
value  does not have to be initialized before invoking $LISTNEXT. value cannot
       be a global variable or a subscripted variable.

Description
$LISTNEXT sequentially returns elements in a list. You initialize ptr to 0
before the first invocation of $LISTNEXT. This causes $LISTNEXT to begin
returning elements from the beginning of the list. Each successive invocation
of $LISTNEXT advances ptr and returns the next list element value to value. The
$LISTNEXT function returns 1, indicating that a list element has been
successfully retrieved.
When $LISTNEXT reaches the end of the list, it returns 0, resets ptr to 0, and
leaves value unchanged from the previous invocation. Because ptr has been reset
to 0, the next invocation of $LISTNEXT would start at the beginning of the
list.
You can use $LISTVALID to determine if list is a valid list. An invalid list
causes $LISTNEXT to generate a <LIST> error.
Not all lists validated by $LISTVALID can be used successfully with $LISTNEXT.
When $LISTNEXT encounters a list element with a null value, it returns 1
indicating that a list element has been successfully retrieved, advances ptr to
the next element, and resets value to be an undefined variable. This can happen
with any of the following valid lists: value=$LB(), value=$LB(NULL), value=$LB
(,), or when encountering an omitted list element, such as the second
invocation of $LISTNEXT on value=$LB("a",,"b").
$LISTNEXT("",ptr,value) returns 0, and does not advance the pointer or set 
value. $LISTNEXT($LB(""),ptr,value) returns 1, advances the pointer, and set 
value to the null string ("").
$LISTNEXT and Nested Lists
The following example returns three elements, because $LISTNEXT does not
recognize the individual elements in nested lists:

   SET list=$LISTBUILD("Apple","Pear",$LISTBUILD("Walnut","Pecan"))
   SET ptr=0,count=0
   WHILE $LISTNEXT(list,ptr,value) {
    SET count=count+1
    WRITE !,value }
   WRITE !,"End of list: ",count," elements found"
   QUIT
Examples
The following example sequentially returns all the elements in the list:

   SET list=$LISTBUILD("Red","Blue","Green")
   SET ptr=0,count=0
   WHILE $LISTNEXT(list,ptr,value) {
    SET count=count+1
   WRITE !,value }
   WRITE !,"End of list: ",count," elements found"
   QUIT
See Also

  • $LIST function
  • $LISTBUILD function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTSAME function
  • $LISTTOSTRING function
  • $LISTVALID function


 #}}}
*$LISTSAME*  #{{{

Compares two lists and returns a boolean value.
Synopsis

$LISTSAME(list1,list2)
$LS(list1,list2)

Parameters

       Any expression that evaluates to a list. A list can be created using 
list1  $LISTBUILD or $LISTFROMSTRING, or extracted from another list using 
       $LIST. The null string ("") is also treated as a valid list.

       Any expression that evaluates to a list. A list can be created using 
list2  $LISTBUILD or $LISTFROMSTRING, or extracted from another list using 
       $LIST. The null string ("") is also treated as a valid list.

Description
$LISTSAME compares the contents of two lists and returns 1 if the lists are
identical. If the lists are not identical, $LISTSAME returns 0. $LISTSAME
compares list elements using their string representations. $LISTSAME
comparisons are case-sensitive.
$LISTSAME compares the two lists element-by-element in left-to-right order.
Therefore $LISTSAME returns a value of 0 when it encounters the first
non-identical pair of list elements; it does not check subsequent items to
determine if they are valid list elements. If a $LISTSAME comparison encounters
an invalid item, it issues a <LIST> error.
Examples
The following example returns 1, because the two lists are identical:

   SET x = $LISTBUILD("Red","Blue","Green")
   SET y = $LISTBUILD("Red","Blue","Green")
   WRITE $LISTSAME(x,y)
The following example returns 0, because the two lists are not identical:

   SET x = $LISTBUILD("Red","Blue","Yellow")
   SET y = $LISTBUILD("Red","Yellow","Blue")
   WRITE $LISTSAME(x,y)
Identical Lists
$LISTSAME considers two lists to be identical if the string representations of
the two lists are identical. When comparing a numeric list element and a string
list element, note that the numeric is stored in canonical form; it is the
canonical form number that $LISTSAME compared as a string. In the following
example, $LISTSAME compares a string and a numeric. The first three $LISTSAME
functions return 1 (identical); the fourth $LISTSAME function returns 0 (not
identical):

  WRITE $LISTSAME($LISTBUILD("365"),$LISTBUILD(365)),!
  WRITE $LISTSAME($LISTBUILD("365"),$LISTBUILD(365.0)),!
  WRITE $LISTSAME($LISTBUILD("365.5"),$LISTBUILD(365.5)),!
  WRITE $LISTSAME($LISTBUILD("365.0"),$LISTBUILD(365.0))
$LISTSAME comparison is not the same equivalence test as the one used by other
list operations, which test using the internal representation of a list. This
distinction is easily seen when comparing a number and a numeric string, as in
the following example:

   SET x = $LISTBUILD("365")
   SET y = $LISTBUILD(365)
   IF x=y
     { WRITE !,"Equal sign: number/numeric string identical" }
   ELSE { WRITE !,"Equal sign: number/numeric string differ" }
   IF 1=$LISTSAME(x,y)
     { WRITE !,"$LISTSAME: number/numeric string identical" }
   ELSE { WRITE !,"$LISTSAME: number/numeric string differ" }
The equality (=) comparison tests the internal representations of these lists
(which are not identical). $LISTSAME performs a string conversion on both
lists, compares them, and finds them identical.
The following example shows two lists with various representations of numeric
elements. $LISTSAME considers these two lists to be identical:

   SET x = $LISTBUILD("360","361","362","363","364","365","366")
   SET y = $LISTBUILD(00360.000,(19*19),+"362",363,364.0,+365,"3"_"66")
   WRITE !,$LISTSAME(x,y)," lists are identical"
Numeric Maximum
A number larger than 2**63 (9223372036854775810) or smaller than -2**63 ( 
9223372036854775808) exceeds the maximum numeric range for $LISTSAME list
comparison. $LISTSAME returns 0 when such extremely large numbers are compared,
as shown in the following example:

  SET bignum=$LISTBUILD(9223372036854775810)
  SET bigstr=$LISTBUILD("9223372036854775810")
  WRITE $LISTSAME(bignum,bigstr),!
  SET bignum=$LISTBUILD(9223372036854775811)
  SET bigstr=$LISTBUILD("9223372036854775811")
  WRITE $LISTSAME(bignum,bigstr)
Null String and Null List
A list containing the null string (an empty string) as its sole element is a
valid list. The null string by itself is also considered a valid list. However
these two (a null string and a null list) are not considered identical, as
shown in the following example:

   WRITE !,$LISTSAME($LISTBUILD(""),$LISTBUILD(""))," null lists"
   WRITE !,$LISTSAME("","")," null strings"
   WRITE !,$LISTSAME($LISTBUILD(""),"")," null list and null string"
Normally, a string is not a valid $LISTSAME argument, and $LISTSAME issues a
<LIST> error. However, the following $LISTSAME comparisons complete
successfully and return 0 (values not identical). The null string and the
string  abc are compared and found not to be identical. These null string
comparisons do not issue a <LIST> error:

   WRITE !,$LISTSAME("","abc")
   WRITE !,$LISTSAME("abc","")
The following $LISTSAME comparisons do issue a <LIST> error, because a list
(even a null list) cannot be compared with a string:

   SET x = $LISTBUILD("")
   WRITE !,$LISTSAME("abc",x)
   WRITE !,$LISTSAME(x,"abc")
Comparing “Empty” Lists
$LISTVALID considers all of the following as valid lists:

  WRITE $LISTVALID(""),!
  WRITE $LISTVALID($LB()),!
  WRITE $LISTVALID($LB(NULL)),!
  WRITE $LISTVALID($LB("")),!
  WRITE $LISTVALID($LB($CHAR(0))),!
  WRITE $LISTVALID($LB(,))
$LISTSAME considers only the following pairs as identical:

  WRITE $LISTSAME($LB(),$LB(NULL)),!
  WRITE $LISTSAME($LB(,),$LB(NULL,NULL)),!
  WRITE $LISTSAME($LB(,),$LB()_$LB())
Empty Elements
A $LISTBUILD can create empty elements by including extra commas between
elements or appending one or more commas to either end of the element list. 
$LISTSAME is aware of empty elements, and does not treat them as equivalent to
null string elements.
The following $LISTSAME examples all return 0 (not identical):

  WRITE $LISTSAME($LISTBUILD(365,,367),$LISTBUILD(365,367)),!
  WRITE $LISTSAME($LISTBUILD(365,366,),$LISTBUILD(365,366)),!
  WRITE $LISTSAME($LISTBUILD(365,366,,),$LISTBUILD(365,366,)),!
  WRITE $LISTSAME($LISTBUILD(365,,367),$LISTBUILD(365,"",367))
$DOUBLE List Elements
$LISTSAME considers all forms of zero to be identical: 0,  0, $DOUBLE(0), and
$DOUBLE(-0).
$LISTSAME considers a $DOUBLE( NAN ) list element to be identical to another
$DOUBLE( NAN ) list element. However, because NAN (Not A Number) cannot be
meaningfully compared using numerical operators, Caché operations (such as
equal to, less than, or greater than) that attempt to compare $DOUBLE( NAN ) to
another $DOUBLE( NAN ) fail, as shown in the following example:

   SET x = $DOUBLE("NAN")
   SET a = $LISTBUILD(1,2,x)
   SET b = $LISTBUILD(1,2,x)
   WRITE !,$LISTSAME(a,b)    /* 1 (NAN list elements same) */
   WRITE !,x=x               /* 0 (NAN values not equal)   */
Nested and Concatenated Lists
$LISTSAME does not support nested lists. It cannot compare two lists that
contain lists, even if their contents are identical.

   SET x = $LISTBUILD("365")
   SET y = $LISTBUILD(365)
   WRITE !,$LISTSAME(x,y)," lists identical"
   WRITE !,$LISTSAME($LISTBUILD(x),$LISTBUILD(y))," nested lists not identical"
In the following example, both $LISTSAME comparisons returns 0, because these
lists are not considered identical:

   SET x=$LISTBUILD("Apple","Pear","Walnut","Pecan")
   SET y=$LISTBUILD("Apple","Pear",$LISTBUILD("Walnut","Pecan"))
   SET z=$LISTBUILD("Apple","Pear","Walnut","Pecan","")
   WRITE !,$LISTSAME(x,y)," nested list"
   WRITE !,$LISTSAME(x,z)," null string is list item"
$LISTSAME does support concatenated lists. The following example returns 1,
because the lists are considered identical:

   SET x=$LISTBUILD("Apple","Pear","Walnut","Pecan")
   SET y=$LISTBUILD("Apple","Pear")_$LISTBUILD("Walnut","Pecan")
   WRITE !,$LISTSAME(x,y)," concatenated list"
See Also

  • $LIST function
  • $LISTBUILD function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT function
  • $LISTTOSTRING function
  • $LISTVALID function
  • $DOUBLE function


 #}}}
*$LISTTOSTRING*  #{{{

Creates a string from a list.
Synopsis

$LISTTOSTRING(list,delimiter,flag)
$LTS(list,delimiter,flag)

Parameters

list       A Caché list, created using $LISTBUILD or $LISTFROMSTRING, or
           extracted from another list using $LIST.

           Optional  A delimiter used to separate substrings. Specify delimiter
delimiter  as a quoted string. If no delimiter is specified, the default is the
           comma (,) character.

           Optional  A boolean value that specifies how to handle an omitted
flag       list element. 0 issues a <NULL VALUE> error. 1 inserts an empty
           string for the element. The default is 0.

Description
$LISTTOSTRING takes a Caché list and converts it to a string. In the resulting
string, the elements of the list are separated by the delimiter.
A list represents data in an encoded format which does not use delimiter
characters. Thus a list can contain all possible characters, and is ideally
suited for bitstring data. $LISTTOSTRING converts this list to a string with
delimited elements. It sets aside a specified character (or character string)
to serve as a delimiter. These delimited elements can be handled using the 
$PIECE function.
Note:
The delimiter specified here must not occur in the source data. Caché makes no
distinction between a character serving as a delimiter and the same character
as a data character.
Parameters
list
A Caché list, which contains one or more elements. A list is created using 
$LISTBUILD or extracted from another list using $LIST.
If the expression in the list parameter does not evaluate to a valid list, a
<LIST> error occurs.

   SET x=$CHAR(0,0,0,1,16,27,134,240)
   SET a=$LISTTOSTRING(x,",")   // generates a <LIST> error

delimiter
A character (or string of characters) used to delimit substrings within the
output string. It can be a numeric or string literal (enclosed in quotation
marks), the name of a variable, or an expression that evaluates to a string.
Commonly, a delimiter is a designated character which is never used within
string data, but is set aside solely for use as a delimiter separating
substrings. A delimiter can also be a multi-character string, the individual
characters of which can be used within string data.
If you specify no delimiter, the default delimiter is the comma (,) character.
You can specify a null string ("") as a delimiter; in this case, substrings are
concatenated with no delimiter. To specify a quote character as a delimiter,
specify the quote character twice ("""") or use $CHAR(34).
flag
A boolean flag used to specify how to handle omitted elements in list. In the
following example, the $LISTBUILD creates a list with an omitted element, and
the flag=1 option is specified to handle this list element:

  SET colorlist=$LISTBUILD("Red",,"Blue")
  WRITE $LISTTOSTRING(colorlist,,1)
If the flag option was omitted or set to 0, the $LISTTOSTRING would generate a
<NULL VALUE> error.
Note that if flag=1, an element with an empty string value is indistinguishable
from an omitted element. Thus $LISTBUILD("Red","","Blue") and 
$LISTBUILD("Red",,"Blue") would return the same $LISTTOSTRING value. This flag=
1 behavior is compatible with the implementation of $LISTTOSTRING in Caché SQL,
as described in the Caché SQL Reference.
Examples
The following example creates a list of four elements, then converts it to a
string with the elements delimited by the colon (:) character:

   SET namelist=$LISTBUILD("Deborah","Noah","Martha","Bowie")
   WRITE $LISTTOSTRING(namelist,":")
returns "Deborah:Noah:Martha:Bowie"
The following example creates a list of four elements, then converts it to a
string with the elements delimited by the *sp* string:

   SET namelist=$LISTBUILD("Deborah","Noah","Martha","Bowie")
   WRITE $LISTTOSTRING(namelist,"*sp*")
returns "Deborah*sp*Noah*sp*Martha*sp*Bowie"
The following example creates a list with one omitted element and one element
with an empty string value. $LISTTOSTRING converts it to a string with the
elements delimited by the colon (:) character. Because of the omitted element, 
flag=1 is required to avoid a <NULL VALUE> error. However, when flag=1, the
omitted element and the empty string value are indistinguishable:

   SET namelist=$LISTBUILD("Deborah",,"","Bowie")
   WRITE $LISTTOSTRING(namelist,":",1)
returns "Deborah:::Bowie"
$LISTVALID considers all of the following valid lists. With flag=1, 
$LISTTOSTRING returns the null string ("") for all of them:

  WRITE "1",$LISTTOSTRING("",,1),!
  WRITE "2",$LISTTOSTRING($LB(),,1),!
  WRITE "3",$LISTTOSTRING($LB(NULL),,1),!
  WRITE "4",$LISTTOSTRING($LB(""),,1)
With flag=0, $LISTTOSTRING returns the null string ("") for only the following:

  WRITE "1",$LISTTOSTRING("",,0),!
  WRITE "4",$LISTTOSTRING($LB(""),,0)
The others generate a <NULL VALUE> error.
See Also

  • $LISTFROMSTRING function
  • $LISTBUILD function
  • $LIST function
  • $PIECE function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT function
  • $LISTSAME function
  • $LISTVALID function


 #}}}
*$LISTVALID*  #{{{

Determines if an expression is a list.
Synopsis

$LISTVALID(exp)
$LV(exp)

Parameters

exp  Any valid expression.

Description
$LISTVALID determines whether exp is a list, and returns a Boolean value: If 
exp is a list, $LISTVALID returns 1; if exp is not a list, $LISTVALID returns
0.
A list can be created using $LISTBUILD or $LISTFROMSTRING, or extracted from
another list using $LIST. A list containing the empty string ("") as its sole
element is a valid list. The empty string ("") by itself is also considered a
valid list.
Examples
The following examples all return 1, indicating a valid list:

   SET w = $LISTBUILD("Red","Blue","Green")
   SET x = $LISTBUILD("Red")
   SET y = $LISTBUILD(365)
   SET z = $LISTBUILD("")
   WRITE !,$LISTVALID(w)
   WRITE !,$LISTVALID(x)
   WRITE !,$LISTVALID(y)
   WRITE !,$LISTVALID(z)
The following examples all return 0. Numbers and strings (with the exception of
the null string) are not valid lists:

   SET x = "Red"
   SET y = 44
   WRITE !,$LISTVALID(x)
   WRITE !,$LISTVALID(y)
The following examples all return 1. Concatenated, nested, and omitted value
lists are all valid lists:

   SET w=$LISTBUILD("Apple","Pear")
   SET x=$LISTBUILD("Walnut","Pecan")
   SET y=$LISTBUILD("Apple","Pear",$LISTBUILD("Walnut","Pecan"))
   SET z=$LISTBUILD("Apple","Pear",,"Pecan")
   WRITE !,$LISTVALID(w_x) ; concatenated
   WRITE !,$LISTVALID(y)   ; nested
   WRITE !,$LISTVALID(z)   ; omitted element
The following examples all return 1. $LISTVALID considers all of the following
 empty lists as valid lists:

  WRITE $LISTVALID(""),!
  WRITE $LISTVALID($LB()),!
  WRITE $LISTVALID($LB(NULL)),!
  WRITE $LISTVALID($LB("")),!
  WRITE $LISTVALID($LB($CHAR(0))),!
  WRITE $LISTVALID($LB(,))
See Also

  • $LIST function
  • $LISTBUILD function
  • $LISTDATA function
  • $LISTFIND function
  • $LISTFROMSTRING function
  • $LISTGET function
  • $LISTLENGTH function
  • $LISTNEXT function
  • $LISTSAME function
  • $LISTTOSTRING function


 #}}}
*$MVAT*  #{{{

Performs MultiValue screen cursor control or sets screen display option.
Synopsis

$MVAT(x,y)

$MVAT(code,arg)

Parameters

      A positive integer specifying the number of columns to indent the
x     horizontal position of the screen cursor. 0=column 1 (no indent), 1=
      indent 1 column.

y     Optional  A positive integer specifying the vertical line position of the
      screen cursor. 0=top of screen. If omitted, defaults to the current line.

code  A negative integer specifying a screen display option code. See the Caché
      MVBasic @ function for a list of these codes.

arg   Optional  An argument required by certain code values.

Description
The $MVAT function invokes the Caché MVBasic @ function, performs the specified
operation, and returns to the Caché ObjectScript environment. Specify parameter
values in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.
The @ function does not change the Caché ObjectScript $X and $Y special
variables.

 #}}}
*$MVFMT*  #{{{

Performs MultiValue formatting of a string.
Synopsis

$MVFMT(string,format)

Parameters

string  A string expression to be formatted for display.

format  A quoted string consisting of positional letter and number codes
        specifying the display format for string.

Description
The $MVFMT function invokes the Caché MVBasic FMT function, and returns the
resulting value to the Caché ObjectScript environment. Specify parameter values
in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.

 #}}}
*$MVFMTS*  #{{{

Performs MultiValue formatting of elements of a dynamic array.
Synopsis

$MVFMTS(dynarray,format)

Parameters

dynarray  A dynamic array to be formatted for display.

format    A quoted string consisting of positional letter and number codes
          specifying the display format for dynarray.

Description
The $MVFMTS function invokes the Caché MVBasic FMTS function, and returns the
resulting value to the Caché ObjectScript environment. Specify parameter values
in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.

 #}}}
*$MV*  #{{{

Builds or modifies a MultiValue dynamic array.
Synopsis

SET $MV(dynvar,fpos[,vpos])=value

Arguments

dynvar  A variable used to hold the MultiValue dynamic array.

        Field-level element. An integer that specifies where to insert the 
        value as a field-level element in the dynvar dynamic array. A value of
fpos    0 appends value to the beginning of the dynamic array. A value of  1
        appends value to the end of the dynamic array. A positive integer
        replaces the field-level element at that position with value.

        Optional  Value-level element. An integer that specifies where to
        insert the value as a value-level element within the field specified in
vpos    fpos in the dynvar dynamic array. A value of 0 appends value to the
        beginning of the fpos field. A value of  1 appends value to the end of
        the fpos field. A positive integer replaces the value-level element at
        that position in the fpos field with value.

        Optional  Subvalue-level element. An integer that specifies where to
        insert the value as a subvalue-level element within the value-level
        element specified in vpos in the dynvar dynamic array. A value of 0
spos    appends value to the beginning of the vpos element. A value of  1
        appends value to the end of the vpos element. A positive integer
        replaces the subvalue-level element at that position in the vpos with 
        value.

Description
The $MV function creates or modifies a MultiValue dynamic array by inserting
element values with the appropriate dynamic array delimiters: fpos inserts
field mark (@FM) delimiters (CHAR(254)). vpos inserts value mark (@VM)
delimiters (CHAR(253)). spos inserts subvalue mark (@SM) delimiters (CHAR
(252)). $MV can add elements to the beginning or end, or replace an existing
element value with a specified value.
By default, $MV inserts or appends elements, not delimiters. Therefore, it does
not insert dynamic array delimiters without element values. To insert or append
dynamic array delimiters, specify the positional argument value as pos::1 and
equate to an empty string. This is shown in the following example:

  SET $MV(dynval,-1)="apple"
  SET $MV(dynval,-1)="orange"
  WRITE dynval,!
  SET $MV(dynval,-1)="" // appends empty element
  WRITE dynval,!
  SET $MV(dynval,-1)="" // does nothing
  WRITE dynval,!
  SET $MV(dynval,-1::1)="" // appends 2nd delimiter
  WRITE dynval,!
  SET $MV(dynval,-1::1)=""  // appends 3rd delimiter
  WRITE dynval

Examples
The following example creates a dynamic array with three field elements:

  SET $MV(dynval,-1)="apple"
  SET $MV(dynval,-1)="orange"
  SET $MV(dynval,-1)="banana"
  WRITE dynval
The following example appends the element value  FRUIT to the beginning of a
three-element dynamic array, creating a dynamic array with four field elements:

  SET $MV(dynval,-1)="apple"
  SET $MV(dynval,-1)="orange"
  SET $MV(dynval,-1)="banana"
  SET $MV(dynval,0)="FRUIT"
  WRITE dynval
The following example replaces the value of the second dynamic array element ( 
orange ) with the value  nectarine :

  SET $MV(dynval,-1)="apple"
  SET $MV(dynval,-1)="orange"
  SET $MV(dynval,-1)="banana"
  SET $MV(dynval,2)="nectarine"
  WRITE dynval
The following example creates a dynamic array with three field elements,
appends an empty fourth element and deletes the second element value:

  SET $MV(dynval,-1)="apple"
  SET $MV(dynval,-1)="orange"
  SET $MV(dynval,-1)="banana"
  SET $MV(dynval,-1)=""
  SET $MV(dynval,2)=""
  WRITE dynval
The following example creates a dynamic array with three field elements, then
adds two value-level elements within the first field element:

  SET $MV(dynval,-1)="apple"
  SET $MV(dynval,-1)="orange"
  SET $MV(dynval,-1)="banana"
  SET $MV(dynval,1,-1)="Braeburn"
  SET $MV(dynval,1,-1)="Macintosh"
  WRITE dynval
See Also

  • Dynamic Arrays in the Caché MVBasic Reference


 #}}}
*$MVICONV*  #{{{

Performs MultiValue external-to-internal conversion of a string.
Synopsis

$MVICONV(string,codes)

Parameters

string  A string expression that specifies a value in external (output) format.

codes   A quoted string containing one or more code characters that govern the
        conversion from external format to internal format.

Description
The $MVICONV function invokes the Caché MVBasic ICONV function, and returns the
resulting value to the Caché ObjectScript environment. Specify parameter values
in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.

 #}}}
*$MVICONVS*  #{{{

Performs MultiValue external-to-internal conversion of elements of a dynamic
array.
Synopsis

$MVICONVS(dynarray,codes)

Parameters

dynarray  A dynamic array, each element of which specifies a value in external
          (output) format.

codes     A quoted string containing one or more code characters that govern
          the conversion from external format to internal format.

Description
The $MVICONVS function invokes the Caché MVBasic ICONVS function, and returns
the resulting value to the Caché ObjectScript environment. Specify parameter
values in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.

 #}}}
*$MVINMAT*  #{{{

Returns the number of MultiValue array elements.
Synopsis

$MVINMAT(array)

Arguments

array  Optional  The name of an array. If omitted, the most recently parsed
       array.

Description
The $MVINMAT function returns the number of elements in an array that has been
loaded using a MultiValue MATREAD, MATREADU, or MATPARSE statement.
An array must be dimensioned using the Caché ObjectScript MVDIM command or the
MultiValue DIMENSION statement.
The Caché ObjectScript $MVINMAT function corresponds to the Cache MultiValue
Basic INMAT function.
Examples
The following example returns the number of elements in a one-dimensional
(vector) array.

  SET x=8
  MVDIM myarray(x)
  WRITE $MVINMAT(myarray)
The following example returns the number of elements in a two-dimensional
(matrix) array.

  SET x=7,y=5
  MVDIM myarray(x,y)
  WRITE $MVINMAT(myarray)
See Also

  • MVDIM command
  • INMAT function in the Caché MVBasic Reference
  • DIM statement in the Caché MVBasic Reference
  • MATPARSE statement in the Caché MVBasic Reference
  • MATREAD statement in the Caché MVBasic Reference


 #}}}
*$MVLOWER*  #{{{

Lowers MultiValue dynamic array delimiters to next level.
Synopsis

$MVLOWER(dynarray)

Arguments

dynarray  Any valid MultiValue dynamic array.

Description
The $MVLOWER function returns a MultiValue dynamic array with its delimiters
converted to the next lower-level delimiters. For example, @VM value mark
delimiters become @SM subvalue mark delimiters. When a delimiter cannot be
lowered any further, it is returned unchanged.
The available levels, in descending order, are: @IM (CHAR(255)); @FM (CHAR
(254)); @VM (CHAR(253)); @SM (CHAR(252)); @TM (CHAR(251)); and CHAR(250).
The Caché ObjectScript $MVLOWER function corresponds to the Cache MultiValue
Basic LOWER function. The $MVRAISE function performs the opposite operation,
raising the level of dynamic array delimiters to the next higher level.
Example
The following example uses the $MVLOWER function to convert dynamic array
delimiters to the next lower level. It then uses the $MVRAISE function to
reverse this operation:

  SET numvm="123"_$CHAR(253)_"456"_$CHAR(253)_"789"
  ZZDUMP numvm       /* Returns 123v456v789 */
  SET numlower=$MVLOWER(numvm)
  ZZDUMP numlower    /* Returns 123s456s789 */
  SET numraise=$MVRAISE(numlower)
  ZZDUMP numraise    /* Returns 123v456v789 */
See Also

  • $MVRAISE function
  • MultiValue LOWER function in the Caché MVBasic Reference
  • Dynamic Arrays in the Caché MVBasic Reference


 #}}}
*$MVOCONV*  #{{{

Performs MultiValue internal-to-external conversion of a string.
Synopsis

$MVOCONV(string,codes)

Parameters

string  A string expression that specifies a value in internal (storage)
        format.

codes   A quoted string containing one or more code characters that govern the
        conversion from internal format to external format.

Description
The $MVOCONV function invokes the Caché MVBasic OCONV function, and returns the
resulting value to the Caché ObjectScript environment. Specify parameter values
in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.

 #}}}
*$MVOCONVS*  #{{{

Performs MultiValue internal-to-external conversion of elements of a dynamic
array.
Synopsis

$MVOCONVS(dynarray,codes)

Parameters

dynarray  A dynamic array, each element of which specifies a value in internal
          (storage) format.

codes     A quoted string containing one or more code characters that govern
          the conversion from internal format to external format.

Description
The $MVOCONVS function invokes the Caché MVBasic OCONVS function, and returns
the resulting value to the Caché ObjectScript environment. Specify parameter
values in MVBasic form. For further details refer to the 
Caché MultiValue Basic Reference.

 #}}}
*$MVRAISE*  #{{{

Raises MultiValue dynamic array delimiters to next level.
Synopsis

$MVRAISE(dynarray)

Arguments

dynarray  Any valid MultiValue dynamic array.

Description
The $MVRAISE function returns a MultiValue dynamic array with its delimiters
converted to the next higher-level delimiters. For example, @SM subvalue mark
delimiters become @VM value mark delimiters. When a delimiter cannot be raised
any further, it is returned unchanged.
The available levels, in ascending order, are: CHAR(250); @TM (CHAR(251)); @SM
(CHAR(252)); @VM (CHAR(253)); @FM (CHAR(254)); and @IM (CHAR(255)).
The Caché ObjectScript $MVRAISE function corresponds to the Cache MultiValue
Basic RAISE function. The $MVLOWER function performs the opposite operation,
lowering the level of dynamic array delimiters to the next lower level.
Examples
The following example uses the $MVRAISE function to convert dynamic array
delimiters to the next higher level. It then uses the $MVLOWER function to
reverse this operation:

  SET numvm="123"_$CHAR(253)_"456"_$CHAR(253)_"789"
  ZZDUMP numvm       /* Returns 123v456v789 */
  SET numraise=$MVRAISE(numvm)
  ZZDUMP numraise    /* Returns 123f456f789 */
  SET numlower=$MVLOWER(numraise)
  ZZDUMP numlower    /* Returns 123v456v789 */
See Also

  • $MVLOWER function
  • MultiValue RAISE function in the Caché MVBasic Reference
  • Dynamic Arrays in the Caché MVBasic Reference


 #}}}
*$MVTRANS*  #{{{

Reads field data from a MultiValue file.
Synopsis

$MVTRANS(mvfile,recID,fieldno,code)

Arguments

         The name of a MultiValue file defined in the VOC, specified as a
mvfile   quoted string. If there are multiple data files, you can specify 
         mvfile as either "dirname,datafile" or simply "datafile".

recID    The record ID of the desired record, specified as an integer.

         Either an integer or a non-numeric string. If an integer, fieldno
         specifies the field number of the field to be read, or, if -1, returns
         the contents of the entire record. This usage is compatible with most
fieldno  MultiValue systems. If a non-numeric string, fieldno specifies an
         attribute to look up in the file's dictionary. If that attribute is a
          D data defining entry, $MVTRANS looks up the data using the
         corresponding field number recorded in the dictionary. This usage is
         compatible with UniData systems.

code     A letter code that specifies what to do if the requested record does
         not exist. This letter code must be specified as a quoted string.

Description
The $MVTRANS function returns a field value from a MultiValue file. Unlike a 
READ statement, you do not have to use the OPEN statement to open the
MultiValue file before issuing a $MVTRANS.
The code argument determines how $MVTRANS should respond when you request an
invalid field. The following are valid letter codes:

"X"  Return an empty string if the specified record or field cannot be located.

"V"  Return an empty string and generate an error message if the specified
     record or field cannot be located.

"C"  Return the recID value if the specified record or field cannot be located.

"N"  Return the recID value if the specified field value is null.

The Caché ObjectScript $MVTRANS function corresponds to the Cache MultiValue
Basic TRANS function.
Examples
The following examples illustrates the use of the $MVTRANS function. Because
TEST.FILE does not exist, each returns the error value dictated by its code
argument:

  SET mydyn=$MVTRANS("TEST.FILE",6,1,"X")
  WRITE !,"the field value:",mydyn

  SET mydyn=$MVTRANS("TEST.FILE",6,1,"V")
  WRITE !,"the field value:",mydyn

  SET mydyn=$MVTRANS("TEST.FILE",6,1,"C")
  WRITE !,"the field value:",mydyn
See Also

  • TRANS function in the Caché MVBasic Reference
  • READ statement in the Caché MVBasic Reference
  • STATUS statement in the Caché MVBasic Reference
  • Dynamic Arrays in the Caché MVBasic Reference


 #}}}
*$NAME*  #{{{

Returns the name value of a variable or a portion of a subscript reference.
Synopsis

$NAME(variable,integer)
$NA(variable,integer)

Parameters

          The variable whose name value is to be returned. It can specify a
          local or global variable, which can be either subscripted or
variable  unsubscripted. It does not need to be a defined variable. However, it
          may not be a defined private variable. If variable is a subscripted
          global, you can specify a naked global reference.

          Optional  A numeric value that specifies which portion (level) of a
integer   subscript reference to return. It can be a positive integer, the name
          of a variable, or an expression. When used, variable must be a
          subscripted reference.

Description
$NAME returns a formatted form of the variable name reference supplied as 
variable. It does not check whether this variable is defined or has a data
value. The value $NAME returns depends on the parameters used.

  • $NAME(variable) returns the name value of the specified variable in 
    canonical form; that is, as a fully expanded reference.
  • $NAME(variable,integer) returns a portion of a subscript reference.
    Specifically, integer controls the number of subscripts returned by the
    function.

Execution of this function does not affect the naked indicator.
Parameters
variable
variable can be a local or global variable, unsubscripted or subscripted. If 
variable is an extended global reference, $NAME returns the extended global
reference as specified, without checking whether the specified namespace exists
and without capitalizing the namespace name. If variable is a naked global
reference, $NAME returns the full global reference. If variable is a private
variable, a compile error occurs.
integer
The integer parameter is used when variable is a subscripted reference. If the
value of integer is 0, $NAME returns only the name of the variable. If the
value of integer is less than the number of subscripts in variable, $NAME
returns the number of subscripts indicated by the value of integer. If integer
is greater than the number of subscripts in variable, $NAME returns the full
subscripted reference.
If variable is an unsubscripted variable, the value of integer is ignored; 
$NAME returns the variable name. If integer is the null string ("") or a
nonnumeric string, $NAME returns the variable name with no subscripts.
The value of integer receives standard integer parsing. For example, leading
zeros and the plus sign are ignored. Fractional digits are truncated and
ignored. A negative integer value results in a <FUNCTION> error.
Examples
In this example, the integer parameter specifies the level to return. If the
specified number of subscripts in integer matches or exceeds the number of
subscript levels (in this case, 3), then $NAME returns all defined levels,
behaving as if you specified the one-parameter form. If you specify an integer
level of zero (0), the null string (""), or any nonnumeric string (such as
"A"), $NAME returns the name of the array (in this case  ^client )

   SET ^client(4)="Vermont"
   SET ^client(4,1)="Brattleboro"
   SET ^client(4,1,1)="Yankee Ingenuity"
   SET ^client(4,1,2)="Vermonster Systems"
   WRITE !,$NAME(^client(4,1,1),1) ; returns 1 level
   WRITE !,$NAME(^client(4,1,1),2) ; returns 2 levels
   WRITE !,$NAME(^client(4,1,1),3) ; returns 3 levels
   WRITE !,$NAME(^client(4,1,1),4) ; returns all (3) levels
   WRITE !,$NAME(^client(4,1,1),0) ; returns array name
   WRITE !,$NAME(^client(4,1,1),"") ; returns array name
   WRITE !,$NAME(^client(4,1,1))    ; returns all (3) levels
In the following example, $NAME is used with a naked reference in a loop to
output the values for all elements in the current (user-supplied) array level.

   READ !,"Array element: ",ary
   SET x=@ary ; dummy operation to set current array and level
   SET y=$ORDER(^("")) ; null string to find beginning of level
   FOR i=0:0 {
     WRITE !,@$NAME(^(y))
     SET y=$ORDER(^(y))
     QUIT:y=""
   }

The first SET command performs a dummy assignment to establish the
user-supplied array and level as the basis for the subsequent naked references.
The $ORDER function is used with a naked reference to return the number of the
first subscript (whether negative or positive) at the current level.
The WRITE command in the FOR loop uses $NAME with a naked global reference and
argument indirection to output the value of the current element. The SET
command uses $ORDER with a naked global reference to return the subscript of
the next existing element that contains data. Finally, the postconditional QUIT
checks the value returned by $ORDER to detect the end of the current level and
terminate the loop processing.
You can use the returned $NAME string value for name or subscript indirection
or pass it as a parameter to a routine or user-defined function. For more
information, refer to Indirection in Using Caché ObjectScript. Consider the
routine ^DESCEND that lists descendant nodes of the specified node.

DESCEND(ROOT)  ;List descendant nodes
   NEW REF
   SET REF=ROOT
   IF ROOT'["(" {
       FOR {
       SET REF=$QUERY(@REF)
       QUIT:REF=""
       WRITE REF,! }
   }
   ELSE {
     SET $EXTRACT(ROOT,$LENGTH(ROOT))=","
     FOR {
       SET REF=$QUERY(@REF)
       QUIT:REF'[ROOT
       WRITE REF,!   }
   }

The following example demonstrates how you can use $NAME to pass a parameter to
the ^DESCEND routine defined in the previous example.

   FOR var1="ONE","TWO","THREE" {
     DO ^DESCEND($NAME(^X(var1))) }

^X("ONE",2,3)
Notes
Uses for $NAME
You typically use $NAME to return the name values of array elements for use
with the $DATA and $ORDER functions.
If a reference to an array element contains expressions, $NAME evaluates the
expressions before returning the canonical form of the name. For example:

   SET x=1+2
   SET y=$NAME(^client(4,1,x))
   WRITE y
$NAME evaluates the variable x and returns the value ^client(4,1,3).
Naked Global References
$NAME also accepts a naked global reference and returns the name value in its
canonical form (that is, a full (non-naked) reference). A naked reference is
specified without the array name and designates the most recently executed
global reference. In the following example, the first SET command establishes
the global reference and the second SET command uses the $NAME function with a
naked global reference.

   SET ^client(5,1,2)="Savings/27564/3270.00"
   SET y=$NAME(^(3))
   WRITE y
In this case, $NAME returns the value ^client(5,1,3). The supplied subscript
value (3) replaces the existing subscript value (2), at the current level.
For more details, see Naked Global Reference in Using Caché Globals.
Extended Global References
The $ZUTIL(68,7) and $ZUTIL(69,7) functions allow you to control whether $NAME
returns name values in extended global reference form. For example, with
extended reference mode in effect:

   WRITE $NAME(^["PAYROLL"]ROUTINE)

The above statement returns the defined namespace PAYROLL and not just ^
ROUTINE.
$ZUTIL(68,7) sets the extended global reference mode switch on the process
level and $ZUTIL(69,7) sets it on the system level.
For a description of extended global reference syntax, see the Global Structure
chapter in Using Caché Globals.
See Also

  • $DATA function
  • $ORDER function
  • $GET function
  • $ZUTIL(68,7) Extended Reference Mode Process Switch function
  • $ZUTIL(69,7) Extended Reference Mode System Default function


 #}}}
*$NCONVERT*  #{{{

Converts a number to a binary encoded value.
Synopsis

$NCONVERT(n,format,endian)
$NC(n,format,endian)

Parameter

        Any number, which can be specified as a value, a variable, or an
n       expression. Additional limitations on valid values are imposed by the 
        format selected.

format  One of the following format codes, specified as a quoted string: S1,
        S2, S4, S8, U1, U2, U4, F4, or F8.

endian  Optional  A boolean value, where 0 = little-endian and 1 = big-endian.
        The default is 0.

Description
$NCONVERT converts n to an encoded string of 8-bit bytes, using the specified 
format.
The following are the supported format codes:

S1  Signed integer encoded into a string of one 8-bit bytes. The value must be
    in the range -128 through 127, inclusive.

S2  Signed integer encoded into a string of two 8-bit bytes. The value must be
    in the range -32768 through 32767, inclusive.

S4  Signed integer encoded into a string of four 8-bit bytes. The value must be
    in the range -2147483648 through 2147483647, inclusive.

    Signed integer encoded into a string of eight 8-bit bytes. The value must
S8  be in the range -9223372036854775808 through 9223372036854775807,
    inclusive.

U1  Unsigned integer encoded into a string of one 8-bit bytes. The maximum
    value is 256.

U2  Unsigned integer encoded into a string of two 8-bit bytes. The maximum
    value is 65535.

U4  Unsigned integer encoded into a string of four 8-bit bytes. The maximum
    value is 4294967295.

F4  IEEE floating point number encoded into a string of four 8-bit bytes.

F8  IEEE floating point number encoded into a string of eight 8-bit bytes.

Values beyond the range of format limits result in a <VALUE OUT OF RANGE>
error. Specifying a negative number for an Unsigned format results in a <VALUE
OUT OF RANGE> error. A non-numeric value returns a value of 0 for all formats.
A fractional number returns a value of 0 for all formats except F4 and F8.
$SCONVERT provides the inverse of the $NCONVERT operation.
Examples
The following example converts a series of unsigned numbers to two-byte encoded
values:

  FOR x=250:1:260 {
    ZZDUMP $NCONVERT(x,"U2") }
  QUIT
The following example performs the same operation in big-endian order:

  FOR x=250:1:260 {
    ZZDUMP $NCONVERT(x,"U2",1) }
  QUIT
See Also

  • $SCONVERT function


 #}}}
*$NEXT*  #{{{

Returns the value of the next subscript in a subscripted variable.
Synopsis

$NEXT(variable)
$N(variable)

Parameters

variable  The array subscript to be used to determine the next existing
          subscript value.

Description
$NEXT returns the value of the next subscript in the subscripted variable. It
can be either a local or global subscripted array element. The value of the
rightmost subscript must be a number whose value is -1 or greater. If you are
using a naked global reference, the naked indicator must be defined.
$NEXT is an obsolete function that has been superseded by the $ORDER function.
It is documented here only for completeness.
Note:
Do not use $NEXT in any new code. Use $ORDER in place of $NEXT to retrieve
subscripts of an array.
Notes
$NEXT and $ORDER
$NEXT is similar to $ORDER. Both return the subscripts of the next sibling in
collating order to the specified node. However, $NEXT and $ORDER have different
start and failure codes, as follows:

                $NEXT    $ORDER

Starting point  -1     Null string

Failure code    -1     Null String

See Also
$ORDER function

 #}}}
*$NORMALIZE*  #{{{

Validates and returns a numeric value; rounds to a specified precision.
Synopsis

$NORMALIZE(num,scale)

Parameters

num    The numeric value to be validated. It can be a numeric or string value,
       a variable name, or any valid Caché ObjectScript expression.

       The number of significant digits to round num to as the returned value.
       This number can be larger or smaller than the actual number of
       fractional digits in num. Permitted values are 0 (round to integer),  1
scale  (truncate to integer), and positive integers (round to specified number
       of fractional digits). There is no maximum scale value. However, the
       functional maximum cannot exceed the numeric precision. For standard
       Caché fractional numbers the functional scale maximum is 18 (minus the
       number of integer digits  1).

Description
The $NORMALIZE function validates num and returns the normalized form of num.
It performs rounding (or truncation) of fractional digits using the scale
parameter. You can use the scale parameter to round a real number to a
specified number of fractional digits, to round a real number to an integer, or
to truncate a real number to an integer.
After rounding, $NORMALIZE removes trailing zeros from the return value. For
this reason, the number of fractional digits returned may be less than the
number specified in scale, as shown in the following example:

  WRITE $NORMALIZE($ZPI,11),!
  WRITE $NORMALIZE($ZPI,12),!   /* trailing zero removed */
  WRITE $NORMALIZE($ZPI,13),!
  WRITE $NORMALIZE($ZPI,14)
Parameters
num
The number to be validated may be an integer, a real number, or a scientific
notation number (with the letter  E or  e ). It may be a string, expression, or
variable that resolves to a number. It may be signed or unsigned, and may
contain leading or trailing zeros. $NORMALIZE validates character-by-character.
It stops validation and returns the validated portion of the string if:

  • num contains any characters other than the digits 0 9, + or  signs, a
    decimal point (.), and a letter  E or  e .
  • num contains more than decimal point, or letter  E or  e .
  • If a + or  sign is found after a numeric in num it is considered a trailing
    sign, and no further numerics are parsed.
  • The letter  E or  e is not followed by an integer.

The scale parameter value causes the returned value to be a rounded or
truncated version of the num value. The actual value of the num variable is not
changed by $NORMALIZE processing.
scale
The mandatory scale parameter is used to specify how many fractional digits to
round to. Depending on the value specified, scale can have no effect on
fractional digits, round to a specified number of fractional digits, round to
an integer, or truncate to an integer.
A nonnegative scale value causes num to be rounded to that number of fractional
digits. When rounding, a value of 5 or greater is always rounded up. To avoid
rounding a number, make scale larger than the number of possible fractional
digits in num. A scale value of 0 causes num to be rounded to an integer value
(3.9 = 4). A scale value of  1 causes num to be truncated to an integer value
(3.9 = 3). A scale value which is nonnumeric or the null string is equivalent
to a scale value of 0.
Specify an integer value for scale; decimal digits in the scale value are
ignored. You can specify a scale value larger than the number of decimal digits
specified in num. You can specify a scale value of  1; all other negative scale
values result in a <FUNCTION> error.
Examples
In the following example, each invocation of $NORMALIZE returns the normalized
version of num with the specified rounding (or integer truncation):

   WRITE !,$NORMALIZE(0,0)        ; All integers OK
   WRITE !,$NORMALIZE("",0)       ; Null string is parsed as 0
   WRITE !,$NORMALIZE(4.567,2)    ; Real numbers OK
   WRITE !,$NORMALIZE("4.567",2)  ; Numeric strings OK
   WRITE !,$NORMALIZE(-+.0,99)    ; Leading/trailing signs OK
   WRITE !,$NORMALIZE(+004.500,1) ; Leading/trailing 0's OK
   WRITE !,$NORMALIZE(4E2,-1)     ; Scientific notation OK
In the following example, each invocation of $NORMALIZE returns a numeric
subset of num:

   WRITE !,$NORMALIZE("4,567",0)
     ; NumericGroupSeparators (commas) are not recognized
     ; here validation halts at the comma, and 4 is returned.
   WRITE !,$NORMALIZE("4A",0)
     ; Invalid (nonnumeric) character halts validation
     ; here 4 is returned.
The following example shows the use of the scale parameter to round (or
truncate) the return value:

   WRITE !,$NORMALIZE(4.55,2)
     ; When scale is equal to the fractional digits of num,
     ; all digits of num are returned without rounding.
   WRITE !,$NORMALIZE(3.85,1)
     ; num is rounded to 1 fractional digit,
     ; (with values of 5 or greater rounded up)
     ; here 3.9 is returned.
   WRITE !,$NORMALIZE(4.01,17)
     ; scale can be larger than number of fractional digits,
     ; and no rounding is peformed; here 4.01 is returned.
   WRITE !,$NORMALIZE(3.85,0)
     ; When scale=0, num is rounded to an integer value.
     ; here 4 is returned.
   WRITE !,$NORMALIZE(3.85,-1)
     ; When scale=-1, num is truncated to an integer value.
     ; here 3 is returned.
Notes
$DOUBLE Numbers
$DOUBLE IEEE floating point numbers are encoded using binary notation. Most
decimal fractions cannot be exactly represented in this binary notation. When a
$DOUBLE value is input to $NORMALIZE with a scale value, the return value
frequently contains more fractional digits than specified in scale because the
fractional decimal result is not representable in binary, so the return value
must be rounded to the nearest representable $DOUBLE value, as shown in the
following example:

  SET x=1234.1234
  SET y=$DOUBLE(1234.1234)
  WRITE "Decimal: ",$NORMALIZE(x,2),!
  WRITE "Double: ",$NORMALIZE(y,2),!
  WRITE "Dec/Dub: ",$NORMALIZE($DECIMAL(y),2)
If you are normalizing a $DOUBLE value for decimal formatting, you should
convert the $DOUBLE value to decimal representation before normalizing the
result, as shown in the above example.
$NORMALIZE handles $DOUBLE("INF") and $DOUBLE("NAN") values, and returns INF
and NAN.
Decimal Separator
$NORMALIZE uses the DecimalSeparator property value for the current locale ( . 
by default) as the delimiter character between the integer part and the
fractional part of num.
To determine the DecimalSeparator character for your locale, invoke the
following method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
$NORMALIZE, and $NUMBER Compared
The $NORMALIZE, and $NUMBER functions both validate numbers and return a
validated version of the specified number.
These two functions offer different validation criteria. Select the one that
best meets your needs.

  • Both functions parse signed and unsigned integers (including  0),
    scientific notation numbers (with  E or  e ), and real numbers. However, 
    $NUMBER can be set (using the  I format) to reject numbers with a
    fractional part (including scientific notation with a negative base-10
    exponent). Both functions parse both numbers (123.45) and numeric strings (
     123.45 ).
  • Both functions strip out leading and trailing zeroes. The decimal character
    is stripped out unless followed by a nonzero value.
  • Numeric strings containing a NumericGroupSeparator: $NUMBER parses
    NumericGroupSeparator characters (American format: comma (,); European
    format: period (.) or apostrophe (')) and the decimal character (American
    format: period (.) or European format: comma (,)) based on its format
    parameter (or the default for the current locale). It accepts and strips
    out any number of NumericGroupSeparator characters. For example, in
    American format it validate  123,,4,56.99 as the number 123456.99. 
    $NORMALIZE does not recognize NumericGroupSeparator characters. It
    validates character-by-character until it encounters a nonnumeric
    character; for example, it validates  123,456.99 as the number 123.
  • Multiple leading signs (+ and  ) are interpreted by both functions for
    numbers. Only $NORMALIZE accepts multiple leading signs in a quoted numeric
    string.
  • Trailing + and  signs: Both functions reject trailing signs in numbers. In
    a quoted numeric string $NUMBER parses one (and only one) trailing sign. 
    $NORMALIZE parses multiple trailing signs.
  • Parentheses: $NUMBER parses parentheses surrounding an unsigned number in a
    quoted string as indicating a negative number. $NORMALIZE treats
    parentheses as nonnumeric characters.
  • Numeric strings containing multiple decimal characters: $NORMALIZE
    validates character-by-character until it encounters the second decimal
    character. For example, in American format it validates  123.4.56 as the
    number 123.4. $NUMBER rejects any string containing more than one decimal
    character as an invalid number.
    Numeric strings containing other nonnumeric characters: $NORMALIZE
    validates character-by-character until it encounters an alphabetic
    character. It validates  123A456 as the number 123. $NUMBER validates or
    rejects the entire string; it reject  123A456 as an invalid number.
  • The null string: $NORMALIZE parses the null string as zero (0). $NUMBER
    rejects the null string.

The $NUMBER function provide optional min/max range checking. This is also
available using the $ISVALIDNUM function.
$NORMALIZE, $NUMBER, and $ISVALIDNUM all provide rounding of numbers to a
specified number of fractional digits. $NORMALIZE can round fractional digits,
and round or truncate a real number to return an integer. For example, 
$NORMALIZE can round 488.65 to 488.7 or 489, or truncate it to 488. $NUMBER can
round real numbers or integers. For example, $NUMBER can round 488.65 to 488.7,
489, 490 or 500.
See Also

  • $DOUBLE function
  • $FNUMBER function
  • $INUMBER function
  • $ISVALIDNUM function
  • $NUMBER function
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$NOW*  #{{{

Returns the local date and time with fractional seconds for the current
process.
Synopsis

$NOW(tzmins)

Parameters

        Optional  A positive or negative integer value that specifies the
        desired time zone offset from GMT, in minutes. A value of 0 corresponds
        to Greenwich Mean Time (GMT). Positive integers correspond to time
        zones west of GMT; negative integers correspond to time zones east of
        GMT. For example, a value of 300 corresponds to United States Eastern
tzmins  Standard Time, 5 hours (300 minutes) west of Greenwich. The range of
        permitted values is -1440 through 1440; values beyond this range result
        in an <ILLEGAL VALUE> error.
        If you omit tzmins, the $NOW function returns the local date and time
        based on the $ZTIMEZONE special variable value. The range of $ZTIMEZONE
        values that the $NOW function supports is -1440 through 1440; values
        beyond this range result in an <ILLEGAL VALUE> error.

Description
$NOW can return the following:

  • The current local date and time with fractional seconds for the current
    process.
  • The local date and time for a specified time zone, with fractional seconds,
    for the current process.

The $NOW function returns a character string that consists of two numeric
values, separated by a comma. The first number is an integer that represents
the current local date. The second is a fractional number that represents the
current local time. These values are counters, not user-readable dates and
times.
$NOW returns the date and time in Caché storage ($HOROLOG) format, with the
additional feature of fractional seconds. $NOW returns the current local date
and time in the following format: ddddd,sssss.ffffff
The first integer (ddddd) is the number of days since December 31, 1840, where
day 1 is January 1, 1841. The maximum value for this date integer is 2980013,
which corresponds to December 31, 9999.
The second number (sssss.ffffff) is the number of seconds (and fractional
seconds) since midnight of the current day. Caché increments the sssss field
from 0 to 86399 seconds. When it reaches 86399 at midnight, Caché resets the 
sssss field to 0 and increments the date field by 1. The number of ffffff
fractional digits is the maximum precision supported by the current operating
system.
The $NOW function can be invoked with or without a parameter value. The
parentheses are mandatory.
$NOW with no parameter value returns the current local date and time for the
current process. It determines the local time zone from the value set in the 
$ZTIMEZONE special variable. Setting $ZTIMEZONE changes the time portion of 
$NOW, and this change of time can also change the date portion of $NOW.
Caution:
The $NOW local time value may not correspond to local clock time. $NOW
determines local time using the $ZTIMEZONE value. $ZTIMEZONE is continuous
throughout the year; it does not adjust for Daylight Savings Time or other
local time variants.
Also, because $NOW resynchronizes its time value with the system clock,
comparisons of time values between $NOW and other Caché time functions and
special variables may show slight variations. This variation is limited to 0.05
seconds; however, within this range of variation, comparisons may yield
misleading results. For example, WRITE $NOW(),!,$HOROLOG may yield results such
as the following:

61438,38794.002085
61438,38793

This anomaly is caused both by the 0.05 second resynchronization variation and
by $HOROLOG truncation of fractional seconds.
$NOW with a parameter value returns the time and date that correspond to the
time zone specified in tzmins. The value of $ZTIMEZONE is ignored.
Time Functions Compared
The various ways to return the current date and time are compared, as follows:

  • $NOW returns the local date and time for the current process. $NOW returns
    the date and time in Caché storage format. It includes fractional seconds;
    the number of fractional digits is the maximum precision supported by the
    current operating system.
      □ $NOW() determines the local time zone from the value of the $ZTIMEZONE
        special variable. The local time is not adjusted for local time
        variants, such as Daylight Savings Time. It therefore may not
        correspond to local clock time.
      □ $NOW(tzmins) returns the time and date that correspond to the specified
        tzmins time zone parameter. The value of $ZTIMEZONE is ignored.
  • $ZUTIL(188) returns the local, variant-adjusted date and time. The date,
    time, and local time zone are determined from the host operating system.
    The value of $ZTIMEZONE is ignored. $ZUTIL(188) returns the date and time
    in Caché storage format. It includes fractional seconds; the number of
    fractional digits is the maximum precision supported by the current
    operating system.
  • $HOROLOG contains the local, variant-adjusted date and time in Caché
    storage format. The local time zone is determined from the current value of
    the $ZTIMEZONE special variable, and then adjusted for local time variants,
    such as Daylight Savings Time. It returns whole seconds only; fractions of
    a second are truncated.
  • $ZTIMESTAMP contains the UTC (Greenwich Mean) date and time, with
    fractional seconds, in Caché storage format. Fractional seconds are
    expressed in three digits of precision (on Windows systems), or six digits
    of precision (on UNIX systems).

Separating Date and Time
To get just the date portion or just the time portion of $NOW, you can use the
$PIECE function, specifying the comma as the delimiter character:

   SET dateval=$PIECE($NOW(),",",1)
   SET timeval=$PIECE($NOW(),",",2)
   WRITE !,"Date and time: ",$NOW()
   WRITE !,"Date only: ",dateval
   WRITE !,"Time only: ",timeval
Setting the Date
The value returned by $NOW, $ZUTIL(188), or $ZTIMESTAMP cannot be set using 
$ZUTIL(71).
The value contained in $HOROLOG can be set to a user-specified date for the
current process using $ZUTIL(71).
Examples
The following example shows several ways to return the current local date and
time:

   WRITE $HOROLOG,"        $HOROLOG date & time",!
   WRITE $NOW()," $NOW() process date & time",!
   WRITE $ZUTIL(193,$NOW(0))," $NOW(0) UTC-to-local process date & time",!
   WRITE $ZUTIL(193,$ZTIMESTAMP),"    $ZTS UTC-to-local process date & time",!
   WRITE $ZUTIL(188)," $ZU(188) system date & time"
Note that $HOROLOG and $ZUTIL(188) adjust for local time variants, such as
Daylight Savings Time. $NOW does not adjust for local time variants.
The following example uses $ZDATE to convert the date field in $NOW to a date
format.

   WRITE $ZDATE($PIECE($NOW(),",",1))
returns a value formatted like this: 04/29/2009
The following example converts the time portion of $NOW to a time in the form
of hours:minutes:seconds.ffff on a 12-hour (a.m. or p.m.) clock.

CLOCKTIME
  NEW
  SET Time=$PIECE($NOW(),",",2)
  SET Sec=Time#60
  SET Totmin=Time\60
  SET Min=Totmin#60
  SET Milhour=Totmin\60
  IF Milhour=12 { SET Hour=12,Meridian=" pm" }
  ELSEIF Milhour>12 { SET Hour=Milhour-12,Meridian=" pm" }
  ELSE { SET Hour=Milhour,Meridian=" am" }
  WRITE !,Hour,":",Min,":",Sec,Meridian
  QUIT
See Also

  • $ZDATE function
  • $ZDATEH function
  • $ZDATETIME function
  • $ZDATETIMEH function
  • $ZTIME function
  • $ZTIMEH function
  • $ZUTIL(188) Local System Date/Time with Fractional Seconds function
  • $ZUTIL(71) Set Date to a Fixed Value function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable
  • $ZTIMEZONE special variable


 #}}}
*$NUMBER*  #{{{

Validates and returns a numeric value; optionally provides rounding and range
checking.
Synopsis

$NUMBER(num,format,min,max)
$NUM(num,format,min,max)

Parameters

        The numeric value to be validated and then converted to Caché canonical
num     form. It can be a numeric or string value, a variable name, or any
        valid Caché ObjectScript expression.

        Optional  Specifies which processing options to apply to num. These
format  processing options dictate primarily how to recognize and handle
        numbers containing decimal points.

min     Optional  The minimum acceptable numeric value.

max     Optional  The maximum acceptable numeric value.

Description
The $NUMBER function converts and validates the num numeric value using the
specified format. It accepts numbers supplied with a variety of punctuation
formats and returns numbers in Caché canonical form. You can use format to test
whether a number is an integer. If min or max are specified, the number must
fall within that range of values.
Using $NUMBER on the $DOUBLE values INF,  INF, or NAN always returns the empty
string.
Parameters
format
The possible format codes are as follows. These format codes may be specified
in any order. A nonnumeric format must be specified as a quoted string. Any or
all of the following format codes may be omitted. If format is invalid, $NUMBER
generates a <SYNTAX> error.

  • Decimal character: either  . or  , indicating whether to use the American (
     . ) or European ( , ) convention for validating the decimal point. You can
    specify either of these characters, or no decimal character. If you omit
    the decimal character, the number takes the DecimalSeparator of the current
    locale.
  • Rounding factor: an integer indicating how many digits to round to. This
    integer can be preceded by an optional + or - sign. If the rounding factor
    is positive (or unsigned) the number is rounded to the specified number of
    fractional digits. If the rounding factor is 0, the number is rounded to an
    integer. If the rounding factor is a negative integer, the number is
    rounded the indicated number of places to the left of the decimal
    separator. For example, a rounding factor of -2 rounds 234.45 to 200. The
    number  5 is always rounded up; thus a rounding factor of 1 rounds 123.45
    to 123.5.
  • Integer indicator: the letter  I (uppercase or lowercase) which specifies
    that the number must resolve to an integer. For example,   07.00 resolves
    to an integer, but   07.01 does not. If the number does not resolve to an
    integer, $NUMBER returns the null string.

min and max
You can specify a minimum allowed value, a maximum allowed value, neither, or
both. If specified, the num value (after rounding) must be greater than or
equal to the min value, and less than or equal to the max value. A null string
as a min or max value is equal to zero. If a value does not meet these
criteria, $NUMBER returns the null string.
Thus in the following examples, the first is valid because num (4.0) equals max
(4). The second is valid because num (4.003) still equals max (4) within the
format range (two fractional digits). However, the third is not valid because 
$NUMBER rounds num up to a value (4.01) greater than max within the format
range. It returns a null string.

   WRITE !,$NUMBER(4.0,2,0,4)
   WRITE !,$NUMBER(4.003,2,0,4)
   WRITE !,$NUMBER(4.006,2,0,4)
You can omit parameters, retaining the commas as place holders. The first line
of the following example sets a max value, but no format or min value. The
second line sets no format value, but sets a min value of the null string,
which is equivalent to zero. Thus the first line returns  7, and the second
line fails the min criteria and returns the null string.

   SET max=10
   WRITE !,$NUMBER(-7,,,max)
   WRITE !,$NUMBER(-7,,"",max)
You cannot specify trailing commas. The following results in a <SYNTAX> error:

   WRITE $NUMBER(mynum,,min,)

Notes
Order of Operations
$NUMBER performs the following series of conversions and validations. If the
number fails any validation step, $NUMBER returns a null string (""). If the
number passes all validation steps, $NUMBER returns the resulting converted
Caché canonical form number.

 1. $NUMBER uses the decimal character format to determine which character is
    the group separator and strips out all group separator characters
    (regardless of location in the number). It uses the following rule: If the
    decimal character specified in format is a period (.), then the group
    separator is a comma (,) or apostrophe ('). If the decimal character
    specified in format is a comma (,), then the group separator is a period
    (.) or apostrophe ('). If no decimal character is specified in format, the
    group separator is the NumericGroupSeparator property of the current
    locale.
 2. $NUMBER validates that the number is well-formed. A well-formed number can
    contain any of the following:
      □ Numbers
      □ An optional decimal indicator character, as defined above (one or none,
        but not more than one).
      □ An optional plus (+) or minus (-) sign character (leading or trailing,
        but not more than one).
      □ Optional parentheses enclosing the number to indicate a negative value
        (debit). The number within the parentheses cannot have a sign
        character.
      □ An optional base-10 exponent, indicated by an  E (uppercase or
        lowercase) followed by an integer. If  E is specified, an exponent
        integer must be present. The exponent integer may be preceded by a sign
        character.
 3. If the integer indicator is present in format, $NUMBER checks for integers.
    An integer cannot contain a decimal indicator character. Numeric strings ( 
    123.45 ) and numbers (123.45) are parsed differently. Numeric strings fail
    this integer test even if there are no digits following the decimal
    indicator character, or if expansion of scientific notation or rounding
    would eliminate the fractional digits. Numbers pass these validation tests.
    If a number fails the integer indicator check, $NUMBER returns the null
    string ("").
 4. $NUMBER converts the number to a Caché canonical form number. It expands
    scientific notation, replaces enclosing parentheses with a negative sign
    character, strips off leading and trailing zeros, and deletes a decimal
    indicator character if it is not followed by any nonzero digits.
 5. $NUMBER uses the rounding factor (if present) to round the number the
    specified number of digits. It then strips off any leading or trailing
    zeros and the decimal indicator character if it is not followed by any
    digits.
 6. $NUMBER validates the number against the minimum value, if specified.
 7. $NUMBER validates the number against the maximum value, if specified.
 8. $NUMBER returns the resulting number.

European and American Decimal Separators
$NUMBER returns a number in canonical form, removing all numeric group
separators and includes at most one decimal separator character. You can use
the format values  , or  . to identify the decimal separator used in num; by
specifying the decimal separator, you are also implicitly specifying the
numeric group separator.
To determine the DecimalSeparator character for your locale, invoke the
following method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
To determine the NumericGroupSeparator character and NumericGroupSize number
for your locale, invoke the following methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("NumericGroupSeparator"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("NumericGroupSize")
In following examples, a comma is specified as the decimal separator:

  SET num="123,456"
  WRITE !,$NUMBER(num,",")
     // converts to the fractional number "123.456"
     // (comma is identified as decimal separator)
  SET num="123,45,6"
  WRITE !,$NUMBER(num,",")
    // returns the null string
    // (invalid number, too many decimal separators)
  SET num="123.456"
  WRITE !,$NUMBER(num,",")
    // converts to the integer "123456"
    // removing group separator
    // (if comma is decimal, then period is group separator)
  SET num="123.4.56"
  WRITE !,$NUMBER(num,",")
    // converts to the integer "123456"
    // removing group separators
    // (number and placement of group separators ignored)
Rounding and Precision
When rounding numbers, be aware that IEEE floating point numbers and standard
Caché fractional numbers differ in precision. $DOUBLE IEEE floating point
numbers are encoded using binary notation. They have a precision of 53 binary
bits, which corresponds to 15.95 decimal digits of precision. (Note that the
binary representation does not correspond exactly to a decimal fraction.)
Because most decimal fractions cannot be exactly represented in this binary
notation, an IEEE floating point number may differ slightly from the
corresponding standard Caché floating point number. Standard Caché fractional
numbers have a precision of 18 decimal digits on all supported Caché system
platforms. When an IEEE floating point number is displayed as a fractional
number, the binary bits are often converted to a fractional number with far
more than 18 decimal digits. This does not mean that IEEE floating point
numbers are more precise than standard Caché fractional numbers.
See Also

  • $DOUBLE function
  • $FNUMBER function
  • $INUMBER function
  • $ISVALIDNUM function
  • $NORMALIZE function
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ORDER*  #{{{

Returns the next local variable or the subscript of a local or global variable.
Synopsis

$ORDER(variable,direction,target)
$O(variable,direction,target)

Parameters

           Either a local variable or a subscripted local or global variable.
variable   If an array, the subscript is required. You cannot specify just the
           array name. variable may be specified as a multidimensional object
           property with the syntax obj.property.

           Optional  The subscript order in which to traverse the target array.
           Values for subscripted variables can be: 1 = ascending subscript
direction  order (the default) or  1 = descending subscript order. For
           unsubscripted local variables, 1 (the default) is the only permitted
           value.

           Optional  Returns the current data value of the next or previous
           node of variable. Whether it is the next or previous depends on the
           setting of direction. You must specify a direction value to specify
target     a target. For unsubscripted local variables, direction must be set
           to 1. If variable is undefined, the target value remains unchanged.
           The target parameter cannot be used with structured system variables
           (SSVNs) such as ^$ROUTINE.

Description
The value $ORDER returns depends on the parameters used.

  • $ORDER(variable) returns the number of the next defined subscript if 
    variable is a subscripted variable. The returned subscript is at the same
    level as that specified for the variable. For example, $ORDER(^client
    (4,1,2)) returns the next subscript (3), assuming that ^client(4,1,3)
    exists.
    $ORDER(variable) returns the name of the next defined local variable in
    alphabetic collating sequence, if variable is an unsubscripted local
    variable. For example, $ORDER would return the following defined local
    variables in the following sequence: a, a0a, a1, a1a, aa, b, bb, c.
  • $ORDER(variable,direction) returns either the next or the previous
    subscript for the variable. You can specify direction as 1 (next, the
    default) or  1 (previous).
    For unsubscripted local variables, $ORDER returns variables in direction 1
    (next) order only; you cannot specify a direction of  1 (previous).
  • $ORDER(variable,direction,target) returns the subscript for the variable,
    and sets target to its current data value. This can be either the next or
    the previous subscript for a subscripted variable, depending on the 
    direction setting. For an unsubscripted local variable, direction must be
    set to 1 to return the current data value to target. The target parameter
    cannot be used with structured system variables (SSVNs) such as ^$ROUTINE.

Examples
The following example lists the name and value of the next defined local
variables after variable a1:

   SET a="best",a1="prime",aa="choice",b="good",c="utility grade"
   WRITE !,$ORDER(a1,1,target),!,target
The following example returns 1, the first subscript in ^X. It sets the naked
indicator to the first level.

   SET ^X(1,2,3)="1", ^X(2)="2"
   WRITE $ORDER(^X(-1))
The following example returns 2, the next subscript on the single subscripted
level. (The node you specify in the argument need not exist.) The naked
indicator is still set to the first level.

   SET ^X(1,2,3)="1",^X(2)="2"
   WRITE $ORDER(^X(1))
The following example returns 2, the first subscript on the two-subscript
level. The naked indicator is now set at the second level.

   SET ^X(1,2,3)="1",^X(2)="2"
   WRITE $ORDER(^X(1,-1))
The following example uses $ORDER to list all of the primary subscripts in the
^data global:

   SET ^data(1)="a",^data(3)="c",^data(7)="g"
   // Get first subscript
   SET key=$ORDER(^data(""))
   WHILE (key'="") {
     WRITE key,!
     // Get next subscript
     SET key = $ORDER(^data(key))
   }
In the following example, a multidimensional property is used as the variable
value. This example returns the names of all defined namespaces to the target
parameter:

  SET obj = ##class(%ResultSet).%New("%SYS.Namespace:List")
  DO obj.Execute()
    SET targ="blank", x=""
  WHILE targ'="" {
     DO obj.Next()
     WRITE $ORDER(obj.Data(x),1,targ),!       // returns "Nsp"
     IF targ'="" {
     WRITE "Namespace: ",targ,! }
     }
   WRITE !,"Done!"
Similar programs return the same information using the $GET and $DATA
functions.
Notes
Uses for $ORDER
$ORDER is typically used with loop processing to traverse the nodes in a sparse
array. A sparse array is an array that may contain undefined nodes on any given
level. Unlike the $DATA function, $ORDER simply skips over undefined nodes to
return the subscript of the next existing node. For example:

   SET struct=""
   FOR  {
     SET struct=$ORDER(^client(struct))
     QUIT:struct=""
     WRITE !,^client(struct)
   }

The above routine writes the values for all the top-level nodes in the ^client
global array.
$ORDER skips over undefined nodes, but not nodes that contain no data. Such
nodes include both pointer nodes and terminal nodes. If you use $ORDER in a
loop to feed a command (such as WRITE) that expects data, you must include a 
$DATA check for dataless nodes. For example, you could specify the WRITE
command in the previous example with a postconditional test, as follows:

   WRITE:(1=$DATA(^client(struct)))!(11=$DATA(^client(struct))) !,
   ^client(struct)

This test covers the case of both a dataless pointer node and a dataless
terminal node. If your code becomes too cumbersome for a simple FOR loop, you
can relegate part of it to a block-structured DO.
Start and End for a Search
To start a search from the beginning of the current level, specify a null
string ("") for the subscript. This technique is required if the level may
contain negative as well as positive subscripts. The following example returns
the first subscript on the array level:

   SET s=$ORDER(^client(""))
   WRITE s

When $ORDER reaches the end of the subscripts for the given level, it returns a
null string (""). If you use $ORDER in a loop, your code should always include
a test for this value. In a previous example, QUIT:struct="" is used to detect
the end of the level and terminate the loop.
$ORDER Uses Naked Global Reference
Like the $NAME and $QUERY functions, $ORDER can be used with a naked global
reference, which is specified without the array name and designates the most
recently executed global reference. For example:

   SET var1=^client(4,5)
   SET var2=$ORDER(^(""))
   WRITE "var1=",var1,!,"var2=",var2

The first SET command establishes the current global reference, including the
subscript level for the reference. The $ORDER function uses a naked global
reference to return the first subscript for this level. For example, it would
return the value 1, indicating ^client(4,1), if that subscripted global is
defined. If ^client(4,1) is not defined, it would return the value 2,
indicating ^client(4,2) if that subscripted global is defined, and so forth.
All three parameters of $ORDER can take a naked global reference, or specify
the global reference. However, if direction specifies an explicit global
reference, subsequent naked global references do not use the direction global
reference. They continue to use the prior established global reference, as
shown in the following example:

   SET ^client(4,3)="Jones"
   SET ^client(4,5)="Smith"
   SET ^dir(1)=-1
   SET rtn=$ORDER(^client(4,5),-1)
   WRITE $ZREFERENCE,!
      /* naked global ref is ^client(4,5) */
   SET rtn=$ORDER(^client(4,5),^dir(1))
   WRITE $ZREFERENCE,!
      /* NOTE: naked global ref is ^client(4,5) */
   SET rtn=$ORDER(^client(4,5),^dir(1),^(1))
   WRITE $ZREFERENCE
      /* NOTE: naked global ref is ^client(4,1) */
   WRITE ^client(4,1),!
   SET rtn=$ORDER(^client(4,5),^dir(1),^targ(1))
   WRITE $ZREFERENCE
      /* naked global ref is ^targ(1) */
   WRITE ^targ(1),!
   SET ^rtn(1)=$ORDER(^client(4,5),^dir(1),^targ(2))
   WRITE $ZREFERENCE
      /* naked global ref is ^rtn(1) */
   WRITE ^targ(2)

For more details, see Naked Global Reference in Using Caché Globals.
$ORDER and $DOUBLE Subscripts
$DOUBLE floating point numbers can be used as subscript identifiers. However,
when used as a subscript identifier, the $DOUBLE number is converted to a
string. When $ORDER returns a subscript of this type, it returns it as a
numeric string, not a $DOUBLE floating point number.
$ORDER and $NEXT
$ORDER is similar to $NEXT. Both functions return the subscripts of the next
sibling in collating order to the specified node. However, $ORDER and $NEXT
have different start and failure codes, as follows:

                $NEXT    $ORDER

Starting point  -1     Null string

Failure code    -1     Null String

Because $ORDER starts and fails on the null string, it correctly returns nodes
having both negative and positive subscripts.
See Also

  • $NEXT function
  • $QUERY function
  • $ZPREVIOUS function
  • Global Structure chapter in Using Caché Globals


 #}}}
*$PIECE*  #{{{

Returns or replaces a substring, using a delimiter.
Synopsis

$PIECE(string,delimiter,from,to)
$P(string,delimiter,from,to)

SET $PIECE(string,delimiter,from,to)=value
SET $P(string,delimiter,from,to)=value

Parameters

string     The target string from which a substring is to be returned.

delimiter  A delimiter used to identify substrings within string.

           Optional  An integer that specifies the substring, or beginning of a
from       range of substrings, to return from the target string. Substrings
           are separated by a delimiter, and counted from 1. If omitted, the
           first substring is returned.

           Optional  An integer that specifies the ending substring for a range
to         of substrings to return from the target string. Must be used with 
           from.

Description
$PIECE can be used in two ways:

  • To return a substring from string. The substring is determined by
    specifying a delimiter character (or character string) that is found in 
    string. This uses the $PIECE(string,delimiter,from,to) syntax.
  • To replace a substring within string. The replacement substring may be the
    same length, longer, or shorter than the original substring. The substring
    is determined by specifying a delimiter character (or character string)
    that is found in string. This uses the 
    SET $PIECE(string,delimiter,from,to)=value syntax.

When returning a specified substring (piece) from string, the substring
returned depends on the parameters used:

  • $PIECE(string,delimiter) returns the first substring in string. If 
    delimiter occurs in string, this is the substring that precedes the first
    occurrence of delimiter. If delimiter does not occur in string, the
    returned substring is string.
  • $PIECE(string,delimiter,from) returns the substring which is the nth piece
    of string, where the integer n is specified by the from parameter, and
    pieces are separated by a delimiter. The delimiter is not returned.
  • $PIECE(string,delimiter,from,to) returns a range of substrings including
    the substring specified in from through the substring specified in to. This
    four-argument form of $PIECE returns a string that includes any
    intermediate occurrences of delimiter that occur between the from and to
    substrings. If to is greater than the number of substrings, the returned
    substring includes all substrings to the end of string.

Note:
$PIECE is a general-purpose function for handling a string containing delimited
substrings. For handling a MultiValue dynamic array string containing the
specific MultiValue delimiters, use the $MV function.
Parameters
string
The target string from which the substring is to be returned. It can be a
string literal, a variable name, or any valid Caché ObjectScript expression
that evaluates to a string. If you specify a null string ("") as the target
string, $PIECE returns the null string.
A target string usually contains instances of a character (or character string)
which are used as delimiters. This character or string cannot also be used as a
data value within string.
When $PIECE is used with SET on the left hand side of the equals sign, string
must evaluate to a valid variable name.
delimiter
The search string to be used to delimit substrings within string. It can be a
numeric or string literal (enclosed in quotation marks), the name of a
variable, or an expression that evaluates to a string.
Commonly, a delimiter is a designated character which is never used within
string data, but is set aside solely for use as a delimiter separating
substrings. A delimiter can also be a multi-character search string, the
individual characters of which can be used within string data.
If the specified delimiter is not in string, $PIECE returns the entire the 
string string. If the specified delimiter is the null string (""), $PIECE
returns the null string.
from
The number of a substring within string, counting from 1. It must be a positive
integer, the name of an integer variable, or an expression that evaluates to a
positive integer. Substrings are separated by delimiters.

  • If the from parameter is omitted or set to 1, $PIECE returns the first
    substring of string. If string does not contain the specified delimiter, a 
    from value of 1 returns string.
  • If the from parameter identifies by count the last substring in string,
    this substring is returned, regardless of whether it is followed by a
    delimiter.
  • If the value of from is the null string (""), zero, a negative number, or
    greater than the number of substrings in string, $PIECE returns a null
    string.

If the from parameter is used with the to parameter, it identifies the start of
a range of substrings to be returned as a string, and should be less than the
value of to.
to
The number of the substring within string that ends the range initiated by the 
from parameter. The returned string includes both the from and to substrings,
as well as any intermediate substrings and the delimiters separating them. The 
to argument must be a positive integer, the name of an integer variable, or an
expression that evaluates to a positive integer. The to parameter must be used
with from and should be greater than the value of from.

  • If from is less than to, $PIECE returns a string consisting of all of the
    delimited substrings within this range, including the from and to
    substrings. This returned string contains the substrings and the delimiters
    within this range.
  • If to is greater than the number of delimited substrings, the returned
    string contains all the string data (substrings and delimiters) beginning
    with the from substring and continuing to the end of the string string.
  • If from is equal to to, the from substring is returned.
  • If from is greater than to, $PIECE returns a null string.
  • If to is the null string (""), $PIECE returns a null string.

Replacing a Substring Using SET $PIECE
When making assignments with the SET command, you can use $PIECE to the left,
as well as to the right, of the equals sign. When used to the left of the
equals sign, $PIECE designates a substring to be replaced by the assigned
value.
The use of $PIECE (and $LIST and $EXTRACT) in this context differs from other
standard functions because it modifies an existing value, instead of just
returning a value.
Replacing a Delimited Substring
The following example changes the value of colorlist to
"Red,Green,Cyan,Yellow,Orange,Black":

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   WRITE !,colorlist
   SET $PIECE(colorlist,",",3)="Cyan"
   WRITE !,colorlist
The replacement substring may, of course, be longer or shorter than the
original:

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   WRITE !,colorlist
   SET $PIECE(colorlist,",",3)="Turquoise"
   WRITE !,colorlist
If you do not specify a from argument, the first substring is replaced:

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   WRITE !,colorlist
   SET $PIECE(colorlist,",")="Turquoise"
   WRITE !,colorlist
If you specify a from and to argument, the included substrings are replaced by
the specified value, in this case the 3rd and 4th delimited substrings:

   SET colorlist="Red,Blue,Yellow,Green,Orange,Black"
   WRITE !,colorlist
   SET $PIECE(colorlist,",",3,5)="non-primary"
   WRITE !,colorlist
If $PIECE specifies more occurrences of the delimiter than exist in the target
variable, it appends additional delimiters to the end of the value, up to one
less than the specified number. The following example changes the value of 
smallcolor to "Green;Blue;;Red". The number of delimiter characters added is
equal to the from value, minus the number of existing delimiters, minus one:

   SET smallcolor="Green;Blue"
   WRITE !,smallcolor
   SET $PIECE(smallcolor,";",4)="Red"
   WRITE !,smallcolor
Replacing the Source String
If the delimiter doesn't appear in string, the new value replaces the original
string:

   SET colorlist="Red,Green,Blue"
   WRITE !,colorlist
   SET $PIECE(colorlist,"^")="Purple"
   WRITE !,colorlist
If the delimiter is the null string, the new value replaces the original
string:

   SET colorlist="Red,Green,Blue"
   WRITE !,colorlist
   SET $PIECE(colorlist,"")="Purple"
   WRITE !,colorlist
Initializing a String Variable
The string variable does not need to be defined before being assigned a value.
The following example initializes newvar to the character pattern ">>>>>>
TOTAL":

   SET $PIECE(newvar,">",7)="TOTAL"
   WRITE newvar
See the "SET with $PIECE and $EXTRACT" section of the SET command documentation
for more information.
$PIECE with Parameters over 32,768 Characters
The following example creates a string of 5 periods and a null:

   SET x="",$PIECE(x,".",6)=""
   WRITE x
Now consider the following example that creates a string of 32767 periods and a
null:

   SET x="",$PIECE(x,".",32768)=""

Although technically within the maximum length of a string, this example
generates a <MAXSTRING> error. If you wish to use $PIECE with a parameter
greater than 32767 characters, you must enable support for long strings. For
details on how to enable long strings, refer to the $ZUTIL(69,69) function.
Examples
The following example returns "Red", the first substring as identified by the
"," delimiter:

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   SET extract=$PIECE(colorlist,",")
   WRITE extract
The following example returns "Blue , the third substring as identified by the
"," delimiters:

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   SET extract=$PIECE(colorlist,",",3)
   WRITE extract
The following example returns "Blue,Yellow,Orange", the third through fifth
substrings in colorlist, as delimited by ",":

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   SET extract=$PIECE(colorlist,",",3,5)
   WRITE extract
The following WRITE statements all return the first substring  123 , showing
that these formats are equivalent when from and to have a value of 1:

   SET numlist="123#456#789"
   WRITE !,"2-arg=",$PIECE(numlist,"#")
   WRITE !,"3-arg=",$PIECE(numlist,"#",1)
   WRITE !,"4-arg=",$PIECE(numlist,"#",1,1)
In the following example, both $PIECE functions returns the entire string
string, because there are no occurrences of delimiter in string:

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   SET extract1=$PIECE(colorlist,"#")
   SET extract2=$PIECE(colorlist,"#",1,4)
   WRITE "#   =",extract1,!,"#,1,4=",extract2
The following two examples use more complex delimiters.
This example uses a delimiter string  #-# to return three substrings of the
string numlist. Here, the component characters of the delimiter string,  # and
 - , can be used as data values; only the specified sequence of characters (#-
#) is set aside:

   SET numlist="1#2-3#-#45##6#-#789"
   WRITE !,$PIECE(numlist,"#-#",1)
   WRITE !,$PIECE(numlist,"#-#",2)
   WRITE !,$PIECE(numlist,"#-#",3)
The following example uses a non-keyboard delimiter character (in this case,
the Unicode character for pi), specified using the $CHAR function, and inserted
into stringby using the concatenate operator (_):

   SET a = $CHAR(960)
   SET colorlist="Red"_a_"Green"_a_"Blue"
   SET extract1=$PIECE(colorlist,a)
   SET extract2=$PIECE(colorlist,a,2)
   SET extract3=$PIECE(colorlist,a,2,3)
   WRITE extract1,!,extract2,!,extract3
Notes
Using $PIECE to Unpack Data Values
$PIECE is typically used to "unpack" data values that contain multiple fields
delimited by a separator character. Typical delimiter characters include the
slash (/), the comma (,), the space ( ), and the semicolon (;). The following
sample values are good candidates for use with $PIECE:

"John Jones/29 River St./Boston MA, 02095"
"Mumps;Measles;Chicken Pox;Diptheria"
"45.23,52.76,89.05,48.27"

$PIECE and $LENGTH
The two-argument form of $LENGTH returns the number of substrings in a string,
based on a delimiter. Use $LENGTH to determine the number of substrings in a
string, and then use $PIECE to extract individual substrings, as shown in the
following example:

   SET sentence="The quick brown fox jumped over the lazy dog's back."
   SET delim=" "
   SET countdown=$LENGTH(sentence,delim)
   SET countup=1
   FOR reps=countdown:-1:1 {
      SET extract=$PIECE(sentence,delim,countup)
      WRITE !,countup," ",extract
      SET countup=countup+1
   }
   WRITE !,"All done!"
Null Values
$PIECE does not distinguish between a delimited substring with a null string
value, and a nonexistent substring. Both return a null string value. For
example, the following examples both return the null string for a from value of
7:

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   SET extract1=$PIECE(colorlist,",",6)
   SET extract2=$PIECE(colorlist,",",7)
   WRITE "6=",extract1,!,"7=",extract2

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black,"
   SET extract1=$PIECE(colorlist,",",6)
   SET extract2=$PIECE(colorlist,",",7)
   WRITE "6=",extract1,!,"7=",extract2
In the first case, there is no seventh substring; a null string is returned. In
the second case there is a seventh substring, as indicted by the delimiter at
the end of the string; the value of this seventh substring is the null string.
The following example shows null values within a string. It extracts substrings
1 and 3. These substrings exists, but both contain a null string. (Substring 1
is defined as the string preceding the first delimiter character):

   SET colorlist=",Red,,Blue,"
   SET extract1=$PIECE(colorlist,",")
   SET extract3=$PIECE(colorlist,",",3)
   WRITE !,"sub1=",extract1,!,"sub3=",extract3
The following examples also returns a null string, because the specified
substrings do not exist:

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   SET extract=$PIECE(colorlist,",",0)
   WRITE !,"Length=",$LENGTH(extract),!,"Value=",extract

   SET colorlist="Red,Green,Blue,Yellow,Orange,Black"
   SET extract=$PIECE(colorlist,",",8,20)
   WRITE !,"Length=",$LENGTH(extract),!,"Value=",extract
Nested $PIECE Operations
To perform complex extractions, you can nest $PIECE references within each
other. The inner $PIECE returns a substring that is operated on by the outer 
$PIECE. Each $PIECE uses its own delimiter. For example, the following returns
the state abbreviation  MA :

   SET patient="John Jones/29 River St./Boston MA 02095"
   SET patientstateaddress=$PIECE($PIECE(patient,"/",3)," ",2)
   WRITE patientstateaddress
The following is another example of nested $PIECE operations, using a hierarchy
of delimiters. First, the inner $PIECE uses the caret (^) delimiter to find the
second piece of nestlist: "A,B,C". Then the outer $PIECE uses the comma (,)
delimiter to return the first and second pieces ("A,B") of the substring
"A,B,C":

   SET nestlist="1,2,3^A,B,C^@#!"
   WRITE $PIECE($PIECE(nestlist,"^",2),",",1,2)
$PIECE Compared with $EXTRACT and $LIST
$PIECE determines a substring by counting user-defined delimiter characters
within the string. $PIECE takes as input an ordinary character string
containing multiple instances of a character (or string) intended for use as a
delimiter.
$EXTRACT determines a substring by counting characters from the beginning of a
string. $EXTRACT takes as input an ordinary character string.
$LIST determines an element from an encoded list by counting elements (not
characters) from the beginning of the list. The $LIST functions specify
substrings without using a designated delimiter. If setting aside a delimiter
character or character sequence is not appropriate to the type of data (for
example, bitstring data), you should use the $LISTBUILD and $LIST functions to
store and retrieve substrings. You can convert a delimited string into a list
using the $LISTFROMSTRING function. You can convert a list to a delimited
string using the $LISTTOSTRING function.
The data storage methods used by $PIECE and the $LIST functions are
incompatible and should not be combined. For example, attempted to use $PIECE
on a list created using $LISTBUILD yields unpredictable results and should be
avoided.
See Also

  • $EXTRACT function
  • $LENGTH function
  • $LIST function
  • $LISTBUILD function
  • $LISTFROMSTRING function
  • $LISTTOSTRING function
  • SET command


 #}}}
*$PREFETCHOFF*  #{{{

Ends pre-fetching of globals.
Synopsis

$PREFETCHOFF(gref,gref2)

Parameters

gref   Optional  A global reference.

gref2  Optional  A global reference used to establish a range.

Description
$PREFETCHOFF turns off the pre-fetching of global nodes established by 
$PREFETCHON.
There are three forms of $PREFETCHOFF:

  • $PREFETCHOFF() turns off all pre-fetching established for the current
    process.
  • $PREFETCHOFF(gref) turns off pre-fetching of the gref node and all of its
    descendents. The gref value must correspond exactly to the $PREFETCHON
    value.
  • $PREFETCHOFF(gref,gref2) turns off pre-fetching of the nodes in the range 
    gref through gref2. gref and gref2 must be nodes of the same global. The 
    gref and gref2 values must correspond exactly to the $PREFETCHON values.
    You cannot turn off part of a range of values.

Upon successful completion, $PREFETCHOFF() returns 0. It returns 0 even if
there were no pre-fetches to turn off.
Upon successful completion, $PREFETCHOFF(gref) and $PREFETCHOFF(gref,gref2)
return a string of six integers separated by commas. These six values are:
number of blocks prefetched, number of I/Os performed, number of prefetch
operations, milliseconds of prefetch disk time, background job: number of
blocks prefetched, and background job: number of I/Os performed.
Upon failure, all forms of $PREFETCHOFF return -1. $PREFETCHOFF(gref) and 
$PREFETCHOFF(gref,gref2) return -1 if there is no corresponding $PREFETCHON
that exactly matches the specified global or range of globals, or if the
specified prefetch global or range of globals has already been turned off.
Parameters
gref
A global reference, either a global or a process-private global. The global
does not need to be defined at the time that the pre-fetch is turned off.
gref2
A global reference used to establish a range with gref. Therefore, gref2 must
be a global node lower in the same global tree as gref.
Examples
The following example establishes two pre-fetches, then turns them off
individually:

  SET ret=$PREFETCHON(^a)
  IF ret=1 { WRITE !,"prefetch established" }
  ELSE { WRITE !,"prefetch not established" }
  SET ret2=$PREFETCHON(^b)
  IF ret2=1 { WRITE !,"prefetch established" }
  ELSE { WRITE !,"prefetch not established" }
  SET retoff=$PREFETCHOFF(^a)
  IF retoff'=-1 { WRITE !,"prefetch turned off. Values:",retoff }
  ELSE { WRITE !,"prefetch not turned off" }
  SET retoff2=$PREFETCHOFF(^b)
  IF retoff2'=-1 { WRITE !,"prefetch turned off. Values:",retoff2 }
  ELSE { WRITE !,"prefetch not turned off" }
The following example establishes two pre-fetches, then turns off all
pre-fetches for the current process:

  SET ret=$PREFETCHON(^a)
  IF ret=1 { WRITE !,"prefetch established" }
  ELSE { WRITE !,"prefetch not established" }
  SET ret2=$PREFETCHON(^b)
  IF ret2=1 { WRITE !,"prefetch established" }
  ELSE { WRITE !,"prefetch not established" }
  SET retoff=$PREFETCHOFF()
  IF retoff=0 { WRITE !,"all prefetches turned off" }
  ELSE { WRITE !,"prefetch not turned off" }
See Also

  • $PREFETCHON function
  • Globals in Using Caché ObjectScript


 #}}}
*$PREFETCHON*  #{{{

Establishes pre-fetch for specified globals.
Synopsis

$PREFETCHON(gref,gref2)

Parameters

gref   A global reference.

gref2  Optional  A global reference used to establish a range.

Description
$PREFETCHON turns on pre-fetching for a global or a range of globals. 
$PREFETCHON returns 1 indicating successful completion or 0 indicating the
desired pre-fetch could not be established.
$PREFETCHOFF turns off pre-fetching.
There are two forms of $PREFETCHON:

  • $PREFETCHON(gref) pre-fetches the gref node and all of its descendents. For
    example, $PREFETCHON(^abc(4)) pre-fetches all of the descendents of ^abc
    (4), such as ^abc(4,1), ^abc(4,2,2), and so forth. It does not pre-fetch ^
    abc(5).
  • $PREFETCHON(gref,gref2) pre-fetches the nodes in the range gref through 
    gref2. This does not include the descendents of gref2. gref and gref2 must
    be nodes of the same global. For example, $PREFETCHON(^abc(4),^abc(7,5))
    pre-fetches all of the global nodes in the range of ^abc(4) through ^abc
    (7,5), including ^abc(4,2,2), ^abc(5), and ^abc(7,1,2). However, it does
    not pre-fetch ^abc(7,5,1).

Pre-fetching and Performance
For pre-fetching to provide an improvement in performance, a one or more
pre-fetch background processes (daemons) must be running on the system when you
invoke $PREFETCHON. These pre-fetch daemons are shared systemwide by all
processes. Because each pre-fetch daemon only processes one pre-fetch request
at a time, it is usually advantageous to have several pre-fetch daemons running
on your system. However, large numbers of concurrent pre-fetch daemons can have
a performance impact on interactive system access.
Pre-fetching can improve performance when running an application that reads a
large number of disk blocks containing nodes from the same global tree.
Pre-fetching is most efficient when:

  • Data is accessed in ascending order, meaning that data blocks of the global
    tree are generally accessed in left-to-right order. However, there is no
    requirement for adhering strictly to ascending order.
  • Most of the data in the specified range is accessed.
  • Less than 100 pre-fetches are active at any given time.

Parameters
gref
A global reference, either a global or a process-private global. The global
does not need to be defined at the time that the pre-fetch is established.
gref2
A global reference used to establish a range with gref. Therefore, gref2 must
be a global node lower in the same global tree as gref.
Examples
The following example establishes pre-fetch for the global ^a.

  SET ^a="myglobal"
  SET x=^a
  SET ret=$PREFETCHON(^a)
  IF ret=1 { WRITE !,"prefetch established" }
  ELSE { WRITE !,"prefetch not established" }
  SET ret=$PREFETCHOFF()
The following example establishes pre-fetch for the range of globals ^||a(1)
through ^a||(50).

  SET ret=$PREFETCHON(^||a(1),^||a(50))
  IF ret=1 { WRITE !,"prefetch established" }
  ELSE { WRITE !,"prefetch not established" }
See Also

  • $PREFETCHOFF function
  • Globals in Using Caché ObjectScript


 #}}}
*$QLENGTH*  #{{{

Returns the number of subscripts in the specified local or global variable.
Synopsis

$QLENGTH(namevalue)
$QL(namevalue)

Parameters

namevalue  A string, or expression that evaluates to a string, which is a local
           or global reference.

Description
$QLENGTH returns the number of subscripts in a local variable, a
process-private global, or a global specified by namevalue. The variable does
not have to be defined for $QLENGTH to return the number of subscripts.
Parameters
namevalue
A quoted string, or expression that evaluates to a string, which is a local or
global reference. It can have the form: Name(s1,s2,...,sn).
If the string is a global reference, it can contain a namespace reference.
Because namevalue is a quoted string, the quotes around a namespace reference
must be doubled to be parsed correctly as literal quotation marks. The same
applies to the quotes in a process-private global with the syntax: 
^|"^"|ppgname.
A namevalue must reference a variable name in canonical form (a fully expanded
reference). To use $QLENGTH with a naked global reference, or with indirection,
you can use the $NAME function to return the corresponding fully expanded
reference.
Examples
The following example show the results of $QLENGTH when used with subscripted
and unsubscripted globals. The first $QLENGTH takes a global with no subscripts
and returns 0. The second $QLENGTH takes a global with two subscripts and
returns 2. Note that quotes found in the variable name are doubled because 
namevalue is specified as a quoted string.

   WRITE !,$QLENGTH("^|""USER""|test")
      ; returns 0
   SET name="^|""USER""|test(1,""customer"")"
   WRITE !,$QLENGTH(name)
      ; returns 2
The following example returns the $QLENGTH value for a process-private global
with two subscript levels. The $ZREFERENCE special variable contains the name
of the most recently referenced variable.

   SET ^||myppg("food","fruit",1)="apples"
   WRITE !,$QLENGTH($ZREFERENCE)   ; returns 3
The following example returns the $QLENGTH value for a process-private global
specified as a naked global indicator. The $NAME function is used to expand the
naked global indicator to canonical form:

   SET ^grocerylist("food","fruit",1)="apples"
   SET ^(2)="bananas"
   WRITE !,$QLENGTH($NAME(^(2)))   ; returns 3
See Also

  • $QSUBSCRIPT function
  • $NAME function
  • $ZREFERENCE special variable
  • Global Structure in Using Caché Globals


 #}}}
*$QSUBSCRIPT*  #{{{

Returns a variable name or a subscript name.
Synopsis

$QSUBSCRIPT(namevalue,intexpr)
$QS(namevalue,intexpr)

Parameters

           A string, or an expression that evaluates to a string, which is the
namevalue  name of a local variable, process-private global, or global
           variable, with or without subscripts.

intexpr    An integer code that specifies which name to return: variable name,
           subscript name, or namespace name.

Description
$QSUBSCRIPT returns the variable name, or the name of a specified subscript of 
namevalue, depending on the value of intexpr. If namevalue is a global
variable, you can also return the namespace name, if it was explicitly
specified. $QSUBSCRIPT does not return a default namespace name.
Parameters
namevalue
A quoted string, or expression that evaluates to a string, which is a local or
global reference. It can have the form: Name(s1,s2,...,sn).
If the string is a global reference, it can contain a namespace reference.
Because namevalue is a quoted string, the quotes around a namespace reference
must be doubled to be parsed correctly as literal quotation marks.
A namevalue must reference a variable name in canonical form (a fully expanded
reference). To use $QSUBSCRIPT with a naked global reference, or with
indirection, you can use the $NAME function to return the corresponding fully
expanded reference.
intexpr
An integer expression code that indicates which value to return. Assume that
the namevalue parameter has the form NAME(s1,s2,...,sn), where n is the ordinal
number of the last subscript. The intexpr parameter can have any of the
following values:

Code                                Return Value

< -1  Generates a <FUNCTION> error; these numbers are reserved for future
      extensions.

-1    Returns the namespace name if a global variable namevalue includes one;
      otherwise, returns the null string ("").

      Returns the variable name. Returns ^NAME for a global variable, and ^||
0     NAME for a process-private global variable. Does not return a namespace
      name.

      Returns the subscript name for the level of subscription specified by the
<=n   integer n, with 1 being the first subscript level and n being the highest
      defined subscript level.

>n    An integer > n returns the null string (""), where n is the highest
      defined subscript level.

Examples
The following example returns $QSUBSCRIPT values when namevalue is a
subscripted global with one subscript level and a specified namespace:

   SET global="^|""account""|%test(""customer"")"
   WRITE !,$QSUBSCRIPT(global,-1)  ; account
   WRITE !,$QSUBSCRIPT(global,0)   ; ^%test
   WRITE !,$QSUBSCRIPT(global,1)   ; customer
   WRITE !,$QSUBSCRIPT(global,2)   ; null string
The following example returns $QSUBSCRIPT values when namevalue is a
process-private global with two subscript levels. The $ZREFERENCE special
variable contains the name of the most recently referenced variable.

   SET ^||myppg(1,3)="apples"
   WRITE !,$QSUBSCRIPT($ZREFERENCE,-1)  ; null string
   WRITE !,$QSUBSCRIPT($ZREFERENCE,0)   ; ^||myppg
   WRITE !,$QSUBSCRIPT($ZREFERENCE,1)   ; 1
   WRITE !,$QSUBSCRIPT($ZREFERENCE,2)   ; 3
The following example returns the $QSUBSCRIPT value for a global variable
specified as a naked global indicator. The $NAME function is used to expand the
naked global indicator to canonical form:

   SET ^grocerylist("food","fruit",1)="apples"
   SET ^(2)="bananas"
   WRITE !,$QSUBSCRIPT($NAME(^(2)),2)   ; returns "fruit"
See Also

  • $QLENGTH function
  • $NAME function
  • $ZREFERENCE special variable
  • Global Structure in Using Caché Globals


 #}}}
*$QUERY*  #{{{

Performs a physical scan of a local or global array.
Synopsis

$QUERY(reference,direction,target)
$Q(reference,direction,target)

Parameters

reference  A reference that evaluates to the name (and optionally subscripts)
           of a local or global variable.

direction  Optional  The direction (forwards or backwards) to traverse the
           array.

target     Optional  Returns the current data value of the local or global
           variable specified in reference.

Description
$QUERY performs a physical scan of a local or global array; it returns the full
reference, name and subscripts, of the defined node next in sequence to the
specified array node. If no such node exists, $QUERY returns the null string.
Parameters
reference
The returned global reference can be at the same level, a lower level, or a
higher level as the level specified in the reference parameter. If you specify 
reference without specifying subscripts, $QUERY returns the first defined node
in the array.
direction
If no direction is specified, the default direction is forward. If you wish to
specify a direction, a parameter value of 1 will traverse the array forward, a
value of -1 will traverse the array backward.
target
If you wish to specify a target, you must specify a direction. If the variable
identified in the reference parameter is undefined, the target value remains
unchanged.
Example
This example presents a generalized routine for outputting the data values for
all the nodes in a user-specified array. It can accommodate arrays with any
number of levels. The code performs the same operation as the code shown in the
example under the $ORDER function. Instead of requiring 23 lines, however, it
requires only six and is not restricted as to the number of levels it can
handle.

Start  READ !,"Array name: ",ary QUIT:ary=""
  SET queryary=$QUERY(@ary@(""))
  WRITE !,@queryary
  FOR   {
    SET queryary=$QUERY(@queryary)
        QUIT:queryary=""
        WRITE !,@queryary
  }
  WRITE !,"Finished."
  QUIT

The first SET command uses $QUERY with subscript indirection to initialize the
global reference to the first existing node that contains data. For more
information, refer to Indirection in Using Caché ObjectScript. (Like $ORDER, 
$QUERY accepts a null string to designate the first subscript in an array.) The
first WRITE command outputs the value of the first node found. If it were
omitted, the first node would be skipped.
In the FOR loop, $QUERY is used to retrieve the next node and update the global
reference, whose contents are then output by the WRITE command. The
postconditional QUIT terminates the loop when it finds a null string (""),
indicating that $QUERY has reached the end of the array.
No $DATA tests are required, unless you wish to distinguish between pointer
nodes ($DATA=11) and terminal nodes ($DATA=1).
Notes
Using $QUERY to Traverse an Array
Used repetitively, $QUERY can traverse an entire array in left-to-right,
top-to-bottom fashion, returning the entire sequence of defined nodes. $QUERY
can start at the point determined by the subscript specified for reference. It
proceeds along both the horizontal and vertical axes. For example:

   SET exam=$QUERY(^client(4,1,2))

Based on this example, $QUERY might return any of the following values,
assuming a three-level array:

  Value                    Returned by the $QUERY Function If...

^client     If ^client(4,1,3) exists and contains data.
(4,1,3)

^client     If ^client(4,1,3) does not exist or does not contain data and if ^
(4,2)       client(4,2) does exist and contains data.

^client(5)  If ^client(4,1,3) and ^client(4,2) do not exist or do not contain
            data and if ^client(5) does exist and contains data.

null        If none of the previous global references exist or contain data; 
string      $QUERY has reached the end of the array.
("")

With a direction value of -1, $QUERY can traverse an entire array in reverse
order in right-to-left, bottom-to-top fashion.
$QUERY Compared to $ORDER
$QUERY differs from the $ORDER function in that $QUERY returns a full global
reference, while $ORDER returns only the subscript of the next node. $ORDER
proceeds along only the horizontal axis, across nodes at one level.
$QUERY also differs from $ORDER in that it selects only those existing nodes
that contain data. $ORDER selects existing nodes, regardless of whether or not
they contain data. Where $ORDER performs an implicit test for existence ($DATA'
=0), $QUERY performs an implicit test for both existence and data ($DATA'=0 and
$DATA'=10). Note, however, that $QUERY does not distinguish between pointer
nodes ($DATA=11) and terminal nodes ($DATA=1) that contain data. To make this
distinction, you must include appropriate $DATA tests in your code.
Like $ORDER, $QUERY is typically used with loop processing to traverse the
nodes in a sparse array. A sparse array is an array that can contain undefined
nodes on any given level. $QUERY simply skips undefined or empty nodes to
return the global reference of the next existing node. $QUERY provides very
compact code for accessing global arrays.
Like the $NAME and $ORDER functions, $QUERY can be used with a naked global
reference, which is specified without the array name and designates the most
recently executed global reference. For example:

   SET a=^client(1)
   SET x=2
   SET z=$QUERY(^(x))

The first SET command establishes the current global reference, including the
level for the reference. The second SET command sets up a variable for use with
subscripts. The $QUERY function uses a naked reference to return the full
global reference for the next node following ^client(2). For example, the
returned value might be ^client(2,1) or ^client(3).
$QUERY and $ZUTIL(68,7) and $ZUTIL(69,7)
The $ZUTIL(68,7) and $ZUTIL(69,7) functions allow you to control whether $QUERY
returns global references in Extended Global Reference mode.
$ZUTIL(68,7) lets you set the Extended Global Reference mode switch for a
particular process and $ZUTIL(69,7) lets you set the Extended Global Reference
mode switch for the entire system.
For further details on extended global references, see the Global Structure
chapter in Using Caché Globals.
See Also

  • $DATA function
  • $ORDER function
  • $ZUTIL(68,7) Extended Reference Mode Process Switch function
  • $ZUTIL(69,7) Extended Reference Mode System Default function


 #}}}
*$RANDOM*  #{{{

Returns a pseudo-random integer value in the specified range.
Synopsis

$RANDOM(range)
$R(range)

Parameter

range  A nonzero positive integer used to calculate the random number.

Description
$RANDOM returns a pseudo-random integer value between 0 and range-1
(inclusive). Returned numbers are uniformly distributed across the specified
range.
$RANDOM is sufficiently random for most purposes. Applications that require
strictly random values should use the $System.Encryption.GenCryptRand() method.
Parameters
range
A nonzero positive integer used to calculate the random number. The range value
can be a nonzero positive integer value, the name of an integer variable, or
any valid Caché ObjectScript expression that evaluates to a nonzero positive
integer. The maximum range value is 1E17 (100000000000000000); specifying a
value beyond this maximum results in a <FUNCTION> error.
Examples
The following example returns a random number from 0 through 24 (inclusive).

   WRITE $RANDOM(25)
To return a random number with a fractional portion, you can use the
concatenation operator (_) or the addition operator (+), as shown in the
following example:

   SET x=$RANDOM(10)_$RANDOM(10)/10
   WRITE !,x
   SET y=$RANDOM(10)+($RANDOM(10)/10)
   WRITE !,y
This program returns numbers with one fractional digit, ranging between .0 and
9.9 (inclusive). Using either operator, Caché deletes any leading and trailing
zeros (and the decimal point, if the fractional portion is zero). However, if
both $RANDOM functions return zero (0 and .0), Caché returns a zero (0).
The following example simulates the roll of two dice.

Dice
   WRITE !,"Do you want to roll the dice?"
   WRITE !, "Press <RETURN> to exit"
   READ !,"Roll Dice",A
   QUIT:A=""
   WRITE !,$RANDOM(6)+1,"+",$RANDOM(6)+1
   GOTO Dice


 #}}}
*$REPLACE*  #{{{

Performs string-for-string replacement within a string.
Synopsis

$REPLACE(string,oldsub,newsub[,start[,count[,case]]])

Parameters

        The target string. It can be a numeric value, a string literal, the
string  name of a variable, or any valid Caché ObjectScript expression. If 
        string is an empty string (""), $REPLACE returns an empty string.

        The substring to search for in string. It can be a numeric value, a
oldsub  string literal, the name of a variable, or any valid Caché ObjectScript
        expression. If oldsub is an empty string (""), $REPLACE returns string.

        The replacement substring substituted for instances of oldsub in string
        . It can be a numeric value, a string literal, the name of a variable,
newsub  or any valid Caché ObjectScript expression. If newsub is an empty
        string (""), $REPLACE returns string with the occurrences of oldsub
        removed.

        Optional  Character count position within string where substring search
        is to begin. String characters are counted from 1. A value of 0, a
        negative number, a nonnumeric string or an empty string are equivalent
start   to 1. If omitted, 1 is assumed. If start > 1, the substring of string
        beginning with that character is returned, with substring substitutions
        (if any) performed. If start > $LENGTH(string), $REPLACE returns the
        empty string ("").

        Optional  Number of substring substitutions to perform. If omitted, the
        default value is -1, which means perform all possible substitutions. A
count   value of 0, a negative number other than -1, a nonnumeric string or an
        empty string are equivalent to 0 which means perform no substitutions. 
        count must be used in conjunction with start.

        Optional  Boolean flag indicating whether matching is to be
case    case-sensitive. 0 = case-sensitive (the default). 1 = not
        case-sensitive. Any nonzero number is equivalent to 1. Any nonnumeric
        value is equivalent to 0.

Description
The $REPLACE function performs string-for-string replacements within a string.
It searches string for the oldsub substring. If $REPLACE finds a match, it
replaces the oldsub substring with newsub. The newsub parameter value may be
long or shorter than oldsub; newsub may be an empty string.
By default, $REPLACE begins at the start of string and replaces every instance
of oldsub. You can use the optional start parameter to begin comparisons at a
specified character count location within the string. The returned string is a
substring of string that begins at the start location and replaces every
instance of oldsub from that point. You can use the optional count parameter to
replace only a specified number of matching substrings.
By default, $REPLACE substring matching is case-sensitive. You can use the
optional case parameter to specify not case-sensitive matching.
$REPLACE supports long strings (strings of > 32K characters) on Caché
implementation in which the Enable Long Strings configuration option has been
specified.
$REPLACE by itself does not change the string parameter. To change the input
string, you must SET it equal to the returned value.
$REPLACE and $TRANSLATE
$REPLACE performs string-for-string matching and replacement. $TRANSLATE
performs character-for-character matching and replacement. $REPLACE can replace
a single specified substring of one or more characters with another substring. 
$TRANSLATE can replace multiple specified characters with corresponding
specified new characters. By default, both functions replace all matching
instances in the string.
Examples
In the following example, invocations of $REPLACE match and substitute for the
all instances of a substring, and the first two instances of a substring:

   SET x="1110/1110/1100/1110"
   WRITE !,"before conversion  ",x
   SET all=$REPLACE(x,"111","AAA")
   WRITE !,"after replacement  ",all
   SET some=$REPLACE(x,"111","AAA",1,2)
   WRITE !,"after replacement  ",some
In the following example, invocations of $REPLACE perform case-sensitive and
not case-sensitive matching and replacement of all occurrences in the string:

   SET x="Yes/yes/Y/YES/Yes"
   WRITE !,"before conversion  ",x
   SET case=$REPLACE(x,"Yes","NO")
   WRITE !,"after replacement  ",case
   SET nocase=$REPLACE(x,"Yes","NO",1,-1,1)
   WRITE !,"after replacement  ",nocase
The following example compares the $REPLACE and $TRANSLATE functions:

   SET x="A mom, o plom, o comal, Pomama"
   WRITE !,"before conversion  ",x
   SET s4s=$REPLACE(x,"om","an")
   WRITE !,"after replacement  ",s4s
   SET c4c=$TRANSLATE(x,"om","an")
   WRITE !,"after translation  ",c4c
$REPLACE returns "A man, o plan, o canal, Panama"
$TRANSLATE returns "A nan, a plan, a canal, Panana"
In the following example, the four-argument form of $REPLACE returns only the
part of the string beginning with the start point, with the string-for-string
replacements performed:

   SET x="A mon, a plon, a conal, Ponona"
   WRITE !,"before start replacement ",x
   SET ret=$REPLACE(x,"on","an",8)
   WRITE !,"after start replacement  ",ret
$REPLACE returns "a plan, a canal, Panama"
See Also

  • $TRANSLATE function
  • $EXTRACT function
  • $PIECE function
  • $REVERSE function
  • $ZCONVERT function


 #}}}
*$REVERSE*  #{{{

Returns the characters in a string in reverse order.
Synopsis

$REVERSE(string)
$RE(string)

Parameter

string  A string or expression that evaluates to a string.

Description
$REVERSE returns the characters in string in reverse order.
Surrogate Pairs
$REVERSE does not recognize surrogate pairs. A surrogate pair is a pair of
16-bit Unicode characters that together encode a single ideographic character.
Surrogate pairs are used to represent some Chinese characters and to support
the Japanese JIS2004 standard. You can use the $WISWIDE function to determine
if a string contains a surrogate pair. The $WREVERSE function recognizes and
correctly parses surrogate pairs. $REVERSE and $WREVERSE are otherwise
identical. However, because $REVERSE is generally faster than $WREVERSE, 
$REVERSE is preferable for all cases where a surrogate pair is not likely to be
encountered.
Examples
The following WRITE commands shows the return value from $REVERSE. The first
returns  CBA , the second returns 321.

   WRITE !,$REVERSE("ABC")
   WRITE !,$REVERSE(123)
You can use the $REVERSE function with other functions to perform search
operations from the end of the string. The following example demonstrates how
you can use $REVERSE with the $FIND and $LENGTH functions to locate the
position of a word within a line of text. It returns 33:

   SET line="THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG."
   SET position=$L(line)+2-$F($RE(line),$RE("THE"))
   WRITE "The second THE in the line begins at ",position
See Also

  • $FIND function
  • $EXTRACT function
  • $LENGTH function
  • $PIECE function
  • $WISWIDE function
  • $WLENGTH function


 #}}}
*$SCONVERT*  #{{{

Converts a binary encoded value to a number.
Synopsis

$SCONVERT(s,format,endian,position)
$SC(s,format,endian,position)

Parameter

s         A string of 8-bit bytes which encode for a number. Limitations on
          valid values are imposed by the format selected.

format    One of the following format codes, specified as a quoted string: S1,
          S2, S4, S8, U1, U2, U4, F4, or F8.

endian    Optional  A boolean value, where 0 = little-endian and 1 =
          big-endian. The default is 0.

          Optional  The character position in the string of 8-bit bytes at
position  which to begin conversion. Character positions are counted from 1.
          The default value is 1. If you specify position, you must also
          specify endian.

Description
$SCONVERT converts s from an encoded string of 8-bit bytes to a numeric value,
using the specified format.
The following are the supported format codes:

S1  Signed integer encoded into a string of one 8-bit bytes. The value must be
    in the range -128 through 127, inclusive.

S2  Signed integer encoded into a string of two 8-bit bytes. The value must be
    in the range -32768 through 32767, inclusive.

S4  Signed integer encoded into a string of four 8-bit bytes. The value must be
    in the range -2147483648 through 2147483647, inclusive.

    Signed integer encoded into a string of eight 8-bit bytes. The value must
S8  be in the range -9223372036854775808 through 9223372036854775807,
    inclusive.

U1  Unsigned integer encoded into a string of one 8-bit bytes. The maximum
    value is 256.

U2  Unsigned integer encoded into a string of two 8-bit bytes. The maximum
    value is 65535.

U4  Unsigned integer encoded into a string of four 8-bit bytes. The maximum
    value is 4294967295.

F4  IEEE floating point number encoded into a string of four 8-bit bytes.

F8  IEEE floating point number encoded into a string of eight 8-bit bytes.

Values beyond the range of format limits result in a <VALUE OUT OF RANGE>
error. Specifying a negative number for an Unsigned format results in a <VALUE
OUT OF RANGE> error. A non-numeric value returns a value of 0 for all formats.
A fractional number returns a value of 0 for all formats except F4 and F8.
$SCONVERT provides the inverse of the $NCONVERT operation.
Examples
The following example converts a series of unsigned numbers to two-byte encoded
values:

  SET x=$NCONVERT(258,"U2")
  ZZDUMP x
  SET y=$SCONVERT(x,"U2")
  WRITE !,y
The following example performs the same operation in big-endian order:

  SET x=$NCONVERT(258,"U2",1)
  ZZDUMP x
  SET y=$SCONVERT(x,"U2",1)
  WRITE !,y
See Also

  • $NCONVERT function


 #}}}
*$SELECT*  #{{{

Returns the value associated with the first true expression.
Synopsis

$SELECT(expression:value,...)
$S(expression:value,...)

Parameters

expression  The select test for the associated value parameter.

value       The value to be returned if the associated expression evaluates to
            true.

Description
The $SELECT function returns the value associated with the first expression
that evaluates to true (1). Each $SELECT argument is a pair of expressions
separated by a colon. The left half is a truth-valued expression. The right
half can be any expression.
The specified list of expression:value pairs can be of any length. $SELECT
evaluates the parameters from left to right. When $SELECT discovers a
truth-valued expression with the value of true (1), it returns the matching
expression to the right of the colon. $SELECT stops evaluation after it
discovers the left-most true truth-valued expression. It never evaluates later
pairs on the parameter list.
Parameters
expression
The select test for the associated value parameter. It can be any valid Caché
relational or logical expression. If no expression evaluates to true, Caché
generates a <SELECT> error. To prevent an error from disrupting an executing
routine, the final expression can be the value 1, which always tests true.
value
The value to be returned if the associated expression evaluates to true. It can
be a numeric value, a string literal, a variable name, or any valid Caché
ObjectScript expression. If you specify an expression for value, it is
evaluated only after the associated expression evaluates to true. If value
contains a subscripted global reference, it changes the naked indicator when it
is evaluated. For this reason, be careful when using naked global references
either within or immediately after a $SELECT function. For more details on the
naked indicator, see Naked Global Reference in Using Caché Globals.
Example
In this example, the $SELECT function selects the destination for the GOTO
based on the user’s input.

Start
   READ !,"Which level: ",a
   QUIT:a=""
   SET x=$SELECT(a=1:"Level1",a=2:"Level2",a=3:"Level3")
   GOTO @x

Notes
Including a Default Value
To ensure that a <SELECT> error never results, you should always include the
value 1 as the last expression with an appropriate default value at the end of
the list. For example:

Start
   READ !,"Which level: ",a
   QUIT:a=""
   SET x=$SELECT(a=1:"Level1",a=2:"Level2",a=3:"Level3",1:"Start")
   GOTO @x

If the user enters a value other then 1, 2, 3, or the null string, control is
passed back to the prompt.
Replacing the IF Command
You can use $SELECT to replace IF command clauses. The following example uses 
IF, ELSEIF, and ELSE clauses to determine whether a number is odd or even.

Odds
   READ !,"ENTER A NUMBER: ",X
   QUIT:X=""
   WRITE !,"THE NUMBER IS "
   IF X#1 { WRITE "NOT AN INTEGER" }
   ELSEIF X#2=1 { WRITE "ODD" }
   ELSE  { WRITE "EVEN" }
   GOTO Odds

The following example also accepts a number and determines if the number is odd
or even. It uses $SELECT to replace the IF command in the previous example:

Odds
   READ !,"ENTER A NUMBER: ", X
   QUIT:X=""
   WRITE !,"NUMBER IS ",$SELECT(X#1:"NOT AN INTEGER",X#2=1:"ODD",1:"EVEN")
      GOTO Odds

See Also

  • $CASE function


 #}}}
*$SORTBEGIN*  #{{{

Initiates a sorting mode to improve performance of multiple sets to a global.
Synopsis

$SORTBEGIN(set_global)

Parameters

set_global  A global variable name.

Description
$SORTBEGIN initiates a special sorting mode during which SET operations to the
specified target global are redirected to a process-private temporary area and
sorted into subsets. This mode is ended with a call to $SORTEND which copies
the data into the target global reference. When the special sorting mode is in
effect, all sets to the target global reference and any of its descendants are
affected.
$SORTBEGIN is designed to help the performance of operations, such as index
building, where a large amount of unordered data needs to be written to a
global. When the amount of data written approaches or exceeds the amount of
available buffer pool memory, performance can suffer drastically. $SORTBEGIN
solves this problem by guaranteeing that data is written to the target global
in sequential order, thus minimizing the number of physical disk accesses
needed. It does this by writing and sorting data into one or more temporary
buffers (using space in the ^CacheTemp global if needed) and then, when 
$SORTEND is called, copying the data sequentially into the target global.
While $SORTBEGIN is in effect, data read from the target global will not
reflect any SET operations. You cannot use $SORTBEGIN in cases where you need
to read global values from the same global in which you are inserting values.
Caché Objects and Caché SQL applications automatically make use of $SORTBEGIN
for index and temporary index creation.
The $SORTBEGIN sorting mode can be terminated without writing data to the
target global by calling $SORTEND with it optional second parameter set to 0.
If successful, $SORTBEGIN returns a nonzero integer value. If unsuccessful, 
$SORTBEGIN returns zero.
Sorting Mode Errors
Invoking some operations between the $SORTBEGIN and $SORTEND result in Caché
issuing an error code:

  • If you issue a $SORTBEGIN and then change the current namespace, a
    <NAMESPACE> error occurs when you invoke $SORTEND.
  • If you establish a $SORTBEGIN global, and then issue a $SORTBEGIN for an
    ancestor or descendent of that global, Caché issues a <DUPLICATEARG> error.
    For example, if you invoke $SORTBEGIN(^test(1,2,3)), the following function
    calls result in a <DUPLICATEARG> error: $SORTBEGIN(^test(1,2)) or 
    $SORTBEGIN(^test(1,2,3,4)).

See Also

  • $SORTEND function


 #}}}
*$SORTEND*  #{{{

Concludes the sorting mode initiated by $SORTBEGIN.
Synopsis

$SORTEND(set_global,dosort)

Parameters

set_global  A global variable name.

            Optional  A flag parameter. If 1, Caché performs the sort operation
dosort      initiated by $SORTBEGIN and copies the sorted data into set_global.
            If 0, Caché terminates the sort operation without copying any data.
            The default is 1.

Description
$SORTEND specifies the end of a special sorting mode initiated by $SORTBEGIN on
a specific target global. The value of set_global must match the corresponding
parameter specified for $SORTBEGIN.
If successful, $SORTEND returns an integer specifying the total number of
global nodes set. If unsuccessful, $SORTEND returns -1.
You may not change the current namespace between $SORTBEGIN and $SORTEND. If
you have changed the current namespace, invoking $SORTEND results in a
<NAMESPACE> error.
See Also

  • $SORTBEGIN function


 #}}}
*$STACK*  #{{{

for variable go |$STACK_var|

Returns information about active contexts saved on the process call stack.
Synopsis

$STACK(context_level,code_string)
$ST(context_level,code_string)

Parameters

               An integer specifying the zero-based context level number of the
context_level  context for which information is requested. Supported values
               include 0, positive integers, and -1.

               Optional  A keyword string that specifies the kind of context
code_string    information that is requested. supported values are  PLACE ,  
               MCODE , and  ECODE 

Description
The $STACK function returns information on either the current execution stack
or the current error stack, depending on the value of the $ECODE special
variable. $STACK is most commonly used to return information on the current
execution stack (also known as the process call stack).
Each time a routine invokes a DO command, an XECUTE command, or a user-defined
function (but not a GOTO command), the context of the currently executing
routine is saved on the call stack and execution starts in the newly created
context of the called routine. The called routine, in turn, can call another
routine, and so on, causing more saved contexts to be placed on the call stack.
The $STACK function returns information about these active contexts saved on
your process call stack. $STACK also can return information about the currently
executing context. However, during error processing, $STACK returns a snapshot
of all the context information that is available when an error occurs in your
application.
You can use the $STACK special variable to determine the current context level.
$ECODE and $STACK
The values returned by $STACK are dependent on the $ECODE special variable. If 
$ECODE is clear (set to the null string), $STACK returns the current execution
stack. If $ECODE contains a non-null value, $STACK returns the current error
stack.
Error stack context information is only available when the $ECODE special
variable contains a non-null value. This can occur either when an error has
occurred or when $ECODE is explicitly set to a non-null value. In this case, 
$STACK returns information about the error stack context rather than an active
stack context at the specified context level.
When error stack context information is not available ($ECODE="") and you
specify the current context level with the two-argument form of $STACK, Caché
returns information about the currently executing command. To ensure consistent
behavior when accessing the current execution stack, specify NEW $ECODE before
calling $STACK.
See Error Handling in Using Caché ObjectScript for more detailed information
about error processing and your error process stack.
The One-Argument Form of $STACK
$STACK(context_level) returns a string that indicates how the specified context
level was established. The following table describes the string values that can
be returned:

DO      Returned when the specified context was established by a DO command.

XECUTE  Returned when the specified context was established by an XECUTE
        command or a BREAK command.

$$      Returned when the specified context was established by a user-defined
        function reference.

        The error code value of the error that caused the specified context to
An      be added to the error stack. For example, ,M26,. When an error occurs
ECODE   at a context level where an error has already occurred, the context
string  information is placed at the next higher error stack level; it is only
        returned when context information at the specified error stack context
        level is relocated information.

When the specified context level is zero (0) or is undefined, $STACK returns
the null string.
You can also specify a -1 for the context level in the one-argument form of the
$STACK function. In this case, $STACK returns the maximum context level for the
information that is available that, during normal processing, is the context
level number of the currently executing context. However, during error
processing, $STACK(-1) returns whichever is greater:

  • The maximum context level of your process error stack
  • The context level number of the currently executing context

The Two-Argument Form of $STACK
$STACK(context_level,code_string) returns information about the specified
context level according to the code_string you specify. A code_string must be
specified as a quoted string; code_string values are not case-sensitive. For
example, $STACK(1,"PLACE") or $STACK(1,"place").
The following describes the code strings and the information returned when you
specify each.

  • PLACE  Returns the entry reference and command number of the last command
    executed at a specified context level. The value is returned in the
    following format for DO and user-defined function contexts: "label[+offset]
    [^routine name] +command". For XECUTE contexts, the following format is
    used: "@ +command".
  • MCODE  Returns the source routine line, XECUTE string, or $ETRAP string
    that contains the last command executed at the specified context level.
    (Routine lines are returned in the same manner as those returned by the 
    $TEXT function.)
    Note:
    During error processing, if memory is low while the error stack is being
    built or updated, you may not have enough memory to store the source line.
    In this case, the return value for the MCODE code string is the null
    string. However, the return value for the PLACE code string indicates the
    location.
  • ECODE  The error code of any error that occurred at the specified context
    level (available only in error stack contexts).

When the requested information is not available at the specified context level,
the two argument form of $STACK returns the null string.
Example
The following example demonstrates some of the information that $STACK can
return:

STAC  ;
      NEW $ECODE
      XECUTE "DO First"
      QUIT
First SET varSecond=$$Second()
      QUIT
Second()  FOR loop=0:1:$STACK(-1) {
          WRITE !,"Context level:",loop,?25,"Context type: ",$STACK(loop)
          WRITE !,?5,"Current place: ",$STACK(loop,"PLACE")
          WRITE !,?5,"Current source: ",$STACK(loop,"MCODE")
          WRITE ! }
      QUIT 1

>DO  ^STAC
Context level: 0      Context type:
  Current place: @ +1
  Current source: DO ^STAC
Context level: 1      Context type: DO
  Current place: STAC+2^STAC +1
  Current source: XECUTE "DO First"
Context level: 2      Context type: XECUTE
  Current place: @ +1
  Current source: DO First
Context level: 3      Context type: DO
  Current place: First^STAC +1
  Current source: First SET Second=$$Second
Context level: 4      Context type: $$
  Current place: Second+2^STAC +4
  Current source: WRITE !,?5,"Current source: ",$STACK(loop,"MCODE")

Notes
Cross-Namespace Routine Calls
If a routine calls a routine in a different namespace, $STACK returns the
namespace name as part of the routine name. For example, if a routine in the
USER namespace calls a routine in the SAMPLES namespace, $STACK returns 
^|"SAMPLES"|routinename.
$STACK uses the caret (^) character as a delimiter. Therefore, if an implied
namespace name includes the caret (^) character, Caché displays this namespace
name character as the @ character.
$STACK Counts Multiple-Argument Commands
When you specify a multiple-argument command, the command count includes
command keywords and all command arguments beyond the first. Consider the
following multiple-argument command:

TEST
  SET X=1,Y=Z

In Caché, the $STACK statement, $STACK(1,"PLACE") returns "TEST^TEST +2"
because the Y=Z argument counts as a separate command.
$STACK with <STORE> Errors or Low Memory Conditions
After a <STORE> error or under low-memory conditions, the information available
normally through the application of the two-argument form of $STACK may not be
available.
See Also

  • DO command
  • XECUTE command
  • $ECODE special variable
  • $ESTACK special variable
  • $STACK special variable
  • Error Handling in Using Caché ObjectScript


 #}}}
*$TEXT*  #{{{

Returns a line of source code found at the specified location.
Synopsis

$TEXT(label+offset^routine)
$TEXT(@expr_atom)
$T(label+offset^routine)
$T(@expr_atom)

Parameter

label       Optional  A line label in a routine.

+offset     Optional  A positive integer that identifies the line to be
            returned.

^routine    Optional  A separate routine that resides on disk.

@expr_atom  Optional  An expression atom that uses indirection to supply a
            location.

Description
$TEXT returns a line of source code found at the specified location. The source
code is returned as text and is not executed at the reference point. If $TEXT
does not find source code at the specified location, it returns the null
string.
In the returned source code, if the first whitespace character in the line is a
tab, $TEXT replaces it with a single space character. All other tabs and space
characters are returned unchanged. Thus $PIECE($TEXT(line)," ",1) always
returns a label, and $PIECE($TEXT(line)," ",2,99) returns all code except a
label.
$TEXT does not recognize the Return character that terminates the line.
Parameters
label
The label within the current routine or, if the routine parameter is also
supplied, in a separate routine.
offset
If specified alone, the offset indicates a line number within the current
routine. If specified with the label parameter, the line number is calculated
from the start of the label. If specified with routine (and without label), the
line number is calculated from the start of the separate routine.
routine
If specified alone, it indicates the first line of code in the routine. If
specified with only the label parameter, the line found at that specified label
within the routine is returned. If specified with only the offset parameter,
the line at the specified offset within the routine is returned. If both label
and offset are supplied, the line found at the specified offset within the
specified label within the routine is returned.
expression atom (@expr_atom)
An indirect argument that evaluates to a $TEXT argument (label+offset^routine).
For more information, refer to Indirection in Using Caché ObjectScript.
Examples
This example shows the $TEXT(label) form, which returns the line found at the
specified label within the current routine. The label is also returned. If the
user enters "?", the Info text is written out, along with the line label, and
control returns to the initial prompt:

Start  READ !,"Array name or ? for Info: ",ary QUIT:ary=""
  IF ary="?" {
    WRITE !,$TEXT(Info),! GOTO Start }
Info  ;; This routine outputs the entire contents of a global array.
    QUIT

This example shows the $TEXT(label+offset) form, which returns the line found
at the offset within the specified label, which must be within the current
routine. If the offset is 0, the label line, with the label, is returned. You
can use this form in a FOR loop, to access multiline text:

Start READ !,"Array name or ? for Info: ",ary QUIT:ary=""
  IF ary="?" {
    DO Info
    GOTO Start
  }
Info  FOR loop=1:1:5 { WRITE !,$TEXT(Info+loop) }
  ;;   This routine outputs the entire contents of a global array.
  ;;  Specifically, it asks you to supply the name of the array
  ;;  and then writes out the current values for all existing
  ;;  nodes that contain data. It ignores any nodes
  ;;  that do not contain data.
  QUIT

This example shows the $TEXT(+offset) form, which returns the line found at the
specified offset within the current routine. This form is similar to the
previous form except that no label is used. If the offset is 0, $TEXT returns
the name of the current routine as filed on disk. Note that the routine name
may be different from the line label in the file. Like the previous form, this
form can be used in a FOR loop to access multiline text:

  ;
  ;  This routine outputs the entire contents of a global array.
  ;;  Specifically, it asks you to supply the name of the array
  ;;  and then writes out the current values for all existing
  ;;  nodes that contain data.  It ignores any nodes
  ;;  that do not contain data.
Start    READ !,"Array name: ",ary QUIT:ary=""
  IF ary="?" { GOTO Start }
  FOR i=1:1:5 {
    WRITE !,$TEXT(+i) }

Notes
Argument Indirection
Indirection of the entire $TEXT argument is a convenient way to make an
indirect reference to both the line and the routine. For example, if the
variable ENTRYREF contains both a line label and a routine name, you can
reference the variable:

$TEXT(@ENTRYREF)

rather than referencing the line and the routine separately:

$TEXT(@$PIECE(ENTRYREF,"^",1)^@$PIECE(ENTRYREF,"^",2))

Edit Pointer
If you specify a routine in $TEXT other than the current routine, Caché resets
the edit pointer (current line location) to +0. This can affect execution of
the ZINSERT command. You can use $ZNAME to determine the current routine.
See Also

  • Indirection in Using Caché ObjectScript


 #}}}
*$TRANSLATE*  #{{{

Performs character-for-character replacement within a string.
Synopsis

$TRANSLATE(string,identifier,associator)
$TR(string,identifier,associator)

Parameters

string      The target string. It can be a numeric value, a string literal, the
            name of a variable, or any valid Caché ObjectScript expression.

            The character(s) to search for in string. It can be a numeric
identifier  value, a string literal, the name of a variable, or any valid Caché
            ObjectScript expression.

            Optional  The replacement character(s) corresponding to each
associator  character in the identifier. It can be a numeric value, a string
            literal, the name of a variable, or any valid Caché ObjectScript
            expression.

Description
The $TRANSLATE function performs character-for-character replacement within a
string. It processes the string parameter one character at a time. Initially, 
$TRANSLATE sets the output string to the input string. It compares each
character in the input string with each character in the identifier parameter.
If $TRANSLATE finds a match, it makes note of the position of that character.

  • The two-argument form of $TRANSLATE removes those characters in the 
    identifier parameter from the output string.
  • The three-argument form of $TRANSLATE replaces the identifier character(s)
    found in the string with the positionally corresponding character(s) from
    the associator parameter. Replacement is performed on a character, not a
    string, basis. If the identifier parameter contains fewer characters than
    the associator parameter, the excess character(s) in the associator
    parameter are ignored. If the identifier parameter contains more characters
    than the associator parameter, the excess character(s) in the identifier
    parameter are deleted in the output string.

$TRANSLATE is case-sensitive.
$TRANSLATE by itself does not change the string parameter. To change the input
string, you must SET it equal to a translation of itself.
$TRANSLATE and $REPLACE
$TRANSLATE performs character-for-character matching and replacement. $REPLACE
performs string-for-string matching and replacement. $REPLACE can replace a
single specified substring of one or more characters with another substring, or
remove multiple instances of a specified substring. $TRANSLATE can replace
multiple specified characters with corresponding specified replacement
characters.
By default, both functions are case-sensitive, start at the beginning of string
, and replace all matching instances. $REPLACE has parameters that can be used
to change these defaults.
Examples
In this example, the second SET command uses $TRANSLATE to remove the commas
and produce a valid number, 1462543.

   SET x="1,462,543"
   WRITE !,"before translation ",x
   SET x=$TRANSLATE(x,",")
   WRITE !,"after translation  ",x
This example shows use of the three-argument $TRANSLATE and nested $TRANSLATE
functions. The outermost $TRANSLATE function returns the string "06/23/93". The
original "1" is replaced by "9" and the original occurrences of "9" are
deleted. The hyphens are replaced by slashes.

   SET x="06-23-1993"
   WRITE !,"before translation ",x
   SET x=$TRANSLATE($TRANSLATE(x,"199","9"),"-","/")
   WRITE !,"after translation  ",x
If a character appears multiple times in the identifier, the first (leftmost)
occurrence of the character is used to position the replacement. As a result,
you cannot use $TRANSLATE to remove multiple occurrences of a character from a
string. For example, if the innermost $TRANSLATE in the previous example were
specified as:

  SET x = $TRANSLATE(x,"1993","93")

It would result in the undesirable value "06/2/933". In the original string
("06-23-1993"), the "1" is replaced by "9" and each occurrence of "9" is
replaced by "3". The original occurrences of "3" are removed since "3" is an
excess character in identifier. This is a case of attempting to use $TRANSLATE
to perform string, rather than character replacement.
See Also

  • $EXTRACT function
  • $PIECE function
  • $REPLACE function
  • $REVERSE function
  • $ZCONVERT function


 #}}}
*$VIEW*  #{{{

Returns the contents of memory locations.
Synopsis

$VIEW(offset,mode,length)
$V(offset,mode,length)

Parameters

offset  An offset, in bytes, from a base address within the memory region
        specified by mode. Interpretation is mode-dependent (see below.)

mode    Optional  The memory region whose base address will be used to locate
        the data. Default is -1.

length  Optional  The length of the data to be returned, in bytes. May also
        contain a letter  O reverse order suffix. Default is 1.

Description
$VIEW returns the contents of memory locations.
The view buffer is a special memory area used to store blocks of data read from
the Caché database (CACHE.DAT) with the VIEW command. After reading a block
into the view buffer, you can use the $VIEW function with the special 0 mode to
examine the contents of the view buffer.
The $VIEW function is usually used when debugging and repairing Caché databases
and system information.
Parameters
offset
The value of this argument depends upon the mode argument, as follows:

  • When mode is 0, -1, or -2, specify a positive integer as the offset from
    the base address, in bytes, counting from 0.
  • When mode is -3, or a positive integer, specify -1, which represents the
    base address in the virtual address space for the process. (Offset is not
    meaningful in a virtual address space.)
  • When mode is -5, specify a positive integer that specifies the number of
    global nodes in the current block. In this case, odd values return full
    global references and even values return pointers or data.

mode
The possible values for mode are shown in the following table. If mode is
omitted, the default is -1. Note that some values are implementation specific.
Implementation restrictions are noted in the table.

Mode                Memory Management Region                   Base Address

0     The view buffer                                       Beginning of view
                                                            buffer

-1    The process’s partition (default)                     Beginning of
                                                            partition

-2    The system table                                      Beginning of system
                                                            table

-3    The virtual address space for the current process.    0

                                                            Special. See  Using
-5    Global reference and data                             Mode -5, later in
                                                            the Notes section.

-6    Reserved for InterSystems use                          

-7    Used only by the integrity checking utility           Special.

      When n is a positive number, the virtual address
      space for the running process n, where n is the pid
n     (value of the $JOB special variable) for that         0
      process. Treats offset and length the same as mode
      -3.

The following example shows two equivalent $VIEW statements, the first of which
takes the mode and length argument defaults:

  OPEN 63
  WRITE !,$VIEW(0)
  WRITE !,$VIEW(0,-1,1)
  CLOSE 63
length
A length in bytes. May contain a letter  O reverse order suffix (as described
in Notes below).

  • When mode is 0, -1, or -2, specify a negative integer from -1 to -8192 to
    return that length of data as a string. $VIEW returns the specified number
    of characters (from 1 to 8192) starting at the address indicated by offset.
    To return the decimal value of the data, specify a positive integer from 1
    to 4. $VIEW returns from one to four contiguous bytes starting at the
    address indicated by offset. You can also use the letter C to indicate a
    four-byte address or the letter P to indicate a four-byte word address.
    Specify both the P or C and the positive integer in double quotes. To
    return a byte value in reverse order (low-order byte at lowest address)
    append the letter O to the length number and enclose both in double quotes.
    If the length parameter is omitted for modes 0, -1, and -2, the default is
    1.
  • When mode is -3, or a positive integer, the full length of the data is
    returned, regardless of the length parameter. Specify a length of 1 to
    return the decimal value of the data. Specify a negative integer (-1) to
    return the data as a string. If the length parameter is omitted, the
    default is 1.
  • When mode is -5, do not specify a length parameter.

Notes
Process Virtual Address Space
Use mode -3 to return the value from the current process' virtual address
space, as shown in this example:

  WRITE $VIEW(-1,-3,1)
To return the virtual address space of a specified process, provide the Process
ID (pid) for that process  rather than -3  for the second argument, as shown in
this example:

  SET pid=$PIECE($IO,"|",4)
  WRITE $VIEW(-1,pid,1)
The value returned is in the following format:

pid^mode^dev^mem^dir^rou^stat^prio^uic^loc^blk^^^defns^lic^jbstat

The fields are defined as follows: pid=the process ID. mode=* if in programmer
mode, + or  if the job is part of a callin connection, omitted for daemons. dev
=current open device(s), returned as a comma-separated list. The principal
device is indicated by an asterisk (*) suffix. mem=memory in use in the process
partition (in KBs), if the process is not a daemon. dir=default directory. rou=
routine name. stat=bol,gcnt where bol is the beginning of line token,
specifying the number of lines executed, and gcnt is the global count,
specifying the total number of FOR loops and XECUTE commands performed. prio=
user’s current base priority. uic=(no longer used by Caché security at version
5.1 and subsequent) high,low representing the high and low order bits of the
User Identification Code (uic). loc=location, for daemon processes only. blk=
number of 2K blocks that can be used for buddy block queues. defns=default
namespace. lic=license bits. jbstat=job status, specified as high,low
representing the high and low order bits. Refer to $ZJOB special variable for
details.
Using Mode -5
If the current block in the view buffer contains part of a global, specifying
-5 for mode returns the global references and the values contained in the
block. The length parameter is not valid for a mode of -5.
With a mode of -5, the offset value specifies the number of global nodes in the
block, rather than a byte offset from the base address. Odd values return full
global references and even values return pointers or data.
For example, to return the full global reference of the nth node in the view
buffer, specify n*2-1 for offset. To return the value of the nth node, specify 
n*2. To return the global reference of the last node in the block, specify -1
for the offset value.
$VIEW returns the nodes in collating sequence (that is, numeric). This is the
same sequence that the $ORDER function uses. By writing code that expects this
sequence, you can quickly perform a sequential scan through a global in the
view buffer. (Several of the Caché utilities use this technique.) $VIEW returns
a null string ("") if the offset specifies a location beyond the last node in
the view buffer. Be sure to include a test for this value in your code.
If the current block is a pointer block, the values returned are Caché block
numbers, which are pointers. If the block is a data block, the values returned
are the data values associated with the nodes.
If $VIEW issues a <DATABASE> or <FUNCTION> error, it means that the information
in the block is neither a valid global reference nor valid data.
The following example shows generalized code for examining the contents of the
view buffer. The code first opens the view buffer and prompts for the number of
the block to be read in. The FOR loop then cycles through all the offsets in
the current block. The $VIEW function uses a mode of -5 to return the value at
each offset. The WRITE commands output the resulting offset-value pairs.
When the end of the block is reached, $VIEW returns a null string (""). The IF
command tests for this value and writes out the  End of block message. The QUIT
command then terminates the loop and control returns to the prompt so the user
can read in another block.

Start OPEN 63
      WRITE !,"Opening view buffer."
      READ !!,"Number of block to read in: ",block QUIT:block=""
      VIEW block
         FOR i=1:1 {
               SET x=$VIEW(i,-5)
               IF x="" {
                    WRITE !!,"End of block: ",block
                    CLOSE 63
                    QUIT }
               WRITE !,"Offset = ",i
               WRITE !,"Value = ",x
        }
        GOTO Start+2
        CLOSE 63
        QUIT

For a global block, typical output produced by this routine might appear as
follows:

Opening view buffer.
Number of block to read in:3720
Offset = 1
Value = ^client(5)
Offset = 2
Value = John Jones
Offset = 3
Value = ^client(5,1)
Offset = 4
Value = 23 Bay Rd./Boston/MA 02049
 .
 .
 .
Offset = 126
Value = ^client(18,1,1)
Offset = 127
Value = Checking/45673/1248.00
End of block: 3720
Number of block to read in:

Reverse Order Byte Values (Big-Endian only)
On big-endian systems, you can return byte values in reverse order by using a
letter  O suffix as part of the length parameter. When you specify the letter O
in length, $VIEW returns a byte value in reverse order. (The length value must
be enclosed in double quotes.) This is shown in the following example:

   USE IO
   FOR Z=0:0 {
      WRITE *-6
      SET NEXTBN=$VIEW(LINKA,0,"3O")
      QUIT:NEXTBN=0 }

In the example above, the length parameter of $VIEW is  3O (3 and the letter
O). When run on a big-endian system, this specifies a length of the next three
(3) bytes in reverse order (O). Thus, $VIEW starts at a position in memory (the
view buffer as indicated by a mode of 0) and returns the highest byte, the
second highest byte, and the third highest byte.
On little-endian systems, the letter  O is a no-op. A length value of  3O is
the same as a length value of  3 .
See Also

  • VIEW command
  • JOB command
  • $ZUTIL(49) Obtain Database Label Information function
  • Error Handling in Using Caché ObjectScript


 #}}}
*$WASCII*  #{{{

Returns the numeric code corresponding to a character, recognizing surrogate
pairs.
Synopsis

$WASCII(expression,position)
$WA(expression,position)

Parameter

expression  The character to be converted.

position    Optional  The position of a character within a character string,
            counting from 1. The default is 1.

Description
$WASCII returns the character code value for a single character specified in 
expression. $WASCII recognizes a surrogate pair as a single character. The
returned value is a positive integer.
The expression parameter may evaluate to a single character or to a string of
characters. If expression evaluates to a string of characters, you can include
the optional position parameter to indicate which character you want to
convert. The position counts a surrogate pair as a single character. You can
use the $WISWIDE function to determine if a string contains a surrogate pair.
A surrogate pair is a pair of 16-bit Unicode characters that together encode a
single ideographic character. Surrogate pairs are used to represent certain
ideographs which are used in Chinese, Japanese kanji, and Korean hanja. (Most
commonly-used Chinese, kanji, and hanja characters are represented by standard
16-bit Unicode encodings.) Surrogate pairs provide Caché support for the
Japanese JIS X0213:2004 (JIS2004) encoding standard and the Chinese GB18030
encoding standard.
A surrogate pair consists of high-order Unicode character in the hexadecimal
range D800 through DBFF, and a low-order Unicode character in the hexadecimal
range DC00 through DFFF.
The $WASCII function recognizes a surrogate pair as a single character. The 
$ASCII function treats a surrogate pair as two characters. In all other
aspects, $WASCII and $ASCII are functionally identical. However, because $ASCII
is generally faster than $WASCII, $ASCII is preferable for all cases where a
surrogate pair is not likely to be encountered. For further details on
character to numeric code conversion, refer to the $ASCII function.
Example
The following example shows $WASCII returning the Unicode value for a surrogate
pair:

  SET hipart=$CHAR($ZHEX("D806"))
  SET lopart=$CHAR($ZHEX("DC06"))
  WRITE !,$ASCII(hipart)," = high-order value"
  WRITE !,$ASCII(lopart)," = low-order value"
  SET spair=hipart_lopart /* surrogate pair */
  SET xpair=hipart_hipart /* NOT a surrogate pair */
  WRITE !,$WASCII(spair)," = surrogate pair value"
  WRITE !,$WASCII(xpair)," = Not a surrogate pair"
The following example compares $WASCII and $ASCII return values for a surrogate
pair:

  SET hipart=$CHAR($ZHEX("D806"))
  SET lopart=$CHAR($ZHEX("DC06"))
  WRITE !,$ASCII(hipart)," = high-order value"
  WRITE !,$ASCII(lopart)," = low-order value"
  SET spair=hipart_lopart /* surrogate pair */
  WRITE !,$ASCII(spair)," = $ASCII value for surrogate pair"
  WRITE !,$WASCII(spair)," = $WASCII value for surrogate pair"
The following example shows the effects on position counting of surrogate
pairs. It returns both the $WASCII and $ASCII values for each position. $WASCII
counts a surrogate pair as one position; $ASCII counts a surrogate pair as two
positions:

  SET hipart=$CHAR($ZHEX("D806"))
  SET lopart=$CHAR($ZHEX("DC06"))
  WRITE !,$ASCII(hipart)," = high-order value"
  WRITE !,$ASCII(lopart)," = low-order value",!
  SET str="AB"_lopart_hipart_lopart_"CD"_hipart_lopart_"EF"
  FOR x=1:1:11 {
  WRITE !,"position ",x," $WASCII ",$WASCII(str,x)," $ASCII ",$ASCII(str,x) }
See Also

  • $ASCII function
  • $WCHAR function
  • $WEXTRACT function
  • $WFIND function
  • $WISWIDE function
  • $WLENGTH function
  • $WREVERSE function


 #}}}
*$WCHAR*  #{{{

Returns the character corresponding to a numeric code, recognizing surrogate
pairs.
Synopsis

$WCHAR(expression,...)
$WC(expression,...)

Parameter

expression  The integer value to be converted.

Description
$WCHAR returns the character(s) corresponding to a code value(s) specified in 
expression. Decimal values of 65535 (hex FFFF) and smaller are processed
identically by $CHAR and $WCHAR. Values from 65536 (hex 10000) through 1114111
(hex 10FFFF) are used to represent Unicode surrogate pairs; these characters
can be returned using $WCHAR.
If expression contains a comma-separated list of code values, $WCHAR returns
the corresponding characters as a string. $WCHAR recognizes a surrogate pair as
a single character. You can use the $WISWIDE function to determine if a string
contains a surrogate pair.
A surrogate pair is a pair of 16-bit Unicode characters that together encode a
single ideographic character. Surrogate pairs are used to represent certain
ideographs which are used in Chinese, Japanese kanji, and Korean hanja. (Most
commonly-used Chinese, kanji, and hanja characters are represented by standard
16-bit Unicode encodings.) Surrogate pairs provide Caché support for the
Japanese JIS X0213:2004 (JIS2004) encoding standard and the Chinese GB18030
encoding standard.
A surrogate pair consists of high-order Unicode character in the hexadecimal
range D800 through DBFF, followed by a low-order Unicode character in the
hexadecimal range DC00 through DFFF.
The $WCHAR function treats a surrogate pair as a single character. The $CHAR
function treats a surrogate pair as two characters. In all other aspects, 
$WCHAR and $CHAR are functionally identical. However, because $CHAR is
generally faster than $WCHAR, $CHAR is preferable for all cases where a
surrogate pair is not likely to be encountered.
For further details on numeric code to character conversion, refer to the $CHAR
function.
See Also

  • $CHAR function
  • $WASCII function
  • $WEXTRACT function
  • $WFIND function
  • $WISWIDE function
  • $WLENGTH function
  • $WREVERSE function


 #}}}
*$WEXTRACT*  #{{{

Extracts specified characters from a character string, recognizing surrogate
pairs.
Synopsis

$WEXTRACT(string,from,to)
$WE(string,from,to)

Parameter

string  An expression that evaluates to the target string from which the
        substring is to be extracted.

        Optional  The starting position within the target string from which to
        extract a character or the beginning of a range of characters.
        Different values are used for the two-parameter form 
        $WEXTRACT(string,from), and the three-parameter form 
        $WEXTRACT(string,from,to):
        Without to: Specifies a single character. Specify either an expression
        that evaluates to a positive integer (counting from 1), an asterisk
        (which specifies the last character of the string), or an asterisk
from    followed by an expression that evaluates to a negative integer (which
        specifies a start position counting backwards from the last character
        of the string). A zero (0) or negative number returns the empty string.
        With to: Specifies the start of a range of characters. Either specify
        an expression that evaluates to a positive integer (counting from 1) or
        an asterisk followed by an expression that evaluates to a negative
        integer (which specifies a start position counting backwards from the
        last character of the string). A zero (0) or negative number evaluates
        as 1.

        Optional  The end position (inclusive) for a range of characters to be
        extracted, counting from the beginning or end of string. Specify either
to      a positive integer (counting from 1), an asterisk (which specifies the
        last character of the string), or an asterisk followed by a negative
        integer (which specifies an end position counting backwards from the
        last character of the string).

Description
$WEXTRACT returns the specified substring from string. $WEXTRACT recognizes a
surrogate pair as a single character.
The optional from and to parameters count a surrogate pair as a single
character. You can use the $WISWIDE function to determine if a string contains
a surrogate pair.
A surrogate pair is a pair of 16-bit Unicode characters that together encode a
single ideographic character. Surrogate pairs are used to represent certain
ideographs which are used in Chinese, Japanese kanji, and Korean hanja. (Most
commonly-used Chinese, kanji, and hanja characters are represented by standard
16-bit Unicode encodings.) Surrogate pairs provide Caché support for the
Japanese JIS X0213:2004 (JIS2004) encoding standard and the Chinese GB18030
encoding standard.
A surrogate pair consists of high-order Unicode character in the hexadecimal
range D800 through DBFF, and a low-order Unicode character in the hexadecimal
range DC00 through DFFF.
The $WEXTRACT function treats a surrogate pair as a single character. The 
$EXTRACT function treats a surrogate pair as two characters. In all other
aspects, $WEXTRACT and $EXTRACT are functionally identical. However, because 
$EXTRACT is generally faster than $WEXTRACT, $EXTRACT is preferable for all
cases where a surrogate pair is not likely to be encountered. For further
details on extracting a substring, refer to the $EXTRACT function.
Example
The following example shows $WEXTRACT returning the Unicode value for a
surrogate pair:

  SET hipart=$CHAR($ZHEX("D806"))
  SET lopart=$CHAR($ZHEX("DC06"))
  SET spair=hipart_lopart /* surrogate pair */
  SET x="ABC"_spair_"DEFGHIJK"
   WRITE !,"$EXTRACT character "
   ZZDUMP $EXTRACT(x,4)
   WRITE !,"$WEXTRACT character "
   ZZDUMP $WEXTRACT(x,4)
The following example shows $WEXTRACT including a surrogate pair in a substring
range:

  SET hipart=$CHAR($ZHEX("D806"))
  SET lopart=$CHAR($ZHEX("DC06"))
  SET spair=hipart_lopart /* surrogate pair */
  SET x="ABC"_spair_"DEFGHIJK"
   WRITE !,"$EXTRACT two characters "
   ZZDUMP $EXTRACT(x,3,4)
   WRITE !,"$WEXTRACT two characters "
   ZZDUMP $WEXTRACT(x,3,4)
See Also

  • $EXTRACT function
  • $WASCII function
  • $WCHAR function
  • $WFIND function
  • $WISWIDE function
  • $WLENGTH function
  • $WREVERSE function


 #}}}
*$WFIND*  #{{{

Finds a substring by value and returns an integer specifying its end position
in the string, recognizing surrogate pairs.
Synopsis

$WFIND(string,substring,position)
$WF(string,substring,position)

Parameter

           The target string that is to be searched. It can be a variable name,
string     a numeric value, a string literal, or any valid Caché ObjectScript
           expression that resolves to a string.

           The substring that is to be searched for. It can be a variable name,
substring  a numeric value, a string literal, or any valid Caché ObjectScript
           expression that resolves to a string.

position   Optional  A position within the target string at which to start the
           search. It must be a positive integer.

Description
$WFIND returns an integer specifying the end position of a substring within a
string. In calculating position, it counts each surrogate pair as a single
character. $WFIND is functionally identical to $FIND, except that $WFIND
recognizes surrogate pairs. It counts a surrogate pair as a single character.
A surrogate pair is a pair of 16-bit Unicode characters that together encode a
single ideographic character. Surrogate pairs are used to represent certain
ideographs which are used in Chinese, Japanese kanji, and Korean hanja. (Most
commonly-used Chinese, kanji, and hanja characters are represented by standard
16-bit Unicode encodings.) Surrogate pairs provide Caché support for the
Japanese JIS X0213:2004 (JIS2004) encoding standard and the Chinese GB18030
encoding standard.
A surrogate pair consists of high-order Unicode character in the hexadecimal
range D800 through DBFF, and a low-order Unicode character in the hexadecimal
range DC00 through DFFF. You can use the $WISWIDE function to determine if a
string contains a surrogate pair.
The $WFIND function counts a surrogate pair as a single character. The $FIND
function counts a surrogate pair as two characters. In all other aspects, 
$WFIND and $FIND are functionally identical. However, because $FIND is
generally faster than $WFIND, $FIND is preferable for all cases where a
surrogate pair is not likely to be encountered.
For further details on finding a substring, refer to the $FIND function.
Example
The following example shows how $WFIND counts a surrogate pair as a single
character in the return value:

  SET spair=$CHAR($ZHEX("D806"),$ZHEX("DC06"))
  SET str="ABC"_spair_"DEF"
  WRITE !,$FIND(str,"DE")," $FIND location in string"
  WRITE !,$WFIND(str,"DE")," $WFIND location in string"
The following example shows how $WFIND counts a surrogate pair as a single
character in the position parameter:

  SET spair=$CHAR($ZHEX("D806"),$ZHEX("DC06"))
  SET str="ABC"_spair_"DEF"
  WRITE !,$FIND(str,"DE",6)," $FIND location in string"
  WRITE !,$WFIND(str,"DE",6)," $WFIND location in string"
See Also

  • $FIND function
  • $WASCII function
  • $WCHAR function
  • $WEXTRACT function
  • $WISWIDE function
  • $WLENGTH function
  • $WREVERSE function


 #}}}
*$WISWIDE*  #{{{

Returns a flag indicating whether a string contains surrogate pairs.
Synopsis

$WISWIDE(string)

Parameter

string  A string or expression that evaluates to a string.

Description
$WISWIDE returns a boolean value indicating whether string contains surrogate
pairs. 0=string does not contain any surrogate pairs. 1=string contains one or
more surrogate pairs.
A surrogate pair is a pair of 16-bit Unicode characters that together encode a
single ideographic character. Surrogate pairs are used to represent certain
ideographs which are used in Chinese, Japanese kanji, and Korean hanja. (Most
commonly-used Chinese, kanji, and hanja characters are represented by standard
16-bit Unicode encodings.) Surrogate pairs provide Caché support for the
Japanese JIS X0213:2004 (JIS2004) encoding standard and the Chinese GB18030
encoding standard.
A surrogate pair consists of high-order Unicode character in the hexadecimal
range D800 through DBFF, and a low-order Unicode character in the hexadecimal
range DC00 through DFFF.
Example
The following example shows $WISWIDE returning a boolean for a surrogate pair:

  SET spair=$CHAR($ZHEX("D806"),$ZHEX("DC06")) /* surrogate pair */
  SET xpair=$CHAR($ZHEX("DC06"),$ZHEX("D806")) /* NOT a surrogate pair */
  SET str="AB"_spair_"CD"
  WRITE !,$WISWIDE(str)," = surrogate pair(s) in string?"
  SET xstr="AB"_xpair_"CD"
  WRITE !,$WISWIDE(xstr)," = surrogate pair(s) in string?"
See Also

  • $WASCII function
  • $WCHAR function
  • $WEXTRACT function
  • $WFIND function
  • $WLENGTH function
  • $WREVERSE function


 #}}}
*$WLENGTH*  #{{{

Returns the number of characters in a string, recognizing surrogate pairs.
Synopsis

$WLENGTH(string)
$WL(string)

Parameter

string  A string or expression that evaluates to a string.

Description
$WLENGTH returns the number of characters in string. $WLENGTH is functionally
identical to $LENGTH, except that $WLENGTH recognizes surrogate pairs. It
counts a surrogate pair as a single character.
A surrogate pair is a pair of 16-bit Unicode characters that together encode a
single ideographic character. Surrogate pairs are used to represent certain
ideographs which are used in Chinese, Japanese kanji, and Korean hanja. (Most
commonly-used Chinese, kanji, and hanja characters are represented by standard
16-bit Unicode encodings.) Surrogate pairs provide Caché support for the
Japanese JIS X0213:2004 (JIS2004) encoding standard and the Chinese GB18030
encoding standard.
A surrogate pair consists of high-order Unicode character in the hexadecimal
range D800 through DBFF, and a low-order Unicode character in the hexadecimal
range DC00 through DFFF. You can use the $WISWIDE function to determine if a
string contains a surrogate pair.
The $WLENGTH function counts a surrogate pair as a single character. The 
$LENGTH function counts a surrogate pair as two characters. In all other
aspects, $WLENGTH and $LENGTH are functionally identical. However, because 
$LENGTH is generally faster than $WLENGTH, $LENGTH is preferable for all cases
where a surrogate pair is not likely to be encountered.
For further details on string length, refer to the $LENGTH function.
Example
The following example shows how $WLENGTH counts a surrogate pair as a single
character:

  SET spair=$CHAR($ZHEX("D806"),$ZHEX("DC06"))
  SET str="AB"_spair_"CD"
  WRITE !,$LENGTH(str)," $LENGTH characters in string"
  WRITE !,$WLENGTH(str)," $WLENGTH characters in string"
See Also

  • $LENGTH function
  • $WASCII function
  • $WCHAR function
  • $WEXTRACT function
  • $WFIND function
  • $WISWIDE function
  • $WREVERSE function


 #}}}
*$WREVERSE*  #{{{

Returns the characters in a string in reverse order, recognizing surrogate
pairs.
Synopsis

$WREVERSE(string)
$WRE(string)

Parameter

string  A string or expression that evaluates to a string.

Description
$WREVERSE returns the characters in string in reverse order. $WREVERSE is
functionally identical to $REVERSE, except that $WREVERSE recognizes surrogate
pairs.
A surrogate pair is a pair of 16-bit Unicode characters that together encode a
single ideographic character. Surrogate pairs are used to represent certain
ideographs which are used in Chinese, Japanese kanji, and Korean hanja. (Most
commonly-used Chinese, kanji, and hanja characters are represented by standard
16-bit Unicode encodings.) Surrogate pairs provide Caché support for the
Japanese JIS X0213:2004 (JIS2004) encoding standard and the Chinese GB18030
encoding standard.
A surrogate pair consists of high-order Unicode character in the hexadecimal
range D800 through DBFF, and a low-order Unicode character in the hexadecimal
range DC00 through DFFF. You can use the $WISWIDE function to determine if a
string contains a surrogate pair.
The $WREVERSE function counts a surrogate pair as a single character. The 
$REVERSE function treats a surrogate pair as two characters. In all other
aspects, $WREVERSE and $REVERSE are functionally identical. However, because 
$REVERSE is generally faster than $WREVERSE, $REVERSE is preferable for all
cases where a surrogate pair is not likely to be encountered.
For further details on reversing strings, refer to the $REVERSE function.
Example
The following example shows how $WREVERSE treats a surrogate pair as a single
character:

  SET spair=$CHAR($ZHEX("D806"),$ZHEX("DC06"))
  SET str="AB"_spair_"CD"
    WRITE !,"String before reversing:"
    ZZDUMP str
  SET wrev=$WREVERSE(str)
    WRITE !,"$WREVERSE did not reverse surrogate pair:"
    ZZDUMP wrev
  SET rev=$REVERSE(str)
    WRITE !,"$REVERSE reversed surrogate pair:"
    ZZDUMP rev
See Also

  • $REVERSE function
  • $WASCII function
  • $WCHAR function
  • $WEXTRACT function
  • $WFIND function
  • $WISWIDE function
  • $WLENGTH function


 #}}}
*$XECUTE*  #{{{

Executes a specified command line.
Synopsis

$XECUTE(code,paramlist)

Parameters

           An expression that resolves to a valid Caché ObjectScript command
code       line, specified as a quoted string. A command line can contain one
           or more Caché ObjectScript commands. The final command must be an
           argumented QUIT.

paramlist  Optional  A list of parameters to be passed to code. Multiple
           parameters are separated by commas.

Description
The $XECUTE function executes code in a separate stack frame context. The code
parameter must evaluate to a quoted string containing one or more Caché
ObjectScript commands. The code execution must conclude with a QUIT command
that returns an argument. Caché then returns this QUIT argument as the $XECUTE
return code value.
You can use the paramlist argument to pass parameters to code. If you are
passing parameters, there must be a formal parameter list at the beginning of 
code. Parameters are specified positionally. There must be at least as many
formal parameters listed in code as there are actual parameters specified in 
paramlist.
You can use $ZUTIL(62) to perform syntax checking on code.
Each invocation of $XECUTE places a new context frame on the call stack for
your process. The $STACK special variable contains the current number of
context frames on the call stack.
The $XECUTE function performs substantially the same operation as the XECUTE
command, with the following differences: The $XECUTE function does not support
postconditionals or the use of multiple command line arguments. The $XECUTE
function requires every execution path to end with an argumented QUIT; the 
XECUTE command neither requires a QUIT nor permits an argumented QUIT.
Parameters
code
An expression that evaluates to a valid Caché ObjectScript command line,
specified as a quoted string. The code string must not contain a tab character
at the beginning or a <Return> at the end. The string can be no longer than a
valid Caché ObjectScript program line. The code string must contain a QUIT
command that returns an argument at the conclusion of each possible execution
path.
If $XECUTE passes parameters to code, the code string must begin with a formal
parameter list. A formal parameter list is enclosed in parentheses; within the
parentheses, parameters are separated by commas.
paramlist
A list of parameters to pass to code, specified as a comma-separated list. Each
parameter in paramlist must correspond to a formal parameter within the code
string. The number of parameters in paramlist may be less than or equal to the
number of formal parameters listed in code.
You can use a dot prefix to pass a parameter by reference. This is useful for
passing a value out from code. An example is provided below. For further
details, refer to  Passing by Reference in the User-defined Code chapter of 
Using Caché ObjectScript.
Examples
In the following example, the $XECUTE function executes the command line
specified in cmdline. It passes two parameters, num1 and num2 to this command
line.

   SET cmd="(dvnd,dvsr) IF dvsr=0 {QUIT 99} ELSE {SET ^testnum=dvnd/dvsr QUIT 0}"
   SET rtn=$XECUTE(cmd,num1,num2)
   IF rtn=99
     {WRITE !,"Division by zero. ^testnum not set"}
   ELSE
     {WRITE !,"global ^testnum set to",^testnum}

The following example uses passing by reference (.y) to pass a local variable
value from the code to the invoking context.

CubeIt
  SET x=7
  SET rtn=$XECUTE("(in,out) SET out=in*in*in QUIT 0",x,.y)
  IF rtn=0 {WRITE !,x," cubed is ",y}
  ELSE {WRITE !,"Error code=",SQLCODE}
See Also

  • DO command
  • XECUTE command
  • QUIT command
  • $ZUTIL(62) function
  • $STACK special variable


 #}}}
*$ZABS*  #{{{

Absolute value function.
Synopsis

$ZABS(n)

Parameters

n  Any number.

Description
$ZABS returns the absolute value of n.
Parameters
n
Any number. Can be specified as a value, a variable, or an expression. The
expression is evaluated, and the result converted to a positive value. Multiple
plus and minus signs are permitted. Leading and trailing zeros are deleted.
Example
The following program returns the absolute value of the number you supply.

   READ "Input a number: ",num
   SET abs=$ZABS(num)
   WRITE "The absolute value of ",num," is ",abs

See Also

  • Operators in Using Caché ObjectScript


 #}}}
*$ZARCCOS*  #{{{

Inverse (arc) cosine function.
Synopsis

$ZARCCOS(n)

Parameters

n  A signed decimal number.

Description
$ZARCCOS returns the trigonometric inverse (arc) cosine of n. The result is
given in radians (to 18 decimal places).
Parameters
n
Signed decimal number ranging from 1 to -1 (inclusive). It can be specified as
a value, a variable, or an expression. Numbers outside the range generate an
<ILLEGAL VALUE> error.
The following are arc cosine values returned by $ZARCCOS:

1   returns 0

0   returns 1.570796326794896619

-1  returns pi (3.141592653589793238)

Example
The following example permits you to compare the arc cosine and the arc sine of
a number:

   READ "Input a number: ",num
   IF num>1 { WRITE !,"ILLEGAL VALUE: number too big" }
   ELSEIF num<-1 { WRITE !,"ILLEGAL VALUE: number too small" }
   ELSE {
         WRITE !,"the arc cosine is: ",$ZARCCOS(num)
         WRITE !,"the arc sine is: ",$ZARCSIN(num)
        }
   QUIT

See Also

  • $ZCOS function
  • $ZPI special variable


 #}}}
*$ZARCSIN*  #{{{

Inverse (arc) sine function.
Synopsis

$ZARCSIN(n)

Parameters

n  A signed decimal number.

Description
$ZARCSIN returns the trigonometric inverse (arc) sine of n. The result is given
in radians.
Parameters
n
Signed decimal number ranging from 1 to -1 (inclusive). It can be specified as
a value, a variable, or an expression. Numbers outside the range generate an
<ILLEGAL VALUE> error.
The following are arc sine values returned by $ZARCSIN:

1   returns 1.570796326794896619

0   returns 0

-1  returns -1.570796326794896619

Example
The following example permits you to compare the arc sine and the arc cosine of
a number:

   READ "Input a number: ",num
   IF num>1 { WRITE !,"ILLEGAL VALUE: number too big" }
   ELSEIF num<-1 { WRITE !,"ILLEGAL VALUE: number too small" }
   ELSE {
         WRITE !,"the arc sine is: ",$ZARCSIN(num)
         WRITE !,"the arc cosine is: ",$ZARCCOS(num)
        }
   QUIT

See Also

  • $ZSIN function
  • $ZPI special variable


 #}}}
*$ZARCTAN*  #{{{

Inverse (arc) tangent function.
Synopsis

$ZARCTAN(n)

Parameters

n  Any positive or negative number.

Description
$ZARCTAN returns the trigonometric inverse (arc) tangent of n. Possible results
range from 1.57079 (half of pi) though zero to  1.57079. The result is given in
radians.
Parameters
n
Any positive or negative number. It can be specified as a value, a variable, or
an expression. You can use the $ZPI special variable to specify pi.
The following are arc tangent values returned by $ZARCTAN:

2   returns 1.107148717794090502

1   returns .7853981633974483098

0   returns 0

-1  returns -.7853981633974483098

Example
The following example permits you to calculate the arc tangent of a number:

   READ "Input a number: ",num
   WRITE !,"the arc tangent is: ",$ZARCTAN(num)
   QUIT

See Also

  • $ZTAN function
  • $ZPI special variable


 #}}}
*$ZBITAND (legacy function)*  #{{{

Bitstring function – AND.
Synopsis

$ZBITAND(bitstring1,bitstring2)

Description
This page describes the legacy function $ZBITAND. It is described here for
compatibility with legacy applications.
$ZBITAND returns a bitstring formed by the (bitstring1 AND bitstring2)
operation. The length of the resulting bitstring equals the length of the
shorter of the two specified bitstrings. The value of the resulting bitstring
is 1 in all positions where both bitstrings held a 1, and 0 in all other
positions.
Example
If bitstring1 = [0,1,1,0] and bitstring2 = [0,1,0,0], then the result of 
$ZBITAND would be [0,1,0,0]. That is:
Position 1: 0 and 0 = 0
Position 2: 1 and 1 = 1
Position 3: 1 and 0 = 0
Position 4: 0 and 0 = 0
See Also

  • $BITLOGIC function
  • $ZBOOLEAN function
  • $ZBITOR (legacy function) function
  • $ZBITXOR (legacy function) function


 #}}}
*$ZBITCOUNT (legacy function)*  #{{{

Bitstring function – COUNT.
Synopsis

$ZBITCOUNT(bitstring)

Description
This page describes the legacy function $ZBITCOUNT. It is described here for
compatibility with legacy applications.
$ZBITCOUNT returns the number of ON bits (1' s) in bitstring.
Example
If bitstring = [0,0,1,1,0], then the result of $ZBITCOUNT would be 2.
See Also

  • $BITCOUNT function
  • $ZBOOLEAN function


 #}}}
*$ZBITFIND (legacy function)*  #{{{

Bitstring function – FIND.
Synopsis

$ZBITFIND(bitstring, truthval, position)

Parameters

bitstring  A bitstring.

truthval   Binary value (0 or 1).

position   Optional  Specifies a starting bit position in bitstring.

Description
This page describes the legacy function $ZBITFIND. It is described here for
compatibility with legacy applications.
$ZBITFIND returns the position immediately after the first bit in bitstring
that equals truthval. position specifies an optional starting position for the
search. If position is omitted, the search starts at position 1.
If truthval is not found, $ZBITFIND returns zero.
$ZBITFIND is similar to the $FIND function in that the returned position is the
next one after the matching bit. This permits a loop of the form:

Findabit
  FOR p=1:0 {
      SET p=$ZBITFIND(bstring,1,p)
      QUIT:Â´p
      DO Foundone
   }
Foundone

Parameters
truthval
Binary value (0 or 1).
position
Specifies a starting bit position in bitstring. The default is 1. Bits are
counted left-to-right, with the first bit counted as number 1.
Examples
Note that the result is the position immediately after the bit that matches
truthval.
Given the bitstring[0,0,1,1,0]:
If truthval=0 then the result of $ZBITFIND would be position 2.
If truthval=1 then the result of $ZBITFIND would be position 4.
If truthval=0 and position=2, then the result of $ZBITFIND would be position 3.
If truthval=0 and position=3, then the result of $ZBITFIND would be position 6.
See Also

  • $ZBOOLEAN function


 #}}}
*$ZBITGET (legacy function)*  #{{{

Bitstring function – GET.
Synopsis

$ZBITGET(bitstring, position)

Parameters

bitstring  The bitstring to be evaluated.

position   Value or expression that evaluates to a positive integer.

Description
This page describes the legacy function $ZBITGET. It is described here for
compatibility with legacy applications.
$ZBITGET returns the bit value (0 or 1) at the specified bit position within
bitstring. The first bit position is 1.
Parameters
position
Value or expression that evaluates to a positive integer. Bit positions are
counted left-to-right, with the first bit counted as number 1. If position is
set to zero, or to an integer larger than the length ofbitstring, a <FUNCTION>
error occurs.
Examples
Given the bitstring [0,0,1,1,0]:
If position=1, then the result of $ZBITGET would be 0.
If position=2, then the result of $ZBITGET would be 0.
If position=3, then the result of $ZBITGET would be 1.
If position=4, then the result of $ZBITGET would be 1.
If position=5, then the result of $ZBITGET would be 0.
If position=6, then $ZBITGET would generate a <FUNCTION> error.
See Also

  • $BIT function
  • $ZBOOLEAN function
  • $ZBITSET (legacy function)


 #}}}
*$ZBITLEN (legacy function)*  #{{{

Bitstring function – LENGTH.
Synopsis

$ZBITLEN(bitstring)

Description
This page describes the legacy function $ZBITLEN. It is described here for
compatibility with legacy applications.
$ZBITLEN returns the number of bits in bitstring.
Example
If bitstring=[0,0,1,1,0], then the result of $ZBITLEN would be the length 5.
See Also

  • $BITCOUNT function
  • $ZBOOLEAN function


 #}}}
*$ZBITNOT (legacy function)*  #{{{

Bitstring function – NOT
Synopsis

$ZBITNOT(bitstring)

Description
This page describes the legacy function $ZBITNOT. It is described here for
compatibility with legacy applications.
$ZBITNOT returns a permutation of bitstring with each of its bit positions
inverted -- that is, 1s become 0s, and 0s become 1s.
Example
If bitstring=[0,0,1,1,0], then the result of $ZBITNOT would be a bitstring with
the value [1,1,0,0,1].
See Also

  • $BITLOGIC function
  • $ZBOOLEAN function


 #}}}
*$ZBITOR (legacy function)*  #{{{

Bitstring function – OR.
Synopsis

$ZBITOR(bitstring1,bitstring2)

Description
This page describes the legacy function $ZBITOR. It is described here for
compatibility with legacy applications.
$ZBITOR returns a bitstring formed by the (bitstring1 OR bitstring2) operation.
The length of the resulting bitstring equals the longer length of the two
bitstrings. The value of the resulting bitstring is 1 in all positions where
either or both of the bitstrings held a 1, and 0 in all other positions.
Bitstrings are compared left-to- right.
Example
If bitstring1=[0,0,1,1,0] and bitstring2=[0,1,1,0], then the result of $ZBITOR
would be [0,1,1,1,0]. That is:
Position 1: 0 OR 0 = 0
Position 2: 0 OR 1 = 1
Position 3: 1 OR 1 = 1
Position 4: 1 OR 0 = 1
Position 5: 0 OR null = 0
See Also

  • $BITLOGIC function
  • $ZBOOLEAN function
  • $ZBITXOR (legacy function) function
  • $ZBITAND (legacy function) function


 #}}}
*$ZBITSET (legacy function)*  #{{{

Bitstring function – SET.
Synopsis

$ZBITSET(bitstring,position,truthval)

Parameters

bitstring  The bitstring to be set.

position   Positive integer that specifies a location in bitstring.

truthval   Single-bit binary value (0 or 1).

Description
This page describes the legacy function $ZBITSET. It is described here for
compatibility with legacy applications.
$ZBITSET returns a permutation of bitstring in which the bit at position is set
to truthval(0 or 1).
Parameters
position
Positive integer that specifies a location in bitstring. It can be specified as
a value, a variable, or an expression. Bits are counted left-to-right, with the
first bit counted as number 1.
truthval
Single-bit binary value (0 or 1).
Example
The following example creates a bitstring using $ZBITSTR, then sets a bit using
$ZBITSET.
SET bitstring=$ZBITSTR(5,0)
SET newbitstring=$ZBITSET(bitstring,3,1)
If bitstring=[0,0,0,0,0], position=3, and truthval=1, then the result of 
$ZBITSET would be a bitstring with the value [0,0,1,0,0].
See Also

  • $BIT function
  • $ZBOOLEAN function
  • $ZBITGET (legacy function)


 #}}}
*$ZBITSTR (legacy function)*  #{{{

Bitstring function – STRING.
Synopsis

$ZBITSTR(size,truthval)

Parameters

size      Positive integer.

truthval  Optional  Specifies a binary value (0 or 1) for the returned bits.

Description
This page describes the legacy function $ZBITSTR. It is described here for
compatibility with legacy applications.
$ZBITSTR returns a bitstring whose length is size bits long, with all of its
bits set to truthval.
Parameters
size
Positive integer. The integer must be in the range 1 to 262,128 bits (32766 x
8). It can be specified as a value, a variable, or an expression.
truthval
Specifies a binary value (0 or 1) for the returned bits. If truthval is 0, or
is omitted, all the bits are set to 0 (OFF). If truthval is 1, all the bits are
set to 1 (ON).
Example
The following example creates a bitstring named bs:
SET bs=$ZBITSTR(4,1)
If size=4 and truthval=1, then the result of $ZBITSTR would be a bitstring with
the value [1,1,1,1].
See Also

  • $ZBOOLEAN function


 #}}}
*$ZBITXOR (legacy function)*  #{{{

Bitstring function – XOR.
Synopsis

$ZBITXOR(bitstring1,bitstring2)

Description
This page describes the legacy function $ZBITXOR. It is described here for
compatibility with legacy applications.
$ZBITXOR returns a bitstring formed by the (bitstring1 XOR bitstring2)
operation. The length of the resulting bitstring equals the shorter length of
the two bitstrings.
The following table shows the four possible results obtained by performing the 
XOR operation on two bits (b1 and b2):

b1  b2  equals

0   0   0

0   1   1

1   0   1

1   1   0

Example
If bitstring 1=[0,0,1,1,0] and bitstring 2=[0,1,1,0], then the result of 
$ZBITXOR would be [0,1,0,1]. That is:
Position 1: 0 XOR 0 = 0
Position 2: 0 XOR 1 = 1
Position 3: 1 XOR 1 = 0
Position 4: 1 XOR 0 = 1
Position 5: 0 XOR null = null
See Also

  • $BITLOGIC function
  • $ZBOOLEAN function
  • $ZBITOR (legacy function) function
  • $ZBITAND (legacy function) function


 #}}}
*$ZBOOLEAN*  #{{{

Bitwise logical operation function.
Synopsis

$ZBOOLEAN(arg1,arg2,bit_op)
$ZB(arg1,arg2,bit_op)

Parameters

        The first argument. An integer or a string, or a variable or expression
arg1    that resolve to an integer or string. Cannot be a floating point
        number.

        The second argument. An integer or a string, or a variable or
arg2    expression that resolve to an integer or string. Cannot be a floating
        point number.

bit_op  An integer indicating the operation to be performed (see table below.)
        Permitted values are 0 through 15, inclusive.

Description
$ZBOOLEAN performs the bitwise logical operation specified by bit_op on two
arguments, arg1 and arg2. $ZBOOLEAN returns the results of the bitwise
combination of arg1 and arg2, as specified by the bit_op value. You can view
the results using the ZZDUMP command.
$ZBOOLEAN performs its operations on either character strings or numbers. For
character strings, it performs logical AND and OR operations on each character
in the string. For numbers, it performs a logical AND and OR operation on the
entire number as a unit. To force the evaluation of a numeric string as a
number, preface the string with a plus sign (+).
The bitwise operations includes 16 possible Boolean combinations of arg1 and 
arg2. The following table lists these combinations.

Bit Mask in bit_op            Operation Performed

0                   0

1                   arg1 & arg2 (logical AND)

2                   arg1 & ~arg2

3                   arg1

4                   ~arg1 & arg2

5                   arg2

6                   arg1 ^ arg2 (logical XOR (exclusive or))

7                   arg1 ! arg2 (logical OR (inclusive or))

8                   ~(arg1 ! arg2)

9                   ~(arg1 ^ arg2)

10                  ~arg2 (logical NOT)

11                  arg1 ! ~arg2

12                  ~arg1 (logical NOT)

13                  ~arg1 ! arg2

14                  ~(arg1 & arg2)

15                  -1 (one’s complement of 0)

Where:
& is logical AND
! is logical OR
~ is logical NOT
^ is exclusive OR
For further details, see Operators in Using Caché ObjectScript.
All $ZBOOLEAN operations parse both arg1 and arg2, including bit_op values 0,
3, 5, 10, 12, and 15.
The $ZBOOLEAN arg1 and arg2 parameters can resolve to one of the following
types:

  • An integer. A positive or negative whole decimal number of up to 18 digits.
    No characters other than the numbers 0 9 and, optionally, one or more
    leading plus and minus signs are permitted. Leading zeros are ignored.
  • A string. Enclosed in quotation marks, a string of any length with any
    contents is permitted. Note that the string  123 and the integer 123 are
    not the same. A null string is permitted, but if arg2 is the null string,
    $ZBOOLEAN always returns the value of arg1, regardless of the bit_op value.
  • A signed string. A string preceded by a plus or minus sign is parsed as an
    integer, regardless of the string’s contents. Signed strings are subject to
    the same length restriction as integers. A signed null string is equivalent
    to zero.

It is strongly recommended that arg1 and arg2 either both resolve to an integer
or both resolve to a string. Generally, arg1 and arg2 should be the same data
type; combining an integer and a string in a $ZBOOLEAN operation does not give
a useful result in most cases.
Parameters
arg1
The first argument in the bitwise logical expression. For strings, the length
of the returned value is always the same as the length of this argument.
arg2
The second argument in the bitwise logical expression.
bit_op
The bitwise logical operation to be performed, specified as a numeric code from
0 to 15, inclusive. Because this code is handled as a bit mask, a value of 16=
0, 17=1, 18=2, etc.
The bit_op values 0 and 15 return a constant value, but they also evaluate the
arguments. If arg1 is an integer (or signed string), bit_op 0 returns 0, and 
bit_op 15 returns  1 (the one’s complement of 0.) If arg1 is a string, bit_op 0
returns a low value (hex 00) for each character in arg1, and bit_op 15 returns
a high value (hex FF) for each character in arg1. If arg2 is the null string
(""), both operations return the literal value of arg1.
The bit_op values 3, 5, 10 and 12 perform a logical operation on only one of
the arguments, but they evaluate both arguments.

  • bit_op=3 always returns the value of arg1, regardless of the value of arg2.
  • bit_op=5 returns the value of arg2 when the two arguments have the same
    data type. However if one argument is a string and the other argument is an
    integer (or signed string) results are unpredictable. If arg2 is the null
    string $ZBOOLEAN always returns the literal value of arg1.
  • bit_op=10 returns the one’s complement value of arg2 if both arguments are
    integers. If arg1 is a string, the operation returns a high order character
    for each character in arg1.. If arg2 is a string, and arg1 is an integer,
    the bitwise operation is performed on the arg2 string. If arg2 is the null
    string $ZBOOLEAN always returns the literal value of arg1.
  • bit_op=12 returns the one’s complement value of arg1 if it is an integer
    (or signed string), for any value of arg2 except the null string. If arg1
    is a string, the operation returns the one’s complement (as a hex value) of
    each character in arg1. If arg2 is the null string $ZBOOLEAN always returns
    the literal value of arg1.

Examples
The following three examples all illustrate the same AND operation. These
examples AND the ASCII values of lowercase letters with the ASCII value of the
underscore character, resulting in the ASCII values of the corresponding
uppercase letters.

   WRITE $ZBOOLEAN("abcd","_",1)
displays ABCD.
The lowercase "a" = [01100001] (ASCII decimal 97)
The underscore character "_" = [01011111] (ASCII decimal 95)
The uppercase "A" = [01000001] (ASCII decimal 65)
The following example performs the same AND operation as the previous example,
but uses the ASCII decimal values of the arguments. The function $ASCII("a")
returns the decimal value 97 for the first argument:

   WRITE $ZBOOLEAN($ASCII("a"),95,1)
displays 65.
The following example performs the same AND operation, using a $CHAR value as
the second argument:

   WRITE $ZBOOLEAN("a",$CHAR(95),1)
displays A.
The following examples illustrate logical OR:

   WRITE $ZBOOLEAN(1,0,7)
displays 1.

   WRITE $ZBOOLEAN(1,1,7)
displays 1.

   WRITE $ZBOOLEAN(2,1,7)
displays 3.

   WRITE $ZBOOLEAN(2,2,7)
displays 2.

   WRITE $ZBOOLEAN(3,2,7)
displays 3.
The following logical OR examples demonstrate the difference between string
comparisons and number comparisons:

   WRITE $ZBOOLEAN(64,255,7)
compares the two values as numbers and displays 255.

   WRITE $ZBOOLEAN("64","255",7)
compares the two values as strings and displays 65.

   WRITE $ZBOOLEAN(+"64",+"255",7)
the plus signs force the comparison of the two values as numbers, and displays
255.
The following examples illustrate exclusive OR:

   WRITE $ZBOOLEAN(1,0,6)
displays 1.

   WRITE $ZBOOLEAN(1,1,6)
displays 0.

   WRITE $ZBOOLEAN(2,1,6)
displays 3.

   WRITE $ZBOOLEAN(2,2,6)
displays 0.

   WRITE $ZBOOLEAN(3,2,6)
displays 1.

   WRITE $ZBOOLEAN(64,255,6)
displays 191.
The following example shows a 4-byte entity with all bytes set to 1:

   WRITE $ZBOOLEAN(5,1,15)
displays -1.
The following example will set x to 3 bytes with all bits set to 1:

   SET x=$ZBOOLEAN("abc",0,15)
   WRITE !,$LENGTH(x)
   WRITE !,$ASCII(x,1)," ",$ASCII(x,2)," ",$ASCII(x,3)
The first WRITE displays 3; the second WRITE displays 255 255 255.
Notes
Integer Processing
Before $ZBOOLEAN performs the bitwise operation, it interprets each numeric
value as either an 8-byte or a 4-byte signed binary value, depending on size. 
$ZBOOLEAN always interprets a numeric value as a series of bytes. The boolean
operation uses these bytes as a string argument. The result type is the same as
the type of arg1.
If either arg1 or arg2 is numeric and cannot be represented as an 8-byte signed
integer (larger than 18 decimal digits), a <FUNCTION> error results. If both 
arg1 and arg2 are numeric and one of them requires 8 bytes to be represented,
then both values are interpreted as 8-byte binary values.
After the previous transformations are complete, the given Boolean combination
is applied bit by bit to arg1 and arg2 to yield the result. The result returned
is always the same length as arg1 (after the above transformations of numeric
data). If the length of arg2 is less than the length of arg1, then arg2 is
repeatedly combined with successive substrings of arg1 in left to right
fashion.
$ZBOOLEAN always interprets the numeric value as a series of bytes in
little-endian order, with the low-order byte first, no matter what the native
byte order of your machine is.
Internal Structure of $ZBOOLEAN Values
The following table lists the internal rules for $ZBOOLEAN. You do not need to
understand these rules to use $ZBOOLEAN; they are presented here for reference
purposes only.
There are four possible states of any two bits being compared from within arg1
and arg2. The Boolean operation generates a true result (=1) if and only if
bit_op has the bit mask shown in the table.

Bit in arg1  Bit in arg2  Bit Mask in bit_op Decimal  Bit Mask in bit_op Binary

0            0            8                           1000

0            1            4                           0100

1            0            2                           0010

1            1            1                           0001

EQV and IMP Logical Operators
$ZBOOLEAN indirectly supports EQV and IMP logical operators. These logical
operators are defined as follows:

  • EQV is a logical equivalence between two expressions. It is represented by 
    $ZBOOLEAN(arg1,arg2,9). This is logically ~(arg1 ^ arg2) which is logically
    identical to ((~arg1) & (~arg2)) ! (arg1 & arg2).
  • IMP is a logical implication between two expressions. It is represented by 
    $ZBOOLEAN(arg1,arg2,13). This is logically (~arg1) ! arg2.

See Also

  • ZZDUMP command
  • Operators in Using Caché ObjectScript


 #}}}
*$ZCONVERT*  #{{{

String conversion function.
Synopsis

$ZCONVERT(string,mode,trantable,handle)
$ZCVT(string,mode,trantable,handle)

Parameters

string     The string to convert, specified as a quoted string. This string can
           be specified as a value, a variable, or an expression.

           A letter code specifying the conversion mode, either the type of
mode       case conversion or input/output encoding. Specify mode as a quoted
           string.

trantable  Optional  The translation table to use, specified as either an
           integer or a quoted string,

           Optional  An unsubscripted local variable that holds a string value.
           Used for multiple invocations of $ZCONVERT to convert a long string.
handle     This variable contains the remaining portion of string that could
           not be converted. Can also be used to append a string to the return
           value.

Description
$ZCONVERT converts a string from one form to another. The nature of the
conversion depends on the parameters you use.
$ZCONVERT Returns a Converted String
$ZCONVERT(string, mode) returns string with the characters converted as
specified by mode. The conversions are of two types:

  • Case conversion
  • Encoding translation

Case conversion changes the case of each letter character in the string. You
can change all letter characters in a string to their lowercase, uppercase, or
titlecase form. Characters that are already in the specified case, and
characters with no case (usually any nonalphabetic character) in the string are
passed through unchanged. To output a literal quote character ( ) within a
string, input two quote characters (  ). For further case conversion options,
including non-ASCII and customized case conversion, refer to the article System
Classes for National Language Support.
Encoding translation translates string between the internal encoding style used
on your system and another encoding style. You can perform input translation;
that is, translate string from an external encoding style to the encoding style
of your system. You can also perform output translation; that is, translate 
string from the encoding style of your system to an external encoding style.
For further I/O translation options, including non-ASCII and customized
translation, refer to the article System Classes for National Language Support.
The values you can use for mode are as follows:

Mode                                   Meaning
Code

U or  Uppercase translation: Convert all characters in string to uppercase.
u

L or  Lowercase translation: Convert all characters in string to lowercase.
l

      Titlecase translation: Convert all characters in string to titlecase.
T or  Titlecase is only meaningful for those alphabets (principally Eastern
t     European) that have three forms for a letter: uppercase, lowercase, and
      titlecase. For all other letters, titlecase translation is the same as
      uppercase translation.

      Word translation: Convert the first character of each word in string to
      uppercase. Any character preceded by a blank space, a quotation mark ("),
W or  an apostrophe ('), or an open parenthesis (() is considered the first
w     character of a word. Word translation converts all other characters to
      lowercase. Word translation is locale specific; the above syntax rules
      for English may differ for other language locales.

      Sentence translation: Convert the first character of each sentence in 
      string to uppercase. The first non-blank character of string, and any
      character preceded by a period (.), question mark (?), or exclamation
S or  mark (!) is considered the first character of a sentence. (Blank spaces
s     between the preceding punctuation character and the letter are ignored.)
      If this character is a letter, it is converted to uppercase. Sentence
      translation converts all other letter characters to lowercase. Sentence
      translation is locale specific; the above syntax rules for English may
      differ for other language locales.

      Perform input encoding translation on a specified string. For the
I or  two-argument form, the translation is performed using the current process
i     I/O translation handle. If a current process I/O translation handle has
      not been defined, Caché performs translation based on the default process
      I/O translation table name.

      Perform output encoding translation on a specified string. For the
O or  two-argument form, the translation is performed using the current process
o     I/O translation handle. If a current process I/O translation handle has
      not been defined, Caché performs translation based on the default process
      I/O translation table name.

If mode is a null string or any value other than the valid characters, you
receive a <FUNCTION> error.
When you specify case translation, the two-argument form of $ZCONVERT(string
,"L") is the functional equivalent of the following form of the $TRANSLATE
function:

$TRANSLATE(string,"ABC...XYZ","abc...xyz")

Word and Sentence Translation
 W and  S modes determine whether a non-blank character is the first character
of a word or the first character of a sentence, and if that character is a
letter, translate it to uppercase. All other letters are translated to
lowercase. Case translation works on letters in any alphabet, as shown in the
following example which converts Greek letters ($CHAR(945) is lowercase alpha;
$CHAR(913) is uppercase alpha):

   SET greek=$CHAR(945,946,947,913,914,915)
   WRITE $ZCONVERT(greek,"W")
However the rules determining what constitutes a word or sentence are locale
dependent. For example, the following example uses the Spanish inverted
exclamation point $CHAR(161). The default (English) locale does not recognize
this character as beginning a sentence or word. In this example, all letters in
spanish are translated to lowercase:

   SET spanish=$CHAR(161)_"ola MuNdO! "_$CHAR(161)_"olA!"
   SET english="hElLo wOrLd! heLLo!"
   WRITE !,$ZCONVERT(english,"S")
   WRITE !,$ZCONVERT(spanish,"S")
Titlecase Translation
Titlecase ( T ) mode converts every letter in the string to its titlecase form.
Titlecase does not selectively uppercase letters based on their position in a
word or string. Titlecase is the case that a letter is represented in when it
is the first character of a word in a title. For standard Latin letters, the
titlecase form is the same as the uppercase form.
Some languages (for example, Croatian) represent particular letters by two
letter glyphs. For example,  lj is a single letter in the Croatian alphabet.
This letter has three forms: lowercase  lj , uppercase  LJ , and titlecase  Lj 
. $ZCONVERT titlecase translation is used for this type of letter conversion.
Three-Parameter Form: Encoding Translation
$ZCONVERT(string, mode, trantable) performs either an input encoding
translation or an output encoding translation on string. In the three-argument
form, the mode values you can use are either "I" or "O". You must define the 
mode value. For  I translations, the string may be a hexadecimal string, such
as %4B (the letter  K ); hexadecimal strings are not case-sensitive. The 
trantable value can be a numeric character or a string that specifies the 
translation table or translation handle to use.
The trantable value can be:

  • An integer value specifying a process I/O translation object. Available
    values are 0 through 3 (0 represents the current process I/O translation
    object).
  • A string value identifying a Caché-supplied I/O translation table.
    Available translation tables include:
      □  RAW which performs no translation.
      □  SAME which performs no translation on 8-bit systems, and translates
        8-bit characters to the corresponding Unicode character on Unicode
        systems.
      □  HTML which adds (output mode) or removes (input mode) HTML escape
        characters to a string.
      □  JS which uses a supplied JavaScript translation table to convert to
        the format for Zen component pages. The output translation for NULL
        ($CHAR(0)) is  \x00 ; for input translations,  \0 ,  \000 ,  \x00 , and
         \u0000 are all valid escape sequences for NULL.
      □  URL which adds (output mode) or removes (input mode) URL parameter
        escape characters to a string. Characters higher than $CHAR(255) are
        represented in Unicode hexadecimal notation: $CHAR(256) = %u0100.
      □  UTF8 which converts (output mode) 16-bit Unicode characters to a
        series of 8-bit characters. Thus, the characters $CHAR(0) through $CHAR
        (127) are the same in RAW and UTF8 mode; characters $CHAR(128) and
        above are converted.
      □  XML which adds (output mode) or removes (input mode) XML escape
        characters to a string.
  • A string value specifying a user-defined I/O translation table. A named
    table can be defined in a locale and points to one or two translation
    tables. Use a named table to define a specific system-to/from-device
    encoding.
  • An empty string ("") specifying the use of the default process I/O
    translation table. (For equivalent functionality, see the $$GetPDefIO^%NLS
    () function of the %NLS utility.)

The following is a table of Output mode escape characters:

                                HTML    JS         URL         XML

null $CHAR(0)                          \x00  %00               

$CHAR(1) through $CHAR(7)                    %01 through %07   

backspace $CHAR(8)                     \b    %08               

horizontal tab $CHAR(9)                \t    %09               

line feed $CHAR(10)                    \n    %0A               

vertical tab $CHAR(11)                 \v    %0B               

form feed $CHAR(12)                    \f    %0C               

carriage return $CHAR(13)              \r    %0D               

$CHAR(14) through $CHAR(32)                  %0E through %20   

" (doubled)                    &quot;  \"    %22              &quot;

#                                            %23               

%                                            %25               

&                              &amp;         %26              &amp;

'                              &#39;   \'                     &apos;

+                                            %2B               

,                                            %2C               

:                                            %3A               

;                                            %3B               

<                              &lt;          %3C              &lt;

=                                            %3D               

>                              &gt;          %3E              &gt;

?                                            %3F               

@                                            %40               

[                                            %5B               

\                                      \\    %5C               

]                                            %5D               

^                                            %5E               

{                                            %7B               

|                                            %7C               

}                                            %7D               

~                                            %7E               

$CHAR(127) through $CHAR(159)                %7F through %9F   

$CHAR(160)                     &nbsp;        %A0               

$CHAR(161) through $CHAR(255)                %A1 through %FF   

Four-Parameter Form: Input/Output String
The handle parameter is a local variable that $ZCONVERT reads at the beginning
of execution and writes when it completes execution. It can be used for two
purposes: concatenating a string to the beginning of string, and converting
extremely long strings.
To concatenate a string to the beginning of string, set handle before invoking 
$ZCONVERT:

   SET handle="the "
   WRITE $ZCVT("quick brown fox","O","URL",handle)
   /*  the%20quick%20brown%20fox  */
   WRITE $ZCVT("quick brown fox","O","URL",handle)
   /*  quick%20brown%20fox  */
Note that $ZCONVERT resets handle when it completes execution. In the previous
example, it resets handle to the empty string.
To convert an extremely long string, it may be necessary to perform more than
one string conversions by invoking $ZCONVERT multiple times. $ZCONVERT provides
the optional handle parameter to hold the remaining unconverted portion of 
string. If you specify a handle parameter, it is updated by each invocation of 
$ZCONVERT. When the string conversion completes, $ZCONVERT sets handle to the
empty string.

   SET handle=""
   SET out = $ZCVT(hugestring,"O","HTML",handle)
   IF handle '= "" {
     SET out2 = $ZCVT(handle,"O","HTML",handle)
     WRITE "Converted string is: ",out,out2  }
   ELSE {
     WRITE "Converted string is: ",out }

Examples
The following example returns "HELLO":

   WRITE $ZCONVERT("Hello","U")
The following example returns "hello":

   WRITE $ZCVT("Hello","L")
The following example returns "HELLO":

   WRITE $ZCVT("Hello","T")
The following example uses the concatenate operator (_) to append and
case-convert an accented character:

   WRITE "CACH"_$CHAR(201),!, $ZCVT("CACH"_$CHAR(201),"L")
returns:
CACHÉ
caché
The following example converts the angle brackets in the string to HTML escape
characters for output, returning  &lt;TAG&gt; 

   WRITE $ZCVT("<TAG>","O","HTML")
Note that how these angle brackets display depends on the output device; try
running this program here and then running it from the Terminal prompt.
See Also

  • $ASCII function
  • $CHAR function
  • $ZSTRIP function
  • Pattern Matching operators in Using Caché ObjectScript
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ZCOS*  #{{{

Cosine function.
Synopsis

$ZCOS(n)

Parameters

n  An angle in radians ranging from Pi to 2 Pi (inclusive). Other supplied
   numeric values are converted to a value within this range.

Description
$ZCOS returns the trigonometric cosine of n. The result is a signed decimal
number ranging from -1 to +1. $ZCOS(0) returns 1. $ZCOS($ZPI) returns -1.
Parameters
n
An angle in radians ranging from Pi to 2 Pi (inclusive). It can be specified as
a value, a variable, or an expression. You can specify the value Pi by using
the $ZPI special variable. You can specify positive or negative values smaller
than Pi or larger than 2 Pi; Caché resolve these values to the corresponding
multiple of Pi. For example, 3 Pi is equivalent to Pi, negative Pi is
equivalent to Pi, and zero is equivalent to 2 Pi.
Examples
The following example permits you to compute the cosine of a number:

   READ "Input a number: ",num
   IF $ZABS(num)>(2*$ZPI) { WRITE !,"number is a larger than 2 pi" }
   ELSE {
         WRITE !,"the cosine is: ",$ZCOS(num)
        }
   QUIT

The following example compares the results from Caché fractional numbers (
$DECIMAL numbers) and $DOUBLE numbers. In both cases, the cosine of 0 is
exactly 1, the cosine of pi is exactly -1:

  WRITE !,"the cosine is: ",$ZCOS(0.0)
  WRITE !,"the cosine is: ",$ZCOS($DOUBLE(0.0))
  WRITE !,"the cosine is: ",$ZCOS(1.0)
  WRITE !,"the cosine is: ",$ZCOS($DOUBLE(1.0))
  WRITE !,"the cosine is: ",$ZCOS($ZPI)
  WRITE !,"the cosine is: ",$ZCOS($DOUBLE($ZPI))
See Also

  • $ZSIN function
  • $ZARCCOS function
  • $ZPI special variable


 #}}}
*$ZCOT*  #{{{

Cotangent function.
Synopsis

$ZCOT(n)

Parameters

n  An angle in radians.

Description
$ZCOT returns the trigonometric cotangent of n. The result is a signed decimal
number.
Parameters
n
An angle in radians, specified as a nonzero value. It can be specified as a
value, a variable, or an expression.
Examples
The following example permits you to compute the cotangent of a number:

   READ "Input a number: ",num
   IF num=0 { WRITE !,"zero is an illegal value" }
   ELSE {
         WRITE !,"the cotangent is: ",$ZCOT(num)
        }
   QUIT

The following example compares the results from Caché fractional numbers (
$DECIMAL numbers) and $DOUBLE numbers:

  WRITE !,"the cotangent is: ",$ZCOT(1.0)
  WRITE !,"the cotangent is: ",$ZCOT($DOUBLE(1.0))
  WRITE !,"the cotangent is: ",$ZCOT(-1.0)
  WRITE !,"the cotangent is: ",$ZCOT($DOUBLE(-1.0))
  WRITE !,"the cotangent is: ",$ZCOT($ZPI/2)
  WRITE !,"the cotangent is: ",$ZCOT($DOUBLE($ZPI)/2)
Note that the cotangent of pi/2 is a fractional number, not 0.

   WRITE $ZCOT(0)

generates an <ILLEGAL VALUE> error.
See Also

  • $ZTAN function
  • $ZPI special variable


 #}}}
*$ZCRC*  #{{{

Checksum function.
Synopsis

$ZCRC(string,mode,expression)

Parameters

string      A string on which a checksum operation is performed.

mode        An integer code specifying the checksum mode to use.

expression  Optional  The initial "seed" value, specified as an integer. If
            omitted, defaults to zero (0).

Description
$ZCRC performs a cyclic redundancy check on string and returns an integer
checksum value. The value returned by $ZCRC depends on the parameters you use.

  • $ZCRC(string,mode) computes and returns a checksum on string. The value of 
    mode determines the type of checksum $ZCRC computes.
  • $ZCRC(string,mode,expression) computes and returns a checksum on string
    using the mode specified by mode. expression supplies an initial "seed"
    value when checking multiple strings. It allows you to run $ZCRC
    calculations sequentially on multiple strings and obtain the same checksum
    values as if you had concatenated those strings and then run $ZCRC on the
    resulting string.

Parameters
string
A byte string. Can be specified as a value, a variable, or an expression. Only
use a byte string or you will receive a <FUNCTION> error.
mode
The checksum method to use. All checksum methods can be used with 8-bit (ASCII)
or 16-bit Unicode (wide) characters. Legal values for mode are:

Mode                                  Computes

      An 8-bit byte sum. Simply sums the ASCII values of the characters in the
0     string. Thus $ZCRC(2,0)=50, $ZCRC(22,0)=100, $ZCRC(23,0)=101, and $ZCRC
      (32,0)=101.

1     An 8-bit XOR of the bytes

2     A 16-bit DataTree CRC-CCITT

3     A 16-bit DataTree CRC-16

4     A 16-bit CRC for XMODEM protocols

5     A correct 16-bit CRC-CCITT

6     A correct 16-bit CRC-16

7     A correct 32-bit CRC-32. This corresponds to the cksum utility algorithm
      3 on OS X, and the CRC32 class in the Java utilities package.

expression
An argument that is an initial "seed" value. $ZCRC adds expression to the
checksum generated for string. This allows you to run $ZCRC calculations on
multiple strings sequentially and obtain the save checksum value as if you had
concatenated those strings and run $ZCRC on the resulting string.
Examples
The following example uses mode=0 on strings containing the letters A, B, and C
and in each case returns the checksum 198:

  WRITE $ZCRC("ABC",0),!
  WRITE $ZCRC("CAB",0),!
  WRITE $ZCRC("BCA",0),!
The checksum is derived as follows:

  WRITE $ASCII("A")+$ASCII("B")+$ASCII("C")  /* 65+66+67 = 198 */
The following example shows the values returned by each mode for the string  
ABC :

  FOR i=0:1:7 {
     WRITE !,"mode ",i,"=",$ZCRC("ABC",i)
  }
See Also

  • $ZCYC function


 #}}}
*$ZCSC*  #{{{

Cosecant function.
Synopsis

$ZCSC(n)

Parameters

n  An angle in radians.

Description
$ZCSC returns the trigonometric cosecant of n. The result is a signed decimal
number.
Parameters
n
An angle in radians, specified as a nonzero number. It can be specified as a
value, a variable, or an expression. Specifying 0 generates an <ILLEGAL VALUE>
error.
Examples
The following example permits you to compute the cosecant of a number:

   READ "Input a number: ",num
   IF num=0 { WRITE !,"ILLEGAL VALUE: zero not permitted" }
   ELSE {
         WRITE !,"the cosecant is: ",$ZCSC(num)
        }
   QUIT

The following example compares the results from Caché fractional numbers (
$DECIMAL numbers) and $DOUBLE numbers. In both cases, the cosecant of pi/2 is
exactly 1:

  WRITE !,"the cosecant is: ",$ZCSC($ZPI)
  WRITE !,"the cosecant is: ",$ZCSC($DOUBLE($ZPI))
  WRITE !,"the cosecant is: ",$ZCSC($ZPI/2)
  WRITE !,"the cosecant is: ",$ZCSC($DOUBLE($ZPI)/2)
  WRITE !,"the cosecant is: ",$ZCSC($DOUBLE($ZPI/2))
See Also

  • $ZSEC function
  • $ZCOT function
  • $ZPI special variable


 #}}}
*$ZCYC*  #{{{

Cyclical-redundancy check for data integrity.
Synopsis

$ZCYC(string)
$ZC(string)

Parameters

string  A string.

Description
$ZCYC(string) computes and returns the cyclical-redundancy check value for the
string. It allows two intercommunicating programs to check for data integrity.
The sending program transmits a piece of data along with a matching check value
that it calculates using $ZCYC. The receiving program verifies the transmitted
data by using $ZCYC to calculate its check value. If the two check values
match, the received data is the same as the sent data.
$ZCYC calculates the check value by performing an exclusive OR (XOR) on the
binary representations of all the characters in the string.
Use caution when transmitting data between 8-bit and Unicode (16-bit)
implementations of Caché; if a data string does not contain any wide
characters, the cyclical-redundancy check values should match.
Note that the $ZCYC value of an 8-bit string is identical to the $ZCRC mode 1
value.
Parameters
string
A string. Can be specified as a value, a variable, or an expression. String
values are enclosed in quotation marks.
Example
In this example, the first $ZCYC returns 65; the second returns 3; and the
third returns 64.

   SET x= $ZCYC("A")
      ; 1000001 (only one character; no XOR )
   SET y= $ZCYC("AB")
      ; 1000001 XOR 1000010 -> 0000011
   SET z= $ZCYC("ABC")
      ; 1000001 XOR 1000010 -> 0000011 | 1000011 -> 100000
   WRITE !,"x=",x," y=",y," z=",z
See Also

  • $ZCRC function


 #}}}
*$ZDASCII*  #{{{

Converts an eight-byte string to a $DOUBLE floating point number.
Synopsis

$ZDASCII(string,position)
$ZDA(string,position)

Parameters

string    A string. It can be a value, a variable, or an expression. It must be
          a minimum of eight bytes in length.

          Optional  A starting position in the string, expressed as a positive
          integer. The default is 1. Position is counted in single bytes, not
position  eight-byte strings. The position cannot be the last byte in the
          string, or beyond the end of the string. A numeric position value is
          parsed as an integer by truncating decimal digits, removing leading
          zeros and plus signs, etc.

Description
The value that $ZDASCII returns depends on the parameters you use.

  • $ZDASCII(string) returns a $DOUBLE (IEEE floating point) numeric
    interpretation of an eight-byte string starting at the first character
    position of string.
  • $ZDASCII(string,position) returns a $DOUBLE (IEEE floating point) numeric
    interpretation of an eight-byte string beginning at the starting byte
    position specified by position.

$ZDASCII can return either a positive or a negative number.
$ZDASCII issues a <FUNCTION> error if string is of an invalid length, or 
position is an invalid value.
Example
The following example determines the numeric interpretation of the character
string "abcdefgh":

  WRITE $ZDASCII("12345678")

It returns: .0000000000000000000000000000000000000682132005170133
The following examples also return the same value:

  WRITE !,$ZDASCII("12345678",1)
  WRITE !,$ZDASCII("12345678xx",1)
  WRITE !,$ZDASCII("xx12345678xx",3)

Notes
$ZDASCII and Other $ASCII Functions
$ZDASCII converts a eight byte (64-bit) character string to an IEEE floating
point number. $ZQASCII converts a eight byte (64-bit) character string to an
integer. To convert an 8-bit byte string to an integer use $ASCII. To convert a
16-bit (wide) character string to an integer use $ZWASCII. To convert a 32-bit
(long) character string to an integer use $ZLASCII.
See Also

  • $ZDCHAR function
  • $ASCII function
  • $ZLCHAR function
  • $ZWASCII function
  • $ZQASCII function


 #}}}
*$ZDATEH*  #{{{

Validates and converts a date.
Synopsis

$ZDATEH(date,dformat,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)
$ZDH(date,dformat,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)

Parameters

           An expression that evaluates to a date string in display format. 
           $ZDATEH converts this date string to $HOROLOG format. This can be
date       either an explicit date (specified in various formats) or the string
            T or  t , representing the current date. The  T or  t string can
           optionally include a signed integer offset. For example  T-7 meaning
           seven days before the current date.

dformat    Optional  Format option for the date, specified as an integer code.
           If date is  T , dformat must be 5, 6, 7, 8, or 9.

monthlist  Optional  A string or the name of a variable that contains the month
           names you supplied.

yearopt    Optional  A code that specifies whether to represent years as two-
           or four-digit values

startwin   Optional  The start of the sliding window during which dates must be
           represented with two-digit years.

endwin     Optional  The end of the sliding window during which dates are
           represented with two-digit years.

mindate    Optional  The lower limit of the range of valid date dates,
           specified in $HOROLOG format.

maxdate    Optional  The upper limit of the range of valid date dates,
           specified in $HOROLOG format.

           Optional  A expression that resolves to a string or numeric.
erropt     Specifying an erropt value suppresses error messages associated with
           invalid or out of range date values. Instead of issuing an error
           message, $ZDATEH returns erropt.

Description
The $ZDATEH function validates a specified date and converts it from any of the
formats supported by the $ZDATE function to $HOROLOG format. The exact action 
$ZDATEH performs depends on the parameters you use.
Simple $ZDATEH Format
$ZDATEH(date) converts a date in the form MM/DD/[YY]YY to the first integer in
the $HOROLOG format. (The $HOROLOG format consists of two integers: the first
integer is a date, the second integer is a time.) Two or four digits may be
specified for years in the range 1900 to 1999. Four digits must be specified
for years before 1900 or after 1999.
Customizable $ZDATEH Format
$ZDATEH(date,dformat,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)
converts a date in the specified dformat to $HOROLOG format. The dformat, 
monthlist, yearopt, startwin, endwin, mindate, maxdate and erropt values are
identical to the values used by $ZDATE. However, when you use a dformat of 5,
6, 7, 8, or 9, $ZDATEH recognizes and converts a date in any of the external
date formats defined for dformat codes 1, 2, 3, 5, 6, 7, 8, and 9. (But not 
dformat code 4.) It also recognizes a special relative date format that
consists of a string beginning with the letter T or t (indicating  today ,)
optionally followed by a plus (+) or a minus (-) sign, and an integer number of
days after or before the current date.
Parameters
date
The date you want converted to $HOROLOG format, specified as a quoted string.
This can be an explicit date, or the implicit current date, represented by the
string  T or  t .
An explicit date must be specified in one of the formats supported by dformat.
The permitted format(s) depends on the dformat parameter. If dformat is not
specified or is 1, 2, 3, or 4, only one date format is permitted. If dformat is
5, 6, 7, 8, or 9, multiple date formats are permitted. Note that European Date
Format (dformat=4) is not one of the multiple date formats permitted, because 
$ZDATEH could not differentiate between 02/03/02 (meaning February 3, 2002) and
the European 02/03/02 (meaning March 2, 2002). If you want European date
format, you must explicitly specify dformat=4. If you specify a date in a
non-permitted format, or a nonexistent date (such as February 31, 2002), 
$ZDATEH generates an <ILLEGAL VALUE> error code. ($ZDATEH does check for leap
year dates, permitting Feb. 29, 2004 but not Feb. 29, 2003.)
An implicit date is specified as a string consisting of the letter  T or  t ,
indicating the current date (today). This string can optionally include a plus
or minus sign and an integer, which specify the number of days offset from the
current date. For example,  t+9 (nine days after the current date) or  t-12 
(twelve days before the current date). Implicit dates are only permitted if 
dformat is 5, 6, 7, 8, or 9. The only permitted implicit date forms are  T (or
 t ), and  T (or  t ) followed by a sign and integer. Caché generates an
<ILLEGAL VALUE> error if you specify a noninteger number, an arithmetic
expression, an integer without a sign, or a sign without an integer.  T+0 and  
T-0 are permitted, and return the current date. Caché generates a <VALUE OUT OF
RANGE> error if you specify an offset that would result in a $HOROLOG date
smaller than 0 or representing a date after the year 9999.
dformat
Format for the date. Valid values are:

Value                                  Meaning

       Get effective dformat value from the DateFormat property of the current
-1     locale, which defaults to a value of 1. This is the default behavior if
       you do not specify dformat.

1      MM/DD/[YY]YY (07/01/97)

2      DD Mmm [YY]YY (01 Jul 97)

3      [YY]YY-MM-DD (1997-07-01) - ODBC format

4      DD/MM/[YY]YY (01/07/97) - European format

5      Mmm D, YYYY (Jul 1, 1997)

6      Mmm D YYYY (Jul 1 1997)

7      Mmm DD [YY]YY (Jul 01 1997)

8      [YY]YYMMDD (19970701) - Numeric format

9      Mmmmm D, YYYY (July 1, 1997)

Where:

Syntax                                  Meaning

        YYYY is a four-digit year. [YY]YY is a two-digit year if the date falls
        within the active window for two-digit years; otherwise it is a
YYYY    four-digit years. You must supply the year value when using date
        formats (dformat) 1 through 4; these date formats do not supply a
        missing year value. Date formats 5 through 9 assume the current year if
        the date you specify does not include a year.

MM      Two-digit month.

D       One-digit day if the day number <10. Otherwise, two digits.

DD      Two-digit day.

        Month abbreviation extracted from the MonthAbbr property in the current
        locale. The default values are:  Jan Feb Mar Apr May Jun Jul Aug Sep
Mmm     Oct Nov Dec . Or an alternate month abbreviation (or name of any
        length) extracted from an optional list specified as the monthlist
        parameter to $ZDATEH.

Mmmmm   Full name of the month as specified by the MonthName property. The
        default values are:  January February March ... November December .

To determine the default date format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DateFormat")
monthlist
A string or the name of a variable that contains the month names you supplied.
The names in monthlist replace the default month values from the built-in list.
You would use monthlist to specify full month names or month names or
abbreviations in languages other than English.
monthlist is valid only if dformat is 2, 5, 6, 7, or 9. If dformat is 1, 3, 4,
or 8, $ZDATEH ignores monthlist.
The first character in monthlist specifies a delimiter (see the space before
Jan in the default list). The same delimiter must appear between each month
name or abbreviation in monthlist. This delimiter appears between the month,
day, and year portions of the returned date value.
If you omit monthlist or specify a monthlist value of -1, $ZDATEH uses the list
of month name abbreviations defined in the MonthAbbr property of the current
locale, which by default is:
 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 
except when dformat is 9, in which case $ZDATEH uses the list of month full
names defined the MonthName property of the current locale, which by default
is:
 January February March ... November December 
To determine the default MonthName and MonthAbbr lists for your locale, invoke
the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthName"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthAbbr")
yearopt
A numeric code that specifies whether to represent years as either two-digit
values or four-digit values. Valid values are:

Value                                  Meaning

       Get effective yearopt value from YearOption property of current locale
-1     which defaults to a value of 0. This is the default behavior if you do
       not specify yearopt .

       Represent 20th century dates (1900 through 1999) with two-digit years,
       unless a process-specific sliding window (established via the %DATE
0      utility) is in effect. If such a window is in effect, represent only
       those dates falling within the sliding window by two-digit years.
       Represent all dates falling outside the 20th century or outside the
       process-specific sliding window by four-digit years.

       Represent 20th century dates with two-digit years and all other dates
1      with four-digit years, regardless of any sliding temporal window in
       effect.

       Represent all dates with two-digit years, regardless of any sliding
       temporal window in effect. All dates are assumed to be in the 20th
2      century. Because this option deletes two digits from four-digit years,
       its use results in a nonreversible loss of century information. (This
       loss may be trivial if all dates are in the same century).

       Represent with two-digit years those dates falling within the sliding
3      temporal window defined by startwin and (optionally) endwin. Represent
       all other dates with four-digit years. When yearopt=3, startwin and 
       endwin are absolute dates in $HOROLOG format.

4      Represent all dates with four-digit years. Dates input with two- digit
       years are rejected as invalid.

       Represent with two-digit years all dates falling within the sliding
5      temporal window defined by startwin and (optionally) endwin. Represent
       all other dates with four-digit years. When yearopt=5, startwin and 
       endwin are relative years.

6      Represent all dates in the current century with two-digit years and all
       other dates with four-digit years.

startwin
A numeric value that specifies the start of the sliding window during which
dates must be represented with two-digit years. You must supply startwin when
you use a yearopt of 3 or 5.startwin is not valid with any other yearopt
values.
When yearopt=3, startwin is an absolute date in $HOROLOG date format that
indicates the start date of the sliding window.
When yearopt= 5, startwin is a numeric value that indicates the start year of
the sliding window expressed in the number of years before the current year.
The sliding window always begins on the first day of the year (January 1)
specified in startwin.
endwin
A numeric value that specifies the end of the sliding window during which dates
are represented with two-digit years. You may optionally supply endwin when 
yearopt is 3 or 5. endwin is not valid with any other yearopt values.
When yearopt=3, endwin is an absolute date in $HOROLOG date format that
indicates the end date of the sliding window.
When yearopt=5, endwin is a numeric value that indicates the end year of the
sliding window expressed as the number of years past the current year. The
sliding window always ends on the last day of the year (December 31) of the
year specified in endwin or of the implied end year (if you omit endwin).
If endwin is omitted (or specified as -1) the effective sliding window will be
100 years long. The endwin value of -1 is a special case that always returns a
date value, even when higher and lower endwin values return erropt. For this
reason, it is preferable to omit endwin when specifying a 100-year window, and
to avoid the use of negative endwin values.
If you supply both startwin and endwin, the sliding window they specify must
not have a duration of more than 100 years.
mindate
A numeric value that specifies the lower limit of the range of valid dates.
Specifying a date smaller than mindate generates a <VALUE OUT OF RANGE> error
message.
You specify mindate in $HOROLOG format. For example, 1/1/2007 is represented as
60631. You can include or omit the time portion of the $HOROLOG date (for
example  60631,43200 ), but only the date portion of mindate is parsed. mindate
must be smaller than maxdate.
If mindate is omitted or specified as -1, this limit is obtained from the
DateMinimum property of the current locale, which defaults to zero
(corresponding to December 31, 1840).
maxdate
A numeric value that specifies the upper limit of the range of valid dates.
Specifying a date larger than maxdate generates a <VALUE OUT OF RANGE> error
message.
You specify maxdate in $HOROLOG format. For example, 1/1/2100 is represented as
94599. You can include or omit the time portion of the $HOROLOG date (for
example  94599,43200 ), but only the date portion of maxdate is parsed. maxdate
must be larger than mindate.
If maxdate is omitted or if specified as -1, this limit is obtained from the
DateMaximum property of the current locale, which defaults to the maximum
permissible value for the date portion of $HOROLOG: 2980013 (corresponding to
December 31, 9999).
erropt
This parameter suppresses error messages associated with invalid or out of
range date values. Instead of generating <ILLEGAL VALUE> or <VALUE OUT OF
RANGE> error messages, the $ZDATETIMEH function returns erropt.
Examples
The following example returns the $HOROLOG date for June 12, 1983:

   WRITE $ZDATEH("06/12/83")
returns 52027.
The following example returns the $HOROLOG date for June 12, 1902 (which may
not have been your intent):

   WRITE $ZDATEH("06/12/02")
returns 22442.
Note:
Two-digit years, by default, are considered 20th Century dates; for 21st
Century dates, specify a four-digit year, or change the two-digit sliding
window by specifying the yearopt, startwin and endwin parameters. This sliding
window can also be set for your locale.
The following example shows how the dformat parameter is used to permit
multiple date entry formats:

   WRITE !,$ZDATEH("November 2, 1954",5)
   WRITE !,$ZDATEH("Nov 2, 1954",5)
   WRITE !,$ZDATEH("Nov. 2 1954",5)
   WRITE !,$ZDATEH("11/2/1954",5)
   WRITE !,$ZDATEH("11.02.54",5)
   WRITE !,$ZDATEH("11 02 1954",5)
all return 41578.
In the following examples, suppose the current date is January 16, 2007:

   WRITE $HOROLOG
returns 60646,37854, the first integer of which is the current date (the second
integer is the current time, in elapsed seconds).
The next example uses the  T date to return today’s date (here, January 16,
2007):

   WRITE $ZDATEH("T",5)
returns 60646.
The next examples returns the current date with an offset of plus 2 days and
minus 2 days:

   WRITE !,$ZDATEH("T+2",5)
   WRITE !,$ZDATEH("T-2",5)
returns 60648 and 60644.
The final example illustrates that when no year is specified, $ZDATEH assumes
the current year (in this case, 2007):

   WRITE $ZDATEH("25 Nov",5)
returns 60959.
Notes
Invalid Values with $ZDATEH
You receive a <FUNCTION> error in the following conditions:

  • If you specify an invalid dformat code (an integer less than -1 or greater
    than 9, a zero, or a noninteger value)
  • If you specify an invalid yearopt code (an integer less than -1 or greater
    than 6, a value of zero, or a noninteger value)
  • If you do not specify a startwin value when yearopt is 3 or 5

You receive a <ILLEGAL VALUE> error under the following conditions:

  • If you specify an invalid value for any date unit (day, month, or year). If
    specified, the erropt value is returned rather than issuing an <ILLEGAL
    VALUE>.
  • If you specify excess leading zeros for any date unit (day, month, or year)
    in an ODBC date. For example, you can represent the February 3, 2007 as  
    2007 2 3 or  2007 02 03 , but will receive an <ILLEGAL VALUE> for  2007 002
     03 . If specified, the erropt value is returned rather than issuing an
    <ILLEGAL VALUE>.
  • If the given month number is greater than the number of month values in 
    monthlist.
  • If maxdate is less than mindate.
  • If endwin is less than startwin.
  • If startwin and endwin specify a sliding temporal window whose duration is
    greater than 100 years.

You receive a <VALUE OUT OF RANGE> error under the following conditions:

  • If you specify a date (or an offset to  T ) which is earlier than Dec. 31,
    1840 or later than Dec. 31, 9999, and do not supply an erropt value
  • If you specify an otherwise valid date (or an offset to  T ) which is
    outside the range of mindate and maxdate and do not supply an erropt value.

Error Handling with erropt
When supplied, the erropt parameter only suppresses error messages generated
due to invalid or out of range values of date. Errors generated due to invalid
or out of range values of other parameters will always generate error messages
whether or not erropt has been supplied.
For example, an <ILLEGAL VALUE> error is always generated when $ZDATEH
specifies a sliding window where endwin is earlier than startwin. Similarly, an
<ILLEGAL VALUE> error is generated when maxdate is less than mindate.
Acceptable Date Values with Date Formats 5 through 9
The $ZDATEH date formats (dformat) 5 through 9 accept any date value that is
unambiguous. Date formats 5 through 9 assume the current year if the date you
specify does not include a year. When you pass a dformat of 5, 6, 7, 8, or 9 to
$ZDATEH, it accepts any of the following formats:

  • Mmm D
  • Mmm D, YY
  • Mmm D, YYYY
  • Mmm D YY
  • Mmm D YYYY
  • Mmm DD
  • Mmm DD YY
  • Mmm DD YYYY
  • YYYYMMDD
  • YYMMDD
  • YYYY-MM-DD
  • YYYY MM DD
  • YYYY Mmm DD
  • MM/DD
  • MM/DD/YY
  • MM/DD/YYYY
  • MM-DD
  • MM-DD-YY
  • MM-DD-YYYY
  • DD Mmm
  • DD Mmm YY
  • DD Mmm YYYY
  • DD-Mmm
  • DD-Mmm-YY
  • DD-Mmm-YYYY

MMDD is not an implemented format.
Using $ZDATEH Instead of Utilities
Keep the following points in mind when you need to choose between the $ZDATEH
function and a date utility:

  • You can use the $ZDATEH function in place of the existing entry points of
    the %DATE and %DI utility.
  • $ZDATEH and $ZDATE are much faster than calling entry points of %DATE, %DI
    or %DO.

Date Delimiter
$ZDATEH will use the value of the DateSeparator property of the current locale
as the delimiter between months, days, and the year when dformat=1 or 4. The
delimiter in the ODBC date format (dformat=3) will always be a  - as required
by the ODBC standard. The default value of DateSeparator is  / and all
documentation uses this delimiter.
To determine the default date separator for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DateSeparator")
See Also

  • JOB command
  • $ZDATE function
  • $ZDATETIME function
  • $ZDATETIMEH function
  • $ZTIME function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable
  • %DATE utility, which is documented in the  Legacy Documentation chapter in 
    Using InterSystems Documentation
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ZDATE*  #{{{

Validates date and converts format.
Synopsis

$ZDATE(hdate,dformat,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)
$ZD(hdate,dformat,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)

Parameters

           An integer specifying an internal date format value. This integer
hdate      represents the number of days elapsed since December 31, 1840. If 
           $HOROLOG is specified for hdate, only the date portion of $HOROLOG
           is used.

dformat    Optional  Format for the returned date.

monthlist  Optional  A string or the name of a variable that contains the month
           names you supplied.

yearopt    Optional  A code that specifies whether to represent years as two-
           or four-digit values

startwin   Optional  The start of the sliding window during which dates must be
           represented with two-digit years.

endwin     Optional  The end of the sliding window during which dates are
           represented with two-digit years.

mindate    Optional  The lower limit of the range of valid dates.

maxdate    Optional  The upper limit of the range of valid dates.

erropt     Optional  This parameter suppresses error codes associated with
           invalid or out of range hdate values.

Description
The $ZDATE function converts a specified date in internal storage format (
$HOROLOG format) to one of several alternate date display formats. The value
returned by $ZDATE depends on the parameters you use.
Simple $ZDATE format
$ZDATE(hdate), the most basic form of $ZDATE, returns the date in a display
format that corresponds to the specified hdate. hdate is an integer count of
the number of days elapsed since December 31, 1840. It can range from 0 to
2980013 (12/31/1840 to 12/31/9999).
By default, $ZDATE(hdate) represents years between 1900 and 1999 with two
digits. It represents years that fall before 1900 or after 1999 with four
digits. For example:

  WRITE $ZDATE(21400),!  ; returns 08/04/1899
  WRITE $ZDATE(50000),!  ; returns 11/23/77
  WRITE $ZDATE(60000),!  ; returns 04/10/2005
  WRITE $ZDATE(0),!      ; returns 12/31/1840
When you supply a $HOROLOG date to $ZDATE, only the date portion is used. In 
$HOROLOG format, date and time are presented as two integers separated by a
comma. Upon encountering the comma (a non-numeric character) $ZDATE ignores the
rest of the string. In the following example, $ZDATE returns 04/10/2005 and the
current date using $HOROLOG format values:

   WRITE !,$ZDATE("60000,12345")
   WRITE !,$ZDATE($HOROLOG)
Customizable Date Default
Upon Caché startup, the default date format is initialized to dformat=1, which
is the American date format with a slash date separator (MM/DD/[YY]YY). To set
this and other default formats to the values for your current locale, set the
following global variable: SET ^SYS("NLS","Config","LocaleFormat")=1. This sets
all format defaults for all processes to your current locale values. These
defaults persist until this global is changed.
You can use NLS (National Language Support) to override format defaults for the
current process. You can either change the all format defaults to the values
for a specified locale, or change individual format values.

  • To set all of the format defaults (including the date format default) to
    the properties of a specified locale, invoke the following method call: 
    SET fmt=##class(%SYS.NLS.Format).%New("lname"), where lname is the NLS name
    of the desired locale. (For example, deuw=German, espw=Spanish, ptbw=
    Portuguese, rusw=Russian, jpnw=Japanese. A complete list of locales is
    found in the System Management Portal: [Home] > [Configuration] > [NLS
    Settings] > [Locale Definitions]) To set these defaults to the properties
    of the current locale, specify a lname of "current", or the empty string
    ("").
  • To set the default date format to a specified dformat format, invoke the
    following method call: 
    SET rtn=##class(%SYS.NLS.Format).SetFormatItem("DateFormat",n), where n is
    the number of the dformat value you wish to make the default.

The following example demonstrates setting all format defaults to the Russian
locale, returning a date from $ZDATE in the default format (Russian), then
resetting the format defaults to the current locale defaults:

   WRITE !,$ZDATE($HOROLOG)
   SET fmt=##class(%SYS.NLS.Format).%New("rusw")
   WRITE !,$ZDATE($HOROLOG)
   SET fmt=##class(%SYS.NLS.Format).%New("current")
   WRITE !,$ZDATE($HOROLOG)
The following example demonstrates setting individual format defaults. The
first $ZDATE returns a date in the default format. The first SetFormatItem
method changes the default to dformat=4, or the European date format (DD/MM/
[YY]YY), as is shown by the second $ZDATE. The second SetFormatItem method
changes the default for the date separator character (which affects the dformat
 1, 1, and 4). In this example, the date separator character is set to a dot ( 
. ), as is shown by the third $ZDATE. Finally, this program restores the
original date format values:

InitialVals
   SET fmt=##class(%SYS.NLS.Format).GetFormatItem("DateFormat")
   SET sep=##class(%SYS.NLS.Format).GetFormatItem("DateSeparator")
   WRITE !,$ZDATE($HOROLOG)
ChangeVals
   SET x=##class(%SYS.NLS.Format).SetFormatItem("DateFormat",4)
   WRITE !,$ZDATE($HOROLOG)
   SET y=##class(%SYS.NLS.Format).SetFormatItem("DateSeparator",".")
   WRITE !,$ZDATE($HOROLOG)
RestoreVals
   SET x=##class(%SYS.NLS.Format).SetFormatItem("DateFormat",fmt)
   SET y=##class(%SYS.NLS.Format).SetFormatItem("DateSeparator",sep)
   WRITE !,$ZDATE($HOROLOG)
Parameters
hdate
The internal date format value representing the number of days elapsed since
December 31, 1840. It must be an integer in the range 0 through 2980013. You
can specify it as a numeric value, the name of a variable, or an expression.
dformat
Format for the returned date. Valid values are:

Value                                  Meaning

       Get effective dformat value from fmt.DateFormat, where fmt is an
-1     instance of ##class(%SYS.NLS.Format) associated with the current
       process. This is the default behavior if you do not specify dformat. See
        Customizable Date Default for further details.

0      DD Mmm [YY]YY (01 Jul 97 or 27 Mar 2002)

1      MM/DD/[YY]YY (07/01/97 or 03/27/2002)

2      DD Mmm [ YY ]YY (01 Jul 97 or 27 Mar 2002)

3      YYYY-MM-DD (1997-07-01 or 2002-03-27)  ODBC format

4      DD/MM/[YY]YY (01/07/97 or 27/03/2002)  European format

5      Mmm D, YYYY (Jul 1, 1997 or Mar 27, 2002)

6      Mmm D YYYY (Jul 1 1997 or Mar 27 2002)

7      Mmm DD [YY]YY (Jul 01 97 or Mar 27 2002)

8      YYYYMMDD (19970701 or 20020327)  Numeric format

9      Mmmmm D, YYYY (July 1, 1997 or March 27, 2002)

10     W (2)  Day number for the week

11     Www (Tue)  Abbreviated day name

12     Wwwwww (Tuesday)  Full day name

       [D]D/[M]M/YYYY (1/7/2549 or 27/11/2549)  Thai date format. Day and month
13     are identical to European usage, except no leading zeros. The year is
       the Buddhist Era year, calculated by adding 543 years to the Gregorian
       year.

14     nnn (354)  Day number for the year

where:

Syntax                                  Meaning

        YYYY is a four-digit year. [YY]YY is a two-digit year if hdate falls
YYYY    within the active window for two-digit years; otherwise it is a
        four-digit year.

MM      Two-digit month.

D       One-digit day if the day number <10. Otherwise, two digits.

DD      Two-digit day.

        Month abbreviation extracted from the MonthAbbr property in the current
        locale. An alternate month abbreviation (or name of any length) can be
Mmm     extracted from an optional list specified as the monthlist parameter to
        $ZDATE. The default MonthAbbr values are:
         Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 

        Full name of the month as specified by the MonthName property. The
Mmmmm   default values are:
         January February March ... November December 

W       Number 0-6 indicating the day of the week:
        Sunday=0, Monday=1, Tuesday=2, etc.

        Weekday name abbreviation as specified by the WeekdayAbbr property of
Www     the current locale. The default values are:
         Sun Mon Tue Wed Thu Fri Sat 

        Weekday full name as specified by the WeekdayName property in the
Wwwwww  current locale. The default values are:
         Sunday Monday Tuesday ... Friday Saturday 

nnn     Day number for the specified year, always three digits, with leading
        zeros if necessary. Values are 001 through 365 (or 366 on leap years).

To determine the default date format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DateFormat")
To determine the default weekday names and weekday abbreviations for your
locale, invoke the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("WeekdayName"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("WeekdayAbbr"),!
monthlist
A string or the name of a variable that contains the month names you supplied.
The names in monthlist replace the default month abbreviation values from the
MonthAbbr property of the current locale. You would use monthlist to specify
full month names or month names or abbreviations in languages other than
English.
monthlist is valid only if dformat is 0, 2, 5, 6, 7, or 9. If dformat is 1, 3,
4, 8, 10, 11, or 12, $ZDATE ignores monthlist.
The first character in monthlist specifies a delimiter. For example, the space
before Jan in the default built-in list. The same delimiter must appear between
each month name or abbreviation in monthlist. This delimiter appears between
the month, day, and year portions of the returned date value.
If you omit monthlist or specify a monthlist value of -1, $ZDATE uses the list
of month name abbreviations defined in the MonthAbbr property of the current
locale, which by default is:
 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 
except when dformat is 9, in which case $ZDATE uses the list of Month full
names defined the MonthName property of the current locale, which by default
is:
 January February March ... November December 
To determine the default month names and month abbreviations for your locale,
invoke the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthName"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthAbbr"),!
Note that the first character in the MonthName and MonthAbbr lists is a
delimiter character, by default a blank space. You can specify these lists with
another delimiter character, such as the following list using a comma
delimiter:
 ,Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec 
The following example lists the month names the default locale, changes the
locale for this process to the Russian locale, then lists the Russian month
names and displays the current date with a Russian month name. It then reverts
the locale defaults to current locale and again displays the current date, this
time with the default month name.

   WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthName"),!
   SET fmt=##class(%SYS.NLS.Format).%New("rusw")
   WRITE fmt.MonthName,!
   WRITE $ZDATE($HOROLOG,9),!
   SET fmt=##class(%SYS.NLS.Format).%New()
   WRITE $ZDATE($HOROLOG,9)
yearopt
With dformat values 0, 1, 2, 4, or 7, a numeric code that specifies the time
window in which to display the year as a two-digit value. Valid values are:

Value                                  Meaning

       Get effective yearopt value from YearOption property of current locale
-1     which defaults to a value of 0. This is the default behavior if you do
       not specify yearopt.

       Represent 20th century dates (1900 through 1999) with two-digit years
       and all other dates with four-digit years, unless a process-specific
0      sliding window (established via the %DATE utility) is in effect. If such
       a window is in effect, represent only those dates falling within the
       sliding window by two-digit years, and all other dates with four-digit
       years.

1      Represent 20th century dates with two-digit years and all other dates
       with four-digit years.

2      Represent all dates with two-digit years.

       Represent with two-digit years those dates falling within the sliding
3      temporal window defined by startwin and (optionally) endwin. Represent
       all other dates with four-digit years. When yearopt =3, startwin and 
       endwin are absolute dates in $HOROLOG format.

4      Represent all dates with four-digit years.

       Represent with two-digit years all dates falling within the sliding
5      temporal window defined by startwin and (optionally) endwin. Represent
       all other dates with four-digit years. When yearopt=5, startwin and
       endwin are relative years.

6      Represent all dates in the current century with two-digit years and all
       other dates with four-digit years.

To determine the default year option for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("YearOption")
startwin
A numeric value that specifies the start of the sliding window during which
dates must be represented with two-digit years. See parameter section. You must
supply startwin when yearopt is 3 or 5. startwin is not valid with any other 
yearopt values.
When yearopt = 3, startwin is an absolute date in $HOROLOG date format that
indicates the start date of the sliding window.
When yearopt = 5, startwin is a numeric value that indicates the start year of
the sliding window expressed as the number of years before the current year.
The sliding window always begins on January 1st of the year specified in 
startwin.
endwin
A numeric value that specifies the end of the sliding window during which dates
are represented with two-digit years. You may optionally supply endwin when 
yearopt is 3 or 5. endwin is not valid with any other yearopt values.
When yearopt = 3, endwin is an absolute date in $HOROLOG date format that
indicates the end date of the sliding window.
When yearopt = 5, endwin is a numeric value that indicates the end year of the
sliding window expressed as the number of years past the current year. The
sliding window always ends on December 31st of the year specified in endwin. If
endwin is not specified, it defaults to December 31st of the year 100 years
after startwin.
If endwin is omitted (or specified as -1) the effective sliding window will be
100 years long. The endwin value of -1 is a special case that always returns a
date value, even when higher and lower endwin values return erropt. For this
reason, it is preferable to omit endwin when specifying a 100-year window, and
to avoid the use of negative endwin values.
If you supply both startwin and endwin, the sliding window they specify must
not have a duration of more than 100 years.
mindate
A numeric value that specifies the lower limit of the range of valid dates. If
omitted or specified as -1, this limit is obtained from the DateMinimum
property of the current locale, which defaults to zero (corresponding to
December 31, 1840). If mindate is larger than the specified hdate, Caché
generates a <VALUE OUT OF RANGE> error.
maxdate
A numeric value that specifies the upper limit of the range of valid dates. If
omitted or if specified as -1, this limit is obtained from the DateMaximum
property of the current locale, which defaults to the maximum permissible value
for the date portion of $HOROLOG: 2980013 (corresponding to December 31, 9999).
If maxdate is larger than 2980013, Caché generates an <ILLEGAL VALUE> error. If
maxdate is smaller than the specified hdate, Caché generates a <VALUE OUT OF
RANGE> error.
erropt
This parameter suppresses errors associated with invalid or out of range hdate
values. Instead of generating <ILLEGAL VALUE> or <VALUE OUT OF RANGE> errors,
the function returns erropt.
Examples
The first example shows the $HOROLOG internal format:

   WRITE $HOROLOG
returns a value such as the following: 61132,42347.
The following example returns the current date in the default display format, 
MM/DD/YY:

   WRITE $ZDATE($HOROLOG)
The following command returns the current date in the specified display format:

   WRITE $ZDATE($HOROLOG,2)
Date Format Examples
The following examples illustrate how $ZDATE returns the various dformat
formats. (The names and abbreviations of months and days of the week are, of
course, locale-dependent.)

   WRITE $ZDATE(26240,1)
returns 11/04/12.

   WRITE $ZDATE(26240,2)
returns 04 Nov 12.

   WRITE $ZDATE(26240,3)
returns 1912-11-04.

   WRITE $ZDATE(26240,4)
returns 04/11/12.

   WRITE $ZDATE(26240,5)
returns Nov 4, 1912.

   WRITE $ZDATE(26240,6)
returns Nov 4 1912.

   WRITE $ZDATE(26240,7)
returns Nov 04 12.

   WRITE $ZDATE(26240,8)
returns 19121104.

   WRITE $ZDATE(26240,9)
returns November 4, 1912.

   WRITE $ZDATE(26240,10)
returns 1.

   WRITE $ZDATE(26240,11)
returns Mon.

   WRITE $ZDATE(26240,12)
returns Monday.
Two-digit Year Sliding Window Example
To illustrate how to use an explicit sliding window, suppose you enter the
following function call in 1997. The hdate of 59461 represents October 19,
2003; the dformat of 1 allows it to return two-digit or four-digit years, and
the yearopt of 5 specifies a sliding window for four-digit years. Because of
the yearopt setting, the startwin and endwin are calculated relative to the
current year (in this case 1997) by addition and subtraction.

   WRITE $ZDATE(59461,1,,5,90,10)
The sliding window for displaying the year as two digits extends from 1/1/1907
to 12/31/2006. Thus Caché displays the date as 10/19/03.
Date Range Example
The following example illustrates the use of mindate and maxdate. The dates are
specified in $HOROLOG format, and represent the date range from 1/8/1950 to 4/
10/2005.

   WRITE $ZDATE(59451,,,,,,40000,60000)
displays as 10/09/2003.

   WRITE !,$ZDATE(39000,,,,,,40000,60000)
   WRITE !,$ZDATE(62000,,,,,,40000,60000)

both of the above lines generate a <VALUE OUT OF RANGE> error, because 10/12/
1947 and 10/1/2010 fall outside of the date range.
Notes
Invalid Values with $ZDATE
You receive a <FUNCTION> error in the following conditions:

  • If you specify an invalid dformat code (an integer value less than -1 or
    greater than 12, a zero, or a noninteger value).
  • If you do not specify a startwin value when yearopt is 3 or 5.

You receive an <ILLEGAL VALUE> error under the following conditions:

  • If you specify an invalid value for hdate and do not either supply an 
    erropt value or set $ZUTIL(68,32) or $ZUTIL(69,32).
  • If the given month number is greater than the number of month values in 
    monthlist.
  • If maxdate is less than mindate.
  • If endwin is less than startwin.
  • If startwin and endwin specify a sliding temporal window whose duration is
    greater than 100 years.

You receive a <VALUE OUT OF RANGE> error under the following conditions:

  • If you specify an hdate value that is out of the range of valid dates. For
    standard Caché this is 0 through 298013. For ISM-compatible Caché this is 1
    through 94232. See $ZUTIL(68,32) Set Date Range and Invalid Date Behavior.
  • If you specify an otherwise valid date which is outside the range defined
    by the values assumed for maxdate and mindate and do not supply an erropt
    value.

Error Handling with erropt
Caché performs standard numeric evaluation on hdate, which must evaluate to a
positive integer; thus, 7, "7", +7, 0007, 7.0, "7 dwarves", and --7 all
evaluate to the same date value: 01/07/1841. By default, values greater than
2980013 or less than 0 generate a <VALUE OUT OF RANGE> error; fractional values
generate an <ILLEGAL VALUE> error. Non-numeric strings (including the null
string) return the initial date: 12/31/1840.
When supplied, the erropt parameter suppresses errors generated due to invalid
or out of range values of hdate. Errors generated due to invalid or out of
range values of other parameters will always generate errors whether or not 
erropt has been supplied.
For example, an <ILLEGAL VALUE> error is always generated when $ZDATE specifies
a sliding window where endwin is earlier than startwin. Similarly, an <ILLEGAL
VALUE> error is generated when maxdate is less than mindate.
Error Handling with $ZUTIL(68,32) and $ZUTIL(69,32)
The behavior of $ZDATE when given an invalid value for hdate can be set by
using the $ZUTIL(68,32) and $ZUTIL(69,32) functions. $ZDATE can either issue an
error, or return a null value. See $ZUTIL(68,32) Set Date Range and Invalid
Date Behavior.
The system-wide default behavior is configurable. Go to the System Management
Portal, select [Home] > [Configuration] > [Compatibility Settings]. View and
edit the current setting of ZDateNull. The default is  false , meaning that 
$ZDATE returns an error.
Using $ZDATE Instead of Utilities
Keep the following points in mind when you need to choose between the $ZDATE
function and a date utility:

  • You can use the $ZDATE function in place of most existing entry points of
    the %DO or %D utilities.
  • You can invoke $ZDATE($HOROLOG,7) directly instead of calling INT ^%D. This
    provides the current date in  Mmm DD [YY]YY format.
  • $ZDATEH and $ZDATE are much faster than calling entry points of %DATE, %DI
    or %DO.

Date Delimiter
$ZDATE will use the value of the DateSeparator property of the current locale
as the delimiter between months, days, and the year when dformat=1 or 4. The
delimiter in the ODBC date format (dformat=3) will always be a  - as required
by the ODBC standard. The default value of DateSeparator is  / and all
documentation uses this delimiter.
See Also

  • JOB command
  • $ZDATEH function
  • $ZDATETIME function
  • $ZDATETIMEH function
  • $ZTIME function
  • $ZUTIL(68,32) Set Date Range and Invalid Date Behavior function
  • $ZUTIL(69,32) Set Date Range and Invalid Date Behavior function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable
  • %DATE utility, which is documented in the  Legacy Documentation chapter in 
    Using InterSystems Documentation
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ZDATETIMEH*  #{{{

Validates date and time and converts to internal format.
Synopsis

$ZDATETIMEH(datetime,dformat,tformat,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)
$ZDTH(datetime,dformat,tformat,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)

Parameters

           The date and time input value. A date/time string specified in
           display format. $ZDATETIMEH converts this date/time string to 
           $HOROLOG format. The datetime value can be either an explicit date
datetime   and time (specified in various formats), an explicit date (specified
           in various formats) with the time value defaulting to 0, or the
           string  T or  t , representing the current date, with the time value
           either specified or defaulting to 0. The  T or  t string can
           optionally include a signed integer offset.

           Optional  The date format corresponding to the date portion of the 
dformat    datetime value. If datetime is  T , dformat must be 5, 6, 7, 8, or
           9.

tformat    Optional  The time format corresponding to the time portion of the 
           datetime value.

           Optional  A string containing a list of month names (or month name
monthlist  abbreviations). This string must begin with a delimiter character,
           and its 12 entries must be separated by this delimiter character.

yearopt    Optional  The time window in which to display the year as a
           two-digit value.

startwin   Optional  The start of the sliding window during which dates must be
           represented with two-digit years.

endwin     Optional  The end of the sliding window during which dates are
           represented with two-digit years.

mindate    Optional  The lower limit of the range of valid datetime dates,
           specified in $HOROLOG format.

maxdate    Optional  The upper limit of the range of valid datetime dates,
           specified in $HOROLOG format.

           Optional  A expression that resolves to a string or numeric.
erropt     Specifying an erropt value suppresses error messages associated with
           invalid or out of range datetime values. Instead of issuing an error
           message, $ZDATETIMEH returns erropt.

Description
$ZDATETIMEH validates a specified date and time value and converts it from
display format to internal format. The corresponding $ZDATETIME function
converts a date and time from internal format to display format. Internal
format is the format used by the $HOROLOG or $ZTIMESTAMP. It represents a date
and time value as a string of two numeric values separated by a comma.
The exact value returned depends on the parameters you use.
$ZDATETIMEH(datetime) converts a date and time value in the format "MM/DD/[YY]
YY hh:mm:ss[.ffff] to $HOROLOG format.

Syntax                                  Meaning

MM      A two-digit month.

DD      A two-digit day.

[YY]YY  Two or four digits for years from 1900 to 1999. Four digits for years
        before 1900 or after 1999.

hh      The hour in a 24-hour clock format.

mm      Minutes.

ss      Seconds.

ffff    Fractional seconds (zero to nine digits).

$ZDATETIMEH(datetime,dformat,tformat,monthlist,yearopt,startwin,endwin,mindate,
maxdate,erropt) converts a date and time value that was originally specified
(through $ZDATETIME) in date and time to $HOROLOG or $ZTIMESTAMP format. The 
dformat, tformat, yearopt, startwin and endwin values are identical to the
values used by $ZDATETIME.
However, when you use a dformat of 5, 6, 7, 8, or 9, $ZDATETIMEH recognizes and
converts a date in any of the external date formats corresponding to dformat
codes 1, 2, 3, 5, 6, 7, 8, or 9, as well as the current date specified by the
letter  T or  t , optionally followed by a plus (+) or a minus (-), and the
number of days after or before the current date.
$ZDATETIMEH recognizes and converts a time in any of eight time formats,
regardless of which time format you specify in the function call. In addition, 
$ZDATETIMEH recognizes the suffixes  AM, PM, NOON, and MIDNIGHT. You can
express these suffixes in uppercase, lowercase, or mixed case. You can also
abbreviate these suffixes to any number of letters.
The recognized forms include:

  • The default date format, MM/DD/[YY]YY
  • The format DDMmm[YY]YY
  • The ODBC format [YY]YY-MM-DD
  • The format DD/MM/[YY]YY
  • The format Mmm D, YYYY
  • The format Mmm D YYYY
  • The format Mmm DD YY
  • The format YYYYMMDD (numeric format)

Parameter Values
datetime
The date and time string that you want to convert to $HOROLOG format. You can
specify any of the following:

  • An expression that evaluates to a single string with the date first,
    followed by a single blank space, followed by the time.
  • An expression that evaluates to a string specifying the date only. The time
    value defaults to midnight (0), unless tformat is 7 or 8, in which case the
    time defaults to the local time zone offset from midnight (0).
  • The letter code  T or  t , which specifies the current date. This letter
    can optionally be followed by a plus (+) or a minus (-) sign and an integer
    specifying an offset, in days, from the current date. You can either follow
    this date expression by a single blank space and a time expression, or
    allow the time to default to midnight (0). (If tformat is 7 or 8, the time
    defaults to the local time zone offset from midnight (0).) If you use this
    current date option, you must specify a dformat of 5, 6, 7, 8, or 9.

Valid date and time values depend on the DateFormat and TimeFormat properties
of the current locale and the values specified for the dformat and tformat
parameters. For details on specifying dates, refer to $ZDATEH.
dformat
Format for the date. Valid values are:

Value                                  Meaning

       Get effective dformat value from the DateFormat property of the current
-1     locale, which defaults to a value of 1. This is the default behavior if
       you do not specify dformat.

1      MM/DD/[YY]YY (01/01/97 or 03/27/2002) - The default format

2      DD Mmm [YY]YY (01 Jul 97 or 27 Mar 2002)

3      [YY]YY-MM-DD (1997-07-01 or 2002-03-27) - ODBC format

4      DD/MM/[YY]YY (01/07/97 or 27/03/2002) - European format

5      Mmm D, YYYY (Jul 1, 1997 or Mar 27, 2002)

6      Mmm D YYYY (Jul 1 1997 or Mar 27 2002)

7      Mmm DD [YY]YY (Jul 01 1997 or Mar 27 2002)

8      YYYYMMDD (19930701 or 20020327) - Numeric format

9      Mmmmm D, YYYY (July 1, 1997 or March 27, 2002)

Where:

Syntax                                  Meaning

        YYYY is a four-digit year. [YY]YY is a two-digit year if datetime falls
YYYY    within the active window for two-digit dates; otherwise it is a
        four-digit number.

MM      Two-digit month.

D       One-digit day if the day number <10. Otherwise, two digits.

DD      Two-digit day.

        Mmm is a month abbreviation extracted from the MonthAbbr property in
        the current locale. The default values are:
Mmm      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 
        Or an alternate month abbreviation (or name of any length) extracted
        from an optional list specified as the monthlist parameter to 
        $ZDATETIMEH.

        Full name of the month as specified by the MonthName property. The
Mmmmm   default values are:  January February March ... November December 
        Or an alternate month name extracted from an optional list specified as
        the monthlist parameter to $ZDATETIMEH.

To determine the default date format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DateFormat")
tformat
A numeric value that specifies the format in which you want to express the time
value. Supported values are as follows:

Value                                  Meaning

       Get the effective tformat value from the TimeFormat property of the
-1     current locale, which defaults to a value of 1. This is the default
       behavior if you do not specify tformat.

1      Express time in the form "hh:mm:ss" (24-hour clock)

2      Express time in the form  hh:mm (24-hour clock)

3      Express time in the form  hh:mm:ss[AM/PM] (12-hour clock)

4      Express time in the form  hh:mm[AM/PM] (12-hour clock)

       Express time in the form "hh:mm:ss+/-hh:mm" (24-hour clock). The time is
       expressed as local time. The plus (+) or minus ( ) suffix shows the
       offset of local time from Coordinated Universal Time (UTC), also known
5      as Greenwich Mean Time (GMT). A minus sign (-hh:mm) indicates that the
       local time is earlier (westward) from Greenwich by the returned offset
       number of hours and minutes. A plus sign (+hh:mm) indicates that the
       local time is later (eastward) from Greenwich by the returned offset
       number of hours and minutes.

       Express time in the form  hh:mm+/-hh:mm (24-hour clock). The time is
       expressed as local time. The plus (+) or minus ( ) suffix shows the
       offset of local time from Coordinated Universal Time (UTC), also known
6      as Greenwich Mean Time (GMT). A minus sign (-hh:mm) indicates that the
       local time is earlier (westward) from Greenwich by the returned offset
       number of hours and minutes. A plus sign (+hh:mm) indicates that the
       local time is later (eastward) from Greenwich by the returned offset
       number of hours and minutes.

       Express time in the form "hh:mm:ssZ" (24-hour clock). The  Z suffix
7      indicates that the time is expressed as Coordinated Universal Time
       (UTC), also known as Greenwich Mean Time (GMT), rather than as local
       time.

       Express time in the form  hh:mmZ (24-hour clock). The  Z suffix
8      indicates that the time is expressed as Coordinated Universal Time
       (UTC), also known as Greenwich Mean Time (GMT), rather than as local
       time.

For tformat values 1 through 4 (which return local time), the date is separated
from the time by a space. For tformat values 5 through 8 (which return UTC time
information), the date is separated from the time by the letter  T .
When tformat is set to 7 or 8, the time is returned as UTC time, and the date
returned is also adjusted (if necessary) to this UTC time value. This date may
differ from the local date.
To determine the default time format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeFormat")
monthlist
A string, or the name of a variable that contains a string of month names. The
names in monthlist replace the default month name values and month abbreviation
values, overriding the MonthName and MonthAbbr properties of the current
locale. The most common use of monthlist is to specify full month names or
month name abbreviations in languages other than the default language for your
locale.
monthlist is valid only if dformat is 2, 5, 6, 7, or 9. If dformat is -1, 1, 3,
4, or 8$ZDATETIMEH ignores monthlist.
The monthlist string has the following format:

  • The first character of the string is a delimiter character (usually a
    space). The same delimiter must appear between each month name in monthlist
    . This delimiter appears between the month, day, and year portions of the
    returned display date value, which is why a space is usually the preferred
    character.
  • The month names list should contain twelve entries, corresponding to
    January through December. It is possible to specify more or less than
    twelve month names, but if there is no month name corresponding to the
    month in hdatetime an <ILLEGAL VALUE> error is generated.

If you omit monthlist or specify a monthlist value of -1, and dformat is 2, 5,
6, or 7, $ZDATETIMEH uses the list of month name abbreviations defined in the 
MonthAbbr property of the current locale, which by default is:  Jan Feb Mar Apr
May Jun Jul Aug Sep Oct Nov Dec .
If you omit monthlist or specify a monthlist value of -1, and dformat is 9, 
$ZDATETIMEH uses the list of month names defined in the MonthName property of
the current locale, which by default is:  January February March April May June
July August September October November December .
To determine the default month names and month abbreviations for your locale,
invoke the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthName"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthAbbr"),!
yearopt
With dformat values 0, 1, 2, 4, or 7, a numeric code that specifies the time
window in which to display the year as a two-digit value. yearopt can be:

Value                                  Meaning

       Get effective yearopt value from YearOption property of current locale
-1     which defaults to 0. This is the default behavior if you do not specify 
       yearopt .

       Represent 20th century dates (1900 through 1999) with two-digit years,
       unless a process-specific sliding window (established via the %DATE
0      utility) is in effect. If such a window is in effect, represent only
       those dates falling within the sliding window by two-digit years.
       Represent all dates falling outside the 20th century or outside the
       process-specific sliding window by four-digit years.

1      Represent 20th century dates with two-digit years and all other dates
       with four-digit years.

2      Represent all dates with two-digit years.

       Represent with two-digit years those dates falling within the sliding
3      temporal window defined by startwin and (optionally) endwin. Represent
       all other dates with four-digit years. When yearopt =3, startwin and 
       endwin are absolute dates in $HOROLOG format.

4      Represent all dates with four-digit years.

       Represent with two-digit years all dates falling within the sliding
5      window defined by startwin and (optionally) endwin. Represent all other
       dates with four-digit years. When yearopt=5, startwin and endwin are
       relative years.

6      Represent all dates in the current century with two-digit years and all
       other dates with four-digit years.

startwin
A numeric value that specifies the start of the sliding window during which
dates must be represented with two-digit years. You must supply startwin when
you use a yearopt of 3 or 5. startwin is not valid with any other yearopt
values.
When yearopt = 3, startwin is an absolute date in $HOROLOG date format that
indicates the start date of the sliding window.
When yearopt = 5, startwin is a numeric value that indicates the start year of
the sliding window expressed in the number of years before the current year.
The sliding window always begins on the first day of the year (January 1)
specified in startwin.
endwin
A numeric value that specifies the end of the sliding window during which dates
are represented with two-digit years. You may optionally supply endwin when 
yearopt is 3 or 5. endwin is not valid with any other yearopt values.
When yearopt =3, endwin is an absolute date in $HOROLOG date format that
indicates the end date of the sliding window.
When yearopt =5, endwin is a numeric value that indicates the end year of the
sliding window expressed as the number of years past the current year. The
sliding window always ends on December 31st of the year specified in endwin. If
endwin is not specified, it defaults to December 31st of the year 100 years
after startwin.
If endwin is omitted (or specified as -1) the effective sliding window will be
100 years long. The endwin value of -1 is a special case that always returns a
date value, even when higher and lower endwin values return erropt. For this
reason, it is preferable to omit endwin when specifying a 100-year window, and
to avoid the use of negative endwin values.
If you supply both startwin and endwin , the sliding window they specify must
not have a duration of more than 100 years.
mindate
A numeric value that specifies the lower limit of the range of valid dates.
Specifying a datetime date smaller than mindate generates a <VALUE OUT OF
RANGE> error message.
You specify mindate in $HOROLOG format. For example, 1/1/2007 is represented as
60631. You can include or omit the time portion of the $HOROLOG date (for
example  60631,43200 ), but only the date portion of mindate is parsed. mindate
must be smaller than maxdate.
If mindate is omitted or specified as -1, this limit is obtained from the
DateMinimum property of the current locale, which defaults to zero
(corresponding to December 31, 1840).
maxdate
A numeric value that specifies the upper limit of the range of valid dates.
Specifying a datetime date larger than maxdate generates a <VALUE OUT OF RANGE>
error message.
You specify maxdate in $HOROLOG format. For example, 1/1/2100 is represented as
94599. You can include or omit the time portion of the $HOROLOG date (for
example  94599,43200 ), but only the date portion of maxdate is parsed. maxdate
must be larger than mindate.
If maxdate is omitted or if specified as -1, this limit is obtained from the
DateMaximum property of the current locale, which defaults to the maximum
permissible value for the date portion of $HOROLOG: 2980013 (corresponding to
December 31, 9999).
erropt
This parameter suppresses error messages associated with invalid or out of
range datetime values. Instead of generating <ILLEGAL VALUE> or <VALUE OUT OF
RANGE> error messages, the $ZDATETIMEH function returns erropt.
Notes
$ZDATETIMEH and Fractional Seconds
Unlike $ZDATETIME, $ZDATETIMEH does not allow you to specify a precision for
the time. Any fractional seconds in the original $ZDATETIME-formatted time are
retained in the value $ZDATETIMEH returns.
Note that $HOROLOG does not return fractional seconds.
Invalid Values with $ZDATETIMEH
You receive a <FUNCTION> error in the following conditions:

  • If you specify an invalid dformat code (an integer value less than -1 or
    greater than 9, a zero, or a non-integer value.)
  • If you specify an invalid value for tformat (an integer value less than -1
    or greater than 8, a zero, or a non-integer value.)
  • If you do not specify a startwin value when yearopt is 3 or 5.

You receive an <ILLEGAL VALUE> error under the following conditions:

  • If you specify an invalid value for any date/time unit. If specified, the 
    erropt value is returned rather than issuing an <ILLEGAL VALUE>.
  • If you specify excess leading zeros for any date/time unit in an ODBC date.
    For example, you can represent the February 3, 2007 as  2007 2 3 or  2007 
    02 03 , but will receive an <ILLEGAL VALUE> for  2007 002 03 . If
    specified, the erropt value is returned rather than issuing an <ILLEGAL
    VALUE>.
  • If the given month number is greater than the number of month values in 
    monthlist.
  • If maxdate is less than mindate.
  • If endwin is less than startwin.
  • If startwin and endwin specify a sliding temporal window whose duration is
    greater than 100 years.

You receive a <VALUE OUT OF RANGE> error under the following conditions:

  • If you specify a date (or an offset to  T ) which is earlier than Dec. 31,
    1840 or later than Dec. 31, 9999, and do not supply an erropt value.
  • If you specify an otherwise valid date (or an offset to  T ) which is
    outside the range of mindate and maxdate and do not supply an erropt value.

Error Handling with erropt
When supplied, the erropt parameter only suppresses error messages generated
due to invalid or out of range values of datetime. Errors generated due to
invalid or out of range values of other parameters will always generate error
messages whether or not erropt has been supplied.
For example, an <ILLEGAL VALUE> error is always generated when $ZDATETIMEH
specifies a sliding window where endwin is earlier than startwin. Similarly, an
<ILLEGAL VALUE> error is generated when maxdate is less than mindate.
Date Delimiter
$ZDATETIMEH uses the value of the DateSeparator property of the current locale
as the delimiter between months, days, and the year when dformat=1 or 4. The
delimiter in the ODBC date format (dformat=3) is always a  - , as required by
the ODBC standard. The default value of DateSeparator is  / and all Caché
documentation examples use this delimiter.
To determine the default date separator for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DateSeparator")
The Current Date
The following examples shows how you can use the  T or  t letter code to
specify the current date. Note that dformat must be 5 or greater.
The current date with the time defaulting to 0:

   WRITE $ZDATETIMEH("T",5)
Three days before the current date, with the time defaulting to 0:

   WRITE $ZDATETIMEH("T-3",5)
Two days after the current date, with a specified time:

   WRITE $ZDATETIMEH("T+2 11:45:00",5)
Time Delimiter
By default, Caché uses the value of the TimeSeparator property of the current
locale to determine the delimiter character for the time string. By default,
the delimiter is  : and this delimiter has been used in all of our examples.
The delimiter in the ODBC date format (dformat=3) will always be a  : as
required by the ODBC standard.
To determine the default time separator for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeSeparator")
Time Suffixes
By default, Caché uses properties in the current locale to determine the names
of its time suffixes. For $ZDATETIMEH, these properties (and their
corresponding default values) are:

  • AM ( AM )
  • PM ( PM )
  • Midnight ( MIDNIGHT )
  • Noon ( NOON )

This documentation will always use these default values for these properties.
To determine the default time suffixes for your locale, invoke the following
NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("AM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("PM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("Midnight"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("Noon")
$ZDATETIMEH Compared to $ZDATEH
$ZDATETIMEH is similar to $ZDATEH except it converts both a date and a time
value to the internal $HOROLOG format (even if no time value is specified.) 
$ZDATEH only converts a date value to $HOROLOG format. For example:

   WRITE $ZDATEH("Nov 25, 2002",5)
returns 59133.

   WRITE $ZDATETIMEH("Nov 25, 2002 10:08:09.539",5)
returns 59133,36489.539.
Specifying $ZDATETIMEH with no time value:

   WRITE $ZDATETIMEH("Nov 25, 2002",5)
returns 59133,0.
Specifying $ZDATETIMEH with no time value, and a tformat of 7 or 8:

   WRITE $ZDATETIMEH("Nov 25, 2002",5,7)
returns a value such as: 59133,68400, where the time value is the local time
zone offset from midnight. In this case, U.S. Eastern Standard Time is 5 hours
offset from Greenwich Mean Time, so the time value here represents 19:00 (5
hours offset from midnight).
See Also

  • JOB command
  • $ZDATE function
  • $ZDATEH function
  • $ZDATETIME function
  • $ZTIME function
  • $ZTIMEH function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable
  • %DATE utility, which is documented in the  Legacy Documentation chapter in 
    Using InterSystems Documentation
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ZDATETIME*  #{{{

Validates date and time and converts to display format.
Synopsis

$ZDATETIME(hdatetime,dformat,tformat,precision,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)
$ZDT(hdatetime,dformat,tformat,precision,monthlist,yearopt,startwin,endwin,mindate,maxdate,erropt)

Parameters

hdatetime  The date and time value, specified in internal date and time format.

dformat    Optional  The format for the returned date value.

tformat    Optional  The format for the returned time value.

precision  Optional  The number of decimal places of precision (fractional
           seconds) for the returned time value.

           Optional  A string containing a list of month names (or month name
monthlist  abbreviations). This string must begin with a delimiter character,
           and its 12 entries must be separated by this delimiter character.

yearopt    Optional  A numeric code that specifies the time window in which to
           display the year as a two-digit value.

startwin   Optional  The start of the sliding window during which dates are
           represented with two-digit years.

endwin     Optional  The end of the sliding window during which dates are
           represented with two-digit years.

           Optional  A numeric value that specifies the lower limit of the
mindate    range of valid dates. If omitted or specified as -1, this limit is
           obtained from the DateMinimum property of the current locale, which
           defaults to zero (corresponding to December 31, 1840).

maxdate    Optional  The upper limit of the range of valid dates.

erropt     Optional  This parameter suppresses error messages associated with
           invalid or out of range hdatetime values.

Description
$ZDATETIME validates a specified date and time and converts them from $HOROLOG
or $ZTIMESTAMP internal format to one of several alternative date and time
display formats. The exact value returned depends on the parameters you
specify.

  • $ZDATETIME(hdatetime) returns the date and time in the default display
    format for the current locale.
  • $ZDATETIME(hdatetime,dformat,tformat,precision,monthlist,yearopt,startwin,
    endwin,mindate,maxdate,erropt) returns the date and time in the display
    format specified by dformat and tformat, further defined by the other
    parameters you specify. The range of valid dates may be restricted by the 
    mindate and maxdate parameters.

Parameters
hdatetime
The date and time, specified as an internal format value. Caché internal format
represents dates as a count of days from an arbitrary starting point (Dec. 31,
1840), and represents times as a count of seconds in the current day. The 
hdatetime value must be a string in one of the following formats:

  • $HOROLOG: two unsigned integers separated by comma. The first is an integer
    specifying the date (in days), the second is an integer specifying the time
    (in seconds).
  • $ZTIMESTAMP: two unsigned numbers separated by comma: the first is an
    integer specifying the date (in days), the second is a number specifying
    the time (in seconds and fractions of a second). The time value can have up
    to nine digits of precision (fractional seconds) to the right of the
    decimal point.

You can specify hdatetime as a string value, a variable, or an expression.
dformat
Format for the returned date. Valid values are:

Value                                  Meaning

       Get effective dformat value from fmt.DateFormat, where fmt is an
-1     instance of ##class(%SYS.NLS.Format) associated with the current
       process. This is the default behavior if you do not specify dformat. See
        Customizable Date and Time Defaults for further details.

1      MM/DD/[YY]YY (01/01/97)  The default format

2      DD Mmm [YY]YY (01 Jul 97)

3      YYYY-MM-DD (1997-07-01)  ODBC format

4      DD/MM/[YY]YY (01/07/97)  European format

5      Mmm D, YYYY (Jul 1, 1997)

6      Mmm D YYYY (Jul 1 1997)

7      Mmm DD [YY]YY (Jul 01 1997)

8      YYYYMMDD (19970701)  Numeric format

9      Mmmmm D, YYYY (July 1, 1997)

10     W (2)  Day number for the week

11     Www (Tue)  Abbreviated day name

12     Wwwwww (Tuesday)  Full day name

       [D]D/[M]M/YYYY (1/7/2549 or 27/11/2549)  Thai date format. Day and month
13     are identical to European usage, except no leading zeros. The year is
       the Buddhist Era year, calculated by adding 543 years to the Gregorian
       year.

14     nnn (354)  Day number for the year

Where:

Syntax                                  Meaning

        YYYY is a four-digit year. [YY]YY is a two-digit year if hdatetime
YYYY    falls within the active window for two-digit years; otherwise it is a
        four-digit year.

MM      Two-digit month.

D       One-digit day if the day number <10. Otherwise, two digits.

DD      Two-digit day.

        Month abbreviation extracted from the MonthAbbr property in the current
        locale. An alternate month abbreviation (or name of any length) can be
Mmm     extracted from an optional list specified as the monthlist parameter to
        $ZDATETIME. The MonthAbbr default values are:  Jan Feb Mar Apr May Jun
        Jul Aug Sep Oct Nov Dec 

Mmmmm   Full name of the month as specified by the MonthName property. The
        default values are:  January February March ... November December 

W       Number 0-6 indicating the day of the week: Sunday=0, Monday=1, Tuesday=
        2, etc.

        Weekday name abbreviation as specified by the WeekdayAbbr property of
Www     the current locale. The default values are:  Sun Mon Tue Wed Thu Fri
        Sat 

        Weekday full name as specified by the WeekdayName property in the
Wwwwww  current locale. The default values are:  Sunday Monday Tuesday
        Wednesday Thursday Friday Saturday 

nnn     Day number for the specified year, always three digits, with leading
        zeros if necessary. Values are 001 through 365 (or 366 on leap years).

To determine the default date format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DateFormat")
To determine the default weekday names and weekday abbreviations for your
locale, invoke the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("WeekdayName"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("WeekdayAbbr"),!
tformat
A numeric value that specifies the format in which you want to express the time
value. Supported values are:

Value                                  Meaning

       Get the effective tformat value from the TimeFormat property of the
-1     current locale, which defaults to a value of 1. This is the default
       behavior if you do not specify tformat.

1      Express time in the form "hh:mm:ss" (24-hour clock)

2      Express time in the form  hh:mm (24-hour clock)

3      Express time in the form  hh:mm:ss[AM/PM] (12-hour clock)

4      Express time in the form  hh:mm[AM/PM] (12-hour clock)

       Express time in the form "hh:mm:ss+/-hh:mm" (24-hour clock). The time is
       expressed as local time. The plus (+) or minus ( ) suffix shows the
       offset of local time from Coordinated Universal Time (UTC), also known
5      as Greenwich Mean Time (GMT). A minus sign (-hh:mm) indicates that the
       local time is earlier (westward) from Greenwich by the returned offset
       number of hours and minutes. A plus sign (+hh:mm) indicates that the
       local time is later (eastward) from Greenwich by the returned offset
       number of hours and minutes.

       Express time in the form  hh:mm+/-hh:mm (24-hour clock). The time is
       expressed as local time. The plus (+) or minus ( ) suffix shows the
       offset of local time from Coordinated Universal Time (UTC), also known
6      as Greenwich Mean Time (GMT). A minus sign (-hh:mm) indicates that the
       local time is earlier (westward) from Greenwich by the returned offset
       number of hours and minutes. A plus sign (+hh:mm) indicates that the
       local time is later (eastward) from Greenwich by the returned offset
       number of hours and minutes.

       Express time in the form "hh:mm:ssZ" (24-hour clock). The  Z suffix
7      indicates that the time is expressed as Coordinated Universal Time
       (UTC), also known as Greenwich Mean Time (GMT), rather than as local
       time.

       Express time in the form  hh:mmZ (24-hour clock). The  Z suffix
8      indicates that the time is expressed as Coordinated Universal Time
       (UTC), also known as Greenwich Mean Time (GMT), rather than as local
       time.

       For MultiValue support. Same as tformat 1 ("hh:mm:ss" 24-hour clock) for
9      numeric values in the range 0 through 86399. Also accepts negative time
       values and time values greater than 86399, as described below.

       For MultiValue support. Same as tformat 2 ("hh:mm" 24-hour clock) for
10     numeric values in the range 0 through 86399. Also accepts negative time
       values and time values greater than 86399, as described below.

For tformat values 1 through 4 (which return local time), the date is separated
from the time by a space. For tformat values 5 through 8 (which return UTC time
information), the date is separated from the time by the letter  T .
When tformat is set to 5 or 6, the hdatetime input value is assumed to be local
time, and is displayed as local time. The offset from UTC is taken from the
local timezone setting.
When tformat is set to 7 or 8, the hdatetime input value is assumed to be local
date and time. The time is changed to correspond to UTC time (calculated using
the local timezone setting). The date returned may also be changed (if
necessary) to correspond to this UTC time value. Thus the returned date may
differ from the local date.
To determine the default time format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeFormat")
Note:
$ZDATETIME has no way to determine if an hdatetime input value is in UTC time
or local time. Therefore, do not use tformat values 5, 6, 7, or 8 with an 
hdatetime that is already in UTC, such as a $ZTIMESTAMP value. If you use the
output from a tformat 7 or 8 conversion in an operation that converts the time
back to local time be aware that the date may have been changed in the
local-to-UTC conversion.
In 12-hour clock formats, morning and evening are represented by time suffixes,
here shown as AM and PM. To determine the default time suffixes for your
locale, invoke the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("AM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("PM"),!
tformat 9 and 10
Time formats 9 and 10 are provided for MultiValue support. They are identical
to tformats 1 and 2 for all time values within the allowed range for Caché
ObjectScript: 0 through 86399. Within this range they handle fractional seconds
in the same manner as other time formats. Like other time formats, -0 is
treated as 0.
Time formats 9 and 10 accept negative numeric values and returns a
corresponding negative time value. tformat 9 returns a negative time value as
"-hh:mm:ss" (24-hour clock). tformat 10 returns a negative time value as
"-hh:mm" (24-hour clock). For time format 10,   59.9 returns   00:00 and   60 
returns   00:01 . Negative fractional seconds are always truncated. Therefore,
 4.9 returns   00:00:04 ;   0 and   0.9 both return the positive value  
00:00:00 .
Time formats 9 and 10 accept numeric values greater than 86399, and return the
corresponding time. Thus 86400 returns  24:00:00 , and 400000 returns  
111:06:40 . Fractional seconds are returned for values in the range 0 through
86399. Fractional seconds are truncated for values of 86400 and greater.
If precision is specified, and a time value outside the Caché range is
specified, any specified fractional seconds are truncated and the fractional
precision portion is returns as zeros.
precision
A numeric value that specifies the number of decimal places of precision in
which you want to express the time. That is, if you enter a value of 3 as 
precision, $ZDATETIME displays the seconds carried out to three decimal places.
If you enter a value of 9 as precision, $ZDATETIME displays the seconds carried
out to nine decimal places.
Supported values are as follows:
-1: Get the precision value from the TimePrecision property of the current
locale, which defaults to a value of 0. This is the default behavior if you do
not specify precision.
A value of n that is greater than or equal to zero (0) results in the
expression of time to n decimal places.
Precision is only applicable if the hdatetime format can include a fractional
time value ($ZTIMESTAMP format), and if the tformat option selected includes
seconds. Trailing zeros are not suppressed. If the precision specified exceeds
the precision available on your system, the excess digits of precision are
returned as trailing zeros.
To determine the default time precision for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimePrecision")
monthlist
A string, or the name of a variable that contains a string of month names. The
names in monthlist replace the default month name values and month abbreviation
values, overriding the MonthName and MonthAbbr properties of the current
locale. The most common use of monthlist is to specify full month names or
month name abbreviations in languages other than the default language for your
locale.
monthlist is valid only if dformat is 2, 5, 6, 7, 9. If dformat is 1, 3, 4, 8,
10,11, or 12 $ZDATETIME ignores monthlist.
The monthlist string has the following format:

  • The first character of the string is a delimiter character (usually a
    space). The same delimiter must appear between each month name in monthlist
    . This delimiter appears between the month, day, and year portions of the
    returned display date value, which is why a space is usually the preferred
    character.
  • The month names list should contain twelve entries, corresponding to
    January through December. It is possible to specify more or less than
    twelve month names, but if there is no month name corresponding to the
    month in hdatetime an <ILLEGAL VALUE> error is generated.

If you omit monthlist or specify a monthlist value of -1, and dformat is 2, 5,
6, or 7, $ZDATETIME uses the list of month name abbreviations defined in the 
MonthAbbr property of the current locale, which by default is:  Jan Feb Mar Apr
May Jun Jul Aug Sep Oct Nov Dec . Note the space delimiter at the beginning of
the string.
If you omit monthlist or specify a monthlist value of -1, and dformat is 9, 
$ZDATETIME uses the list of month names defined in the MonthName property of
the current locale, which by default is:  January February March April May June
July August September October November December . Note the space delimiter at
the beginning of the string.
To determine the default month names and month abbreviations for your locale,
invoke the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthName"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("MonthAbbr"),!
yearopt
With dformat values 0, 1, 2, 4, or 7, a numeric code that specifies the time
window in which to display the year as a two-digit value. yearopt can be:

Value                                  Meaning

       Get effective yearopt value from YearOption property of current locale
-1     which defaults to a value of 0. This is the default behavior if you do
       not specify yearopt.

       Represent 20th century dates (1900 through 1999) with two-digit years,
       unless a process-specific sliding window (established via the %DATE
0      utility) is in effect. If such a window is in effect, represent only
       those dates falling within the sliding window by two-digit years.
       Represent all dates falling outside the 20th century or outside the
       process-specific sliding window by four-digit years.

1      Represent 20th century dates with two-digit years and all other dates
       with four-digit years.

2      Represent all dates with two-digit years.

       Represent with two-digit years those dates falling within the sliding
3      temporal window defined by startwin and (optionally) endwin. Represent
       all other dates with four-digit years. When yearopt=3, startwin and 
       endwin are absolute dates in $HOROLOG format.

4      Represent all dates with four-digit years.

       Represent with two-digit years all dates falling within the sliding
5      window defined by startwin and (optionally) endwin. Represent all other
       dates with four-digit years. When yearopt=5, startwin and endwin are
       relative years.

6      Represent all dates in the current century with two-digit years and all
       other dates with four-digit years.

To determine the default year option for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("YearOption")
startwin
A numeric value that specifies the start of the sliding window during which
dates must be represented with two-digit years. You must supply startwin when
you use a yearopt of 3 or 5. startwin is not valid with any other yearopt
values.
When yearopt=3, startwin is an absolute date in $HOROLOG date format that
indicates the start date of the sliding window.
When yearopt=5, startwin is a numeric value that indicates the start year of
the sliding window expressed in the number of years before the current year.
endwin
A numeric value that specifies the end of the sliding window during which dates
are represented with two-digit years. You may optionally supply endwin when 
yearopt is 3 or 5. endwin is not valid with any other yearopt values.
When yearopt=3, endwin is an absolute date in $HOROLOG date format that
indicates the end date of the sliding window.
When yearopt=5, endwin is a numeric value that indicates the end year of the
sliding window expressed as the number of years past the current year.
When yearopt=5, the sliding window always begins on January 1st of the year
specified in startwin and ends on December 31st of the year specified in endwin
, or of the implied end year (if you omit endwin).
If endwin is omitted (or specified as -1) the effective sliding window will be
100 years long. The endwin value of -1 is a special case that always returns a
date value, even when higher and lower endwin values return erropt. For this
reason, it is preferable to omit endwin when specifying a 100-year window, and
to avoid the use of negative endwin values.
If you supply both startwin and endwin , the sliding window they specify must
not have a duration of more than 100 years.
mindate
A numeric value that specifies the lower limit of the range of valid dates. If
omitted or specified as -1, this limit is obtained from the DateMinimum
property of the current locale, which defaults to zero (corresponding to
December 31, 1840).
maxdate
A numeric value that specifies the upper limit of the range of valid dates. If
omitted or if specified as -1, this limit is obtained from the DateMaximum
property of the current locale, which defaults to the maximum permissible value
for the date portion of $HOROLOG: 2980013 (corresponding to December 31, 9999).
Attempting to exceed maxdate generates a <VALUE OUT OF RANGE> error message.
erropt
This parameter suppresses error messages associated with invalid or out of
range hdatetime values. Instead of generating <ILLEGAL VALUE> or <VALUE OUT OF
RANGE> error messages, the function returns erropt.
Examples
The following example displays the current local date and time. It takes the
default date and time format for the locale:

  WRITE $ZDATETIME($HOROLOG)
The following example displays the current date and time. $ZTIMESTAMP contains
the current date and time value as Coordinated Universal Time (UTC) date and
time. The dformat parameter specifies ODBC date format, the tformat parameter
specifies a 24-hour clock, and the precision parameter specifies 6 digits of
fractional second precision:

  WRITE $ZDATETIME($ZTIMESTAMP,3,1,6)
This returns the current time stamp date and time, formatted like: 
2005-11-25 18:45:16.960000.
The following example shows how a local time can be converted to UTC time, and
how the date may also change as a result of this conversion. In most time
zones, the time conversion in one of the following $ZDATETIME operations also
changes the date:

  SET local = $ZDATETIME("60219,82824",3,1)
  SET utcwest = $ZDATETIME("60219,82824",3,7)
  SET utceast = $ZDATETIME("60219,00024",3,7)
  WRITE !,local,!,utcwest,!,utceast
Notes
Invalid Values with $ZDATETIME
You receive a <FUNCTION> error in the following conditions:

  • If you specify an invalid dformat code (an integer value less than -1 or
    greater than 12, a zero, or a noninteger value)
  • If you specify a invalid value for tformat (an integer value less than -1
    or greater than 8, a zero, or a noninteger value)
  • If you do not specify a startwin value when yearopt is 3 or 5

You receive a <ILLEGAL VALUE> error under the following conditions:

  • If you specify an invalid value for a date or time and do not supply an 
    erropt value
  • If the given month number is greater than the number of month values in 
    monthlist
  • If maxdate is less than mindate
  • If endwin is less than startwin
  • If startwin and endwin specify a sliding temporal window whose duration is
    greater than 100 years

You receive a <VALUE OUT OF RANGE> error under the following conditions:

  • If you specify an otherwise valid date which is outside the range defined
    by the values assumed for maxdate and mindate and do not supply an erropt
    value

Error Handling with erropt
When supplied, the erropt parameter only suppresses error messages generated
due to invalid or out of range values of hdatetime. Errors generated due to
invalid or out of range values of other parameters will always generate error
messages whether or not erropt has been supplied.
For example, an <ILLEGAL VALUE> error is always generated when $ZDATETIME
specifies a sliding window where endwin is earlier than startwin. Similarly, an
<ILLEGAL VALUE> error is generated when maxdate is less than mindate.
Date Delimiter
$ZDATETIME will use the value of the DateSeparator property of the current
locale as the delimiter between months, days, and the year when dformat=1 or 4.
The delimiter in the ODBC date format (dformat=3) will always be a  - as
required by the ODBC standard. The default value of DateSeparator is  / and all
documentation uses this delimiter.
To determine the default date separator for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DateSeparator")
Decimal Delimiter
$ZDATETIME will use the value of the DecimalSeparator property of the current
locale as the delimiter between the whole and fractional parts of numbers. The
delimiter in the ODBC date format (dformat=3) will always be a  . as required
by the ODBC standard. The default value of DecimalSeparator is  . and all
documentation uses this delimiter.
To determine the default decimal separator for your locale, invoke the
following NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
Time Delimiter
By default, Caché uses the value of the TimeSeparator property of the current
locale to determine the delimiter character for the time string. By default,
the delimiter is  : and this delimiter has been used in all of our examples.
To determine the default time separator for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeSeparator")
Time Suffixes
By default, Caché uses properties in the current locale to determine the names
of its time suffixes. For $ZDATETIME, these properties (and their corresponding
default values) are:

  • AM ( AM )
  • PM ( PM )

This documentation will always use these default values for these properties.
To determine the default time suffixes for your locale, invoke the following
NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("AM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("PM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("Midnight"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("Noon")
Customizable Date and Time Defaults
Upon Caché startup, the default date and time formats are initialized to the
American date and time formats (for example, MM/DD/[YY]YY). To set this and
other default formats to the values for your current locale, set the following
global variable: SET ^SYS("NLS","Config","LocaleFormat")=1. This sets all
format defaults for all processes to your current locale values. These defaults
persist until this global is changed.
In the following example, the first $ZDATETIME returns a date and time in the
default format for the locale. The input parameters are the $ZTIMESTAMP special
variable, with the dformat and tformat taking defaults, and precision set to 2
decimal digits. In most locales, the first $ZDATETIME will return dformat=1 or
the American date and time format with a slash date separator and a dot decimal
separator for fractional seconds.
In the ChangeVals section, the first SetFormatItem method changes the locale
date format default to dformat=4, or the European date format (DD/MM/[YY]YY),
as is shown by the second $ZDATETIME. The second SetFormatItem method changes
the locale default for the date separator character (which affects the dformat
 1, 1, and 4). In this example, the date separator character is set to a dot ( 
. ), as shown by the third $ZDATETIME. The third SetFormatItem method changes
the decimal separator character for this locale to the European standard ( , ),
as shown by the final $ZDATETIME. This program then restores the initial date
format values:

InitalizeLocaleFormat
   SET ^SYS("NLS","Config","LocaleFormat")=1
InitialVals
   SET fmt=##class(%SYS.NLS.Format).GetFormatItem("DateFormat")
   SET sep=##class(%SYS.NLS.Format).GetFormatItem("DateSeparator")
   SET dml=##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
   WRITE !,$ZDATETIME($ZTIMESTAMP,,,2)
ChangeVals
  SET x=##class(%SYS.NLS.Format).SetFormatItem("DateFormat",4)
  WRITE !,$ZDATETIME($ZTIMESTAMP,,,2)
  SET y=##class(%SYS.NLS.Format).SetFormatItem("DateSeparator",".")
  WRITE !,$ZDATETIME($ZTIMESTAMP,,,2)
  SET z=##class(%SYS.NLS.Format).SetFormatItem("DecimalSeparator",",")
  WRITE !,$ZDATETIME($ZTIMESTAMP,,,2)
RestoreVals
   SET x=##class(%SYS.NLS.Format).SetFormatItem("DateFormat",fmt)
   SET y=##class(%SYS.NLS.Format).SetFormatItem("DateSeparator",sep)
   SET z=##class(%SYS.NLS.Format).SetFormatItem("DecimalSeparator",dml)
   WRITE !,$ZDATETIME($ZTIMESTAMP,,,2)
$ZDATETIME Compared to $ZDATE
$ZDATETIME is similar to $ZDATE except it converts a combined date and time
value. $ZDATE only converts a date value. For example:

  WRITE $ZDATE($HOROLOG)
returns the current date, formatted like: 11/25/2002.

  WRITE $ZDATETIME($HOROLOG)
returns the current date and time, formatted like: 11/25/2002 13:53:57.
$ZDATE does not support tformat values 5 through 8.
See Also

  • JOB command
  • $ZDATE function
  • $ZDATEH function
  • $ZDATETIMEH function
  • $ZTIME function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable
  • %DATE utility, which is documented in the  Legacy Documentation chapter in 
    Using InterSystems Documentation
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ZDCHAR*  #{{{

Converts a $DOUBLE floating point number to an eight-byte string.
Synopsis

$ZDCHAR(n)
$ZDC(n)

Parameter

n  An IEEE-format floating point number. It can be specified as a value, a
   variable, or an expression.

Description
$ZDCHAR returns an eight-byte (quad) character string corresponding to n. The
bytes of the character string are presented in little-endian byte order, with
the least significant byte first.
The number n can be a positive or negative IEEE floating point number. If n is
not numeric, $ZDCHAR returns the empty string. For further details on IEEE
floating point numbers, refer to the $DOUBLE function.
Example
The following examples return an eight-byte string corresponding to the IEEE
floating point number:

   WRITE $ZDCHAR($DOUBLE(1.4)),!
   WRITE $ZDCHAR($DOUBLE(1.400000000000001))

These two functions return: "ffffffö?" and "kfffffö?"
Notes
$ZDCHAR and Other $CHAR Functions
$ZDCHAR converts an IEEE floating point number to a eight byte (64-bit)
character string. $ZQCHAR converts an integer to an eight byte (64-bit)
character string. To convert an integer to an 8-bit character string use $CHAR.
To convert an integer to a 16-bit (wide) character string use $ZWCHAR. To
convert an integer to a 32-bit (long) character string use $ZLCHAR.
See Also

  • $DOUBLE function
  • $ZDASCII function
  • $CHAR function
  • $ZWCHAR function
  • $ZLCHAR function
  • $ZQCHAR function


 #}}}
*$ZEXP*  #{{{

Returns the natural logarithm raised to the specified power.
Synopsis

$ZEXP(n)

Parameters

n  A number of any type. A number larger than 335.6 results in a <MAXNUMBER>
   error. A number smaller than -295.4 returns 0.

Description
$ZEXP returns a value that is the natural logarithm (base e) raised to the
power n.
The corresponding natural logarithm function is $ZLN.
Parameters
n
Any number. It can be specified as a value, a variable, or an expression. A
positive value larger than 335.6 or smaller than -4944763837 results in a
<MAXNUMBER> error. A negative value smaller than -295.4 returns 0.
Examples
The following example writes the natural log raised to the power of negative
and positive integers:

   FOR x=-3:1:3 {
     WRITE !,"The natural log raised to ",x," = ",$ZEXP(x)
     }
   QUIT
returns:

The natural log raised to -3 = .04978706836786394297
The natural log raised to -2 = .1353352832366126919
The natural log raised to -1 = .3678794411714423216
The natural log raised to 0 = 1
The natural log raised to 1 = 2.718281828459045236
The natural log raised to 2 = 7.389056098930650228
The natural log raised to 3 = 20.08553692318766774

The following example writes the natural logs raised to the first nine
multiples of pi:

   SET y=1
   FOR x=$ZPI:$ZPI:10*$ZPI {
     WRITE !,"The natural log raised to ",y,"pi = ",$ZEXP(x)
     SET y=y+1 }
   QUIT

   WRITE $ZEXP(1e3)

   WRITE $ZEXP("")
returns 1.

   WRITE $ZEXP()

generates a <SYNTAX> error.
See Also

  • $ZLN function
  • $ZLOG function
  • $ZPI special variable


 #}}}
*$ZF*  #{{{

Invokes non-Caché ObjectScript programs or functions from Caché ObjectScript
routines.
Synopsis

$ZF("function_name",args)

Parameters

function_name  The name of the function you want to call.

args           Optional  A set of argument values passed to the function.

Description
The various forms of the $ZF function allow you to invoke non-Caché
ObjectScript programs (such as shell or operating system commands) or functions
from Caché ObjectScript routines. You can define interfaces or links to
functions written in other languages into Caché and call them from Caché
ObjectScript routines using $ZF.
$ZF can also be used to:

  • Spawn a child process to execute a program or command: $ZF( 1) and $ZF( 2).
  • Load a Dynamic Link Library (DLL) then execute functions from that library:
    $ZF( 3), $ZF( 4), $ZF( 5), and $ZF( 6).

These implementations of $ZF take a negative number as the first parameter.
They are described in their own reference pages.
Parameters
function_name
The name of the function you want to call enclosed in quotation marks, or a
negative number.
args
The args parameters are in the form: arg1, arg2, arg3, ...argn. The arguments
can consist of such items as descriptions of how arguments are passed and the
entry point to the C function you are calling.
Notes
Calling UNIX System Services with $ZF
Caché supports error checking functions for use with UNIX system calls from $ZF
. These calls allow you to check for asynchronous events and to set an alarm
handler in $ZF. By using these UNIX functions you can distinguish between real
errors, <CTRL-C> interrupts, and calls that should be restarted.
The function declarations are included in cdzf.h and are described in the
following table:

Declaration    Purpose                            Notes

int          Clears retry  Should be called once before using sigrtchk()
sigrtclr();  flag.

             Establishes   On entry to $ZF, the previous handler is
int          new SIGALRM   automatically saved. On exit, it is restored
dzfalarm();  handler.      automatically. A user program should not alter the
                           handling of any other signal.

                           Should be called whenever one of the following
                           system calls fails: open(), close(), read(), write
                           (), ioctl(), pause(), any call that fails when the
                           process receives a signal. It returns a code
int          Checks for    indicating the action the user should take:
sigrtchk();  asynchronous  -1 = Not a signal. Check for I/O error. See contents
             events.       of errno variable.
                           0 = Other signal. Restart operation from point at
                           which it was interrupted.
                           1 = SIGINT/. Exit from $ZF with a SIGTERM "return
                           0." The System traps these signals appropriately.

In a typical $ZF function used to control some device, you would code something
like this:

  IF ((fd = open(DEV_NAME, DEV_MODE)) < 0) {
     ; Set some flags
     ; Call zferror
     ; return 0;
  }

The open system call can fail if the process receives a signal. Usually this
situation is not an error and the operation should be restarted. Depending on
the signal, however, you might take other actions. So, to take account of all
the possibilities, consider using the following C code:

sigrtclr();
   WHILE (TRUE) {
      IF (sigrtchk() == 1) { return 1 or 0; }
      IF ((fd = open(DEV_NAME, DEV_MODE)) < 0) {
         switch (sigrtchk()) {
         case -1:
           /* This is probably a real device error */
           ; Set some flags
           Call zferror
           return 0;
         case 0:
           /* A innocuous signal was received. Restart. */
           ; continue;
         case 1:
           /* Someone is trying to terminate your job. */
           Do cleanup work
           return 1 or 0;
         }
      }
      ELSE { break; }
   /* Code to handle the normal situation: */
   /* open() system call succeeded         */

Remember you must not set any signal handler except through dzfalarm().
Calling OpenVMS System Services with $ZF
You can also call OpenVMS system services with $ZF. You define an interface to
each non-Caché ObjectScript routine in a file named CZF.M64. You can also use 
$ZF to call OpenVMS System Service Routines, invoke DCL Command Procedures, or
other high-level language routines.
$ZF adheres to the OpenVMS Procedure Calling and Condition Handling Standard.
While all OpenVMS compilers are supposed to adhere to this convention, some
compilers may not.
You can use $ZF to call DSM intrinsic functions which emulate DSM $ZCalls for
OpenVMS System Services. For example, you can call $ZF( GETSYI ) to get system
information for a DSM cluster node member.
The available DSM intrinsic functions are: GETJPI (job and process
information); GETDVI (device characteristics); GETSYI (system information);
SETSYM (sets DCL symbol value); GETSYM (returns DCL symbol value); DELSYM
(deletes DCL symbol value); CRELOG (creates logical name); TRNLNM (translates
logical name); DELLOG (deletes logical name); GETUAI (returns account
authorization parameters); GETMSG (returns status code message text); SETPRN
(sets name of the calling process); SETPRI (sets base priority for a process);
OPCOM (sends message to the operator); MOUNT (mounts a device); DISMOUNT
(dismounts a device); DIRECTORY (returns the default directory); PARSE (parses
a filename); GETFILE (returns file information). For specific function calls
for DSM compatibility and conversion, refer to the Using the $ZF Function Calls
for DSM article.
Translating Strings between Encoding Systems
Caché supports input-output translation via a $ZF argument type, t (or T),
which can be specified in the following formats:

Argument                           Purpose

t         Specifies the current process I/O translation object.

t//       Specifies the default process I/O translation table name.

t/name/   Specifies a particular I/O translation table name.

$ZF conveys the translated string to the external procedure via a counted-byte
string placed in the following C structure:

typedef struct zarray {
  unsigned short len;
  unsigned char data[1]; /* 1 is a dummy value */
  } *ZARRAYP;

This is also the structure used for the b (or B) argument type.
The following $ZF sample function performs a round trip conversion:

#include cdzf.h
extern    int trantest();
ZFBEGIN
ZFENTRY("TRANTEST","t/SJIS/ T/SJIS/",trantest)

ZFEND

int trantest(inbuf,outbuf);

ZARRAYP inbuf;         /* Buffer containing string that was converted from
        internal Caché encoding to SJIS encoding before it
        was passed to this function */
ZARRAYP outbuf;        /* Buffer containing string in SJIS encoding that will
        be converted back to internal Caché encoding before
        it is passed back into the Caché environment */
{
  int  i;
  /* Copy data one byte at a time from the input argument buffer
     to the output argument buffer */

  for (i = 0; i < inbuf->len; i++)
     outbuf->data[i] = inbuf->data[i];

  /* Set number of bytes of data in the output argument buffer */
       outbuf->len = inbuf->len;

  return 0;  /* Return success */
}

Note:
Conceptually speaking, data flows to and from a $ZF external procedure, as if
the external procedure were a device. The output component of an I/O
translation is used for data that is passed to an external procedure because
the data is  leaving the Caché environment. The input component of an I/O
translation is used for data that is received from an external procedure
because the data is  entering the Caché environment.
If the output component of an I/O translation is undefined and your application
attempts to pass anything but the null string using that I/O translation, Caché
returns an error, because it does not know how to translate the data.
If the input component of an I/O translation is undefined and an argument of
type string associates that I/O translation with a $ZF output argument, Caché
returns an error, because an output argument with an undefined translation is
purposeless.
Zero-Terminated and Counted Unicode Strings
The $ZF function supports argument types for zero-terminated Unicode strings
and counted Unicode strings. These are supported even in versions of Caché that
do not use Unicode characters internally.
The argument types for zero-terminated Unicode strings and counted Unicode
strings have the following codes:

Argument                         Purpose

w         Pointer to a zero-terminated Unicode character string.

s         Pointer to a counted Unicode character string.

For both argument types, the C data type of the Unicode character is an
unsigned short. A pointer to a zero-terminated Unicode string is declared as
follows:

unsigned short *p;

A pointer to a counted Unicode string is declared as a pointer to the following
C structure:

typedef struct zwarray {
  unsigned short len;
  unsigned short data[1]; /* 1 is a dummy value */
  } *ZWARRAYP;

For example:

ZWARRAYP *p;

The len field contains the length of the Unicode character array.
The data field contains the characters in the counted Unicode string. The
maximum size of a Unicode string is the maximum $ZF string size, which is an
updateable configuration parameter that defaults to 32767.
Each Unicode character is two bytes long. This is important to consider when
declaring Unicode strings as output arguments, because Caché reserves space for
the longest string that may be passed back. When using the default string size,
the total memory consumption for a single Unicode string argument is calculated
as follows:
32767 maximum characters * 2 bytes per character = 65534 total bytes.
This is close to the default maximum memory area allocated for all $ZF
arguments, which is 67584. This maximum $ZF heap area is also an updateable
configuration parameter.
Error Messages
When the $ZF heap area is exhausted, $ZF issues an <OUT OF $ZF HEAP SPACE>
error. When the $ZF String Stack is exhausted, $ZF issues a <STRINGSTACK>
error. When $ZF is unable to allocate a buddyblock, it issues a <STORE> error.
Execution from Child Processes and DLLs
The $ZF function can take a negative number as its first parameter. These
negative numbers specify functions that support spawned child processes and
Dynamic-Link Libraries (DLLs). Each of these $ZF functions is described in a
separate reference page.
See Also

  • $ZF(-1) function
  • $ZF(-2) function
  • $ZF(-3) function
  • $ZF(-4) function
  • $ZF(-5) function
  • $ZF(-6) function
  • Calling Out of Caché in Using the Caché Callin and Callout Functions
  • $ZF Function Calls for DSM

$ZF(-1)  #{{{

Executes a program or command as a spawned child process and waits for the
child process to return.
Synopsis

Windows and UNIX:
$ZF(-1,progname)

OpenVMS:
$ZF(-1,progname,outdev,indev)

Parameters

progname  The command or program to be executed as a child process.

outdev    Optional: OpenVMS Only  Output device. Used to specify SYS$OUTPUT for
          the child process. Uses current SYS$OUTPUT if not specified.

indev     Optional: OpenVMS Only  Input device. Used to specify SYS$INPUT for
          the child process. Uses current SYS$INPUT if not specified.

Description
$ZF(-1) permits a Caché ObjectScript process to invoke a command of the host
operating system. It executes the program or command specified in progname as a
spawned child process from the current console. It waits for the process to
return. It returns the child process exit status.
$ZF(-1) returns the exit status code issued by the operating system shell. For
Windows, this is 0 if the function call is successful, 1 if an error occurs. It
returns -1 if a child process could not be forked.
$ZF(-1) with no specified parameter launches the default operating system
shell. For further details, see Issuing Operating System Commands from Caché in
Using the Caché Callin and Callout Functions.
If the pathname supplied in progname contains a space character, pathname
handling is platform-dependent:

  • OpenVMS permits space characters in pathnames; no special processing is
    required.
  • Windows and UNIX permit space characters in pathnames, but the entire
    pathname containing spaces must be enclosed in an additional set of double
    quote (") characters. This is in accordance with the Windows cmd /c
    statement. For further details, specify cmd /? at the Windows command
    prompt.

You can use the $ZUTIL(147) function to handles spaces in pathnames as
appropriate for the host platform.
$ZF(-1) requires the %System_Callout:U privilege.
If $ZF(-1) is unable to spawn a process, it generates a <FUNCTION> error. On
OpenVMS systems this may be caused by the child process trying to use the same
SYS$INPUT as the parent process, and can be handled by specifying an indev
value. The OpenVMS error code may be seen using the SYSLOG utility.
At the programmer prompt, you can perform operations similar to $ZF(-1) by
using an exclamation point (!) or a dollar sign ($) as the first character,
followed by the command you wish to execute as a child process. Note that the !
or $ command line prefix return a value from the invoked process, whereas 
$ZF(-1) returns the exit status code for the invoked process. For further
details, see Issuing Operating System Commands from Caché in 
Using the Caché Callin and Callout Functions.
Examples
The following Windows example executes a user-written program, in this case
displaying the contents of a .txt file. It uses $ZUTIL(147) to handle a
pathname for $ZF(-1). A pathname containing spaces is handled as appropriate
for the host platform. A pathname that does not contain spaces is passed
through unchanged. $ZF(-1) returns the Windows shell exit status of 0 if the
specified file could be accessed, or 1 if the file access failed:

   SET x=$ZF(-1,$ZUTIL(147,"C:\MyTest.txt"))
   WRITE x
The following Windows example invokes the Windows operating system SOL command.
SOL opens a window that displays the Solitaire game provided with the Windows
operating system. Upon closing of the Solitaire interactive window, $ZF(-1)
returns the Windows shell exit status of 0, indicating success:

   SET x=$ZF(-1,"SOL")
   WRITE x
The following Windows example invokes a non-existent Windows operating system
command. $ZF(-1) returns the Windows shell exit status of 1, indicating an
error:

   SET x=$ZF(-1,"SOX")
   WRITE x
See Also

  • $ZF(-2) function
  • $ZUTIL(147) function
  • Calling Out of Caché in Using the Caché Callin and Callout Functions


 #}}}
$ZF(-2)  #{{{

Executes a program or command as a spawned child process and returns
immediately.
Synopsis

$ZF(-2,progname)

Parameters

progname  The command or program to be executed as a child process.

Description
$ZF(-2) executes the program specified in progname as a spawned child process
from the current console. It returns immediately after spawning the child
process and does not wait for the process to terminate. Input and output
devices default to the null device.
$ZF(-2) does not return the child process exit status. Instead, $ZF(-2) returns
zero if the child process was created successfully, or -1 if a child process
could not be forked. $ZF(-2) permits a program invoked from Caché to continue
execution even if Caché is terminated.
$ZF(-2) closes the parent process principal device (specified in $PRINCIPAL)
before executing the command. This is done because the child process executes
concurrently with the parent. If $ZF(-2) did not close $PRINCIPAL, output from
the parent and the child would become intermingled. When using $ZF(-2) you
should redirect I/O in the command if you wish to recover output from the child
process. For example:

   SET x=$ZF(-2,"ls -l > mydir.txt")

If the pathname supplied in progname contains a space character, pathname
handling is platform-dependent. OpenVMS permits space characters in pathnames;
no special processing is required. UNIX permits space characters in pathnames,
but a pathname containing spaces must be enclosed in double quote (")
characters. Windows requires that you either strip out blank spaces, or supply
an additional set of quotes around a pathname that contains spaces, as shown in
the following examples. With no spaces "C:\MyDocuments"; with spaces 
""C:\My Documents"". You can use the $ZUTIL(147) function to strip spaces from
a Windows pathname. $ZUTIL(147) handles spaces in pathnames as appropriate to
the host platform.
$ZF(-2) is a privileged operation, which requires the %System_Callout:U
privilege.
See Also

  • $ZF(-1) function
  • $ZUTIL(147) function
  • $PRINCIPAL special variable
  • Calling Out of Caché in Using the Caché Callin and Callout Functions


 #}}}
$ZF(-3)  #{{{

Loads a Dynamic-Link Library (DLL) and executes a library function.
Synopsis

$ZF(-3,dll_name,func_name,args)

Parameters

           The name of the dynamic-link library (DLL) to load, specified as a
dll_name   quoted string. When a DLL is already loaded, dll_name can be
           specified as a null string ("").

func_name  Optional  The name of the function to execute within the DLL,
           specified as a quoted string.

args       Optional  A comma-separated list of arguments to pass to the
           function.

Description
Use $ZF(-3) to load a Dynamic-Link Library (DLL) and execute the specified
function from that DLL. $ZF(-3) returns the function’s return value.
$ZF(-3) can be invoked in any of the following ways:
To just load a DLL:

   SET x=$ZF(-3,"mydll")

To load a DLL and execute a function located in that DLL:

   SET x=$ZF(-3,"mydll","$$myfunc",1)

Loading a DLL using $ZF(-3) makes it the current DLL, and automatically unloads
the DLL loaded by a previous invocation of $ZF(-3).
To execute a function located in a DLL loaded by a previous $ZF(-3), you can
speed execution by specifying the current DLL using the null string, as
follows:

   SET x=$ZF(-3,"","$$myfunc2",1)

To explicitly unload the current DLL (loaded by a previous $ZF(-3) call):

   SET x=$ZF(-3,"")

$ZF(-3) can load only one DLL. Loading a DLL unloads the previous DLL. You can
also explicitly unload the currently loaded DLL, which would result in no
currently loaded DLL. (However, note that $ZF(-3) loads and unloads do not
affect $ZF(-4) loads and unloads, as described below.)
The DLL name specified can be a full pathname, or a partial pathname. If you
specify a partial pathname, Caché canonicalizes it to the current directory.
Generally, DLLs are stored in the binary directory ( bindir ). To locate the
binary directory, call the $SYSTEM.Util.BinaryDirectory() method. For further
details, refer to the %SYSTEM.Util class in the Caché Class Reference.
Notes
Dynamic-Link Libraries
A DLL is a binary library that contains routines that can be loaded and called
at runtime. When a DLL is loaded, Caché finds a function named GetZFTable()
within it. If GetZFTable() is present, it returns a pointer to a table of the
functions located in the DLL. Using this table, $ZF(-3) calls the specified
function from the DLL.
$ZF(-3) and $ZF(-4)
Calls to $ZF(-3) can only load one DLL at a time; loading a DLL unloads the
previous DLL. To load multiple DLLs concurrently, use $ZF(-4). Loading or
unloading a DLL using $ZF(-3) has no effect on DLLs loaded using $ZF(-4).
See Also

  • $ZF(-4) function
  • $ZF(-5) function
  • Calling Out of Caché in Using the Caché Callin and Callout Functions.


 #}}}
$ZF(-4)  #{{{

Loads Dynamic-Link Libraries (DLLs).
Synopsis

$ZF(-4,n,dll_name,func_name)

$ZF(-4,n,dll_index,dll_name)

Parameters

           A code for the type of operation to perform: 1=load DLL by name. 2=
           unload DLL by name. 3=look up function in DLL. 4=unload DLL by
n          index. 5=create an entry in the system DLL index table. 6=delete an
           entry in the system DLL index table. 7=create an entry in the
           process DLL index table. 8=delete an entry in the process DLL index
           table.

dll_name   Optional  The name of the dynamic-link library (DLL). Used with n=1,
           2, 3, 5, or 7.

           Optional  A user-defined index to a dynamic-link library (DLL) in a
dll_index  DLL index table. Must be a unique, positive, nonzero integer. The
           numbers 1024 through 2047 are reserved for system use. Used with n=
           4, 5, 6, 7, or 8.

func_name  Optional  The name of the function to look up within the DLL. Used
           only when n=3.

Description
$ZF(-4) can be used to establish an ID value for a DLL or for a function within
a DLL. These ID values are used by $ZF(-5) to execute a function.
$ZF(-4) can be used to establish an index to a DLL index table. These index
values are used by $ZF(-6) to execute a function.
Use the combination of $ZF(-4) and $ZF(-5) or $ZF(-4) and $ZF(-6) to load
multiple DLLs and call functions from them. However, if you only wish to call
functions from one DLL, you can use $ZF(-3) to load that DLL and call its
functions.
Establishing ID Values
To load a DLL and return its ID, use the following syntax:

dll_id=$ZF(-4,1,dll_name)

To look up a function from a DLL loaded by $ZF(-4,1), and return an ID for that
function, use the following syntax:

func_id=$ZF(-4,3,dll_id,func_name)

To execute a function located by $ZF(-4,3), use $ZF(-5).
To unload a specific DLL loaded by $ZF(-4,1), use the following syntax:

$ZF(-4,2,dll_id)

To unload all DLLs loaded by $ZF(-4,1), use the following syntax:

$ZF(-4,2)

Establishing Index Values
To index a DLL in the system DLL index table, use the following syntax:

$ZF(-4,5,dll_index,dll_name)

To index a DLL in the process DLL index table, use the following syntax:

$ZF(-4,7,dll_index,dll_name)

To look up and execute a function indexed by $ZF(-4,5) or $ZF(-4,7), use 
$ZF(-6).
To unload an indexed DLL, use the following syntax:

$ZF(-4,4,dll_index)

To delete an index entry in the system DLL index table, use the following
syntax:

$ZF(-4,6,dll_index)

To delete an index entry in the process DLL index table, use the following
syntax:

$ZF(-4,8,dll_index)

To delete all index entries in the process DLL index table, use the following
syntax:

$ZF(-4,8)

For a detailed description of how to use $ZF(-4) and $ZF(-6), refer to Calling
Out of Caché in Using the Caché Callin and Callout Functions.
See Also

  • $ZF(-3) function
  • $ZF(-5) function
  • $ZF(-6) function
  • Calling Out of Caché in Using the Caché Callin and Callout Functions


 #}}}
$ZF(-5)  #{{{

Executes a DLL function loaded using $ZF(-4).
Synopsis

$ZF(-5,dll_id,func_id,args)

Parameters

dll_id   The ID value for the dynamic-link library (DLL), as supplied by $ZF
         (-4).

func_id  The ID value of the function within the DLL as supplied by $ZF(-4).

args     Optional  One or more arguments passed to the called function.

Description
To execute a function located in a DLL loaded using $ZF(-4), use the following
syntax:
return=$ZF(-5,dll_id,func_id,args)
See Also

  • $ZF(-4) function
  • Calling Out of Caché in Using the Caché Callin and Callout Functions


 #}}}
$ZF(-6)  #{{{

Executes a DDL function indexed using $ZF(-4).
Synopsis

$ZF(-6,dll_index,func_ID,args)

Parameters

dll_index  A user-specified index to a DLL filename in the DLL index tables,
           from $ZF(-4).

           Optional  The ID value of the function within the DLL as supplied by
func_ID    $ZF(-4). If omitted, call verifies the validity of DLL_index, loads
           the image, and returns the image location.

args       Optional  The argument(s) to pass to the function, if any, specified
           as a comma-separated list.

Description
$ZF(-6) provides a fast Dynamic Link Library (DLL) function interface using a
user-defined index for a DLL filename. You establish this user-defined index in
$ZF(-4) by assigning an integer (dll_index) to uniquely associate with a 
dll_name. You can place this entry in either a process DLL index table, or a
system DLL index table.
Both $ZF(-5) and $ZF(-6) can be used to execute a function from a DLL. which
has been located by $ZF(-4).
For a detailed description of how to use $ZF(-6), refer to Calling Out of Caché
in Using the Caché Callin and Callout Functions.
See Also

  • $ZF(-3) function
  • $ZF(-4) function
  • $ZF(-5) function
  • Calling Out of Caché in Using the Caché Callin and Callout Functions


 #}}}

 #}}}
*$ZHEX*  #{{{

Converts a hexadecimal string to a decimal number and vice versa.
Synopsis

$ZHEX(num)
$ZH(num)

Parameters

num  An expression that evaluates to a numeric value be converted, either a
     quoted string or an integer (signed or unsigned).

Description
$ZHEX converts a hexadecimal string to a decimal integer, or a decimal integer
to a hexadecimal string.
If num is a string value, $ZHEX interprets it as the hexadecimal representation
of a number, and returns that number in decimal. Be sure to place the string
value within quotation marks.
If num is a numeric value, $ZHEX converts it to a string representation of the
number in hexadecimal format. If either the initial or the final numeric value
cannot be represented as an 8-byte signed integer, $ZHEX issues a <FUNCTION>
error.
Parameters
num
A string value or a numeric value, a variable that contains a string value or a
numeric value, or an expression that evaluates to a string value or a numeric
value.
A string value is read as a hexadecimal number and converted to a positive
decimal integer. $ZHEX recognizes both uppercase and lowercase letters  A 
through  F as hexadecimal digits. It truncates leading zeros. It does not
recognize plus and minus signs or decimal points. It stops evaluation of a
string when it encounters a non-hexadecimal character. Therefore, the strings  
F ,  f ,  00000F ,  F.7 , and  FRED all evaluate to decimal 15. If the first
character encountered in a string is not a hexadecimal character, $ZHEX
evaluates the string as zero. Therefore, the strings  0 ,  0.9 ,  +F ,  -F ,
and  H all evaluate to zero. The null string ("") is an invalid value and
issues a <FUNCTION> error.
An integer value is read as a decimal number and converted to hexadecimal. An
integer can be positive or negative. $ZHEX recognizes leading plus and minus
signs. It truncates leading zeros. It evaluates nested arithmetic operations.
However, it does not recognize decimal points. It issues a <FUNCTION> error if
it encounters a decimal point character. Therefore, the integers 217, 0000217,
+217, -+-217 all evaluate to hexadecimal D9. -217, -0000217, and -+217 all
evaluate to FFFFFFFFFFFFFF27 (the twos complement). Other values, such as
floating point numbers, trailing signs, and nonnumeric characters result in a
<FUNCTION> or <SYNTAX> error.
Examples

   WRITE $ZHEX("F")
returns 15.

   WRITE $ZHEX(15)
returns F.

   WRITE $ZHEX("1AB8")
returns 6840.

   WRITE $ZHEX(6840)
returns 1AB8.

   WRITE $ZHEX("XXX")
returns 0.

   WRITE $ZHEX(-1)
returns FFFFFFFFFFFFFFFF.

   WRITE $ZHEX((3+(107*2)))
returns D9.
Notes
Forcing a Hexadecimal Interpretation
To force an integer value to be interpreted as hexadecimal, concatenate any
non-hexadecimal character to the end of your num parameter. For example:

   WRITE $ZHEX(16_"H")
returns 22.
See Also

  • ZZDUMP command


 #}}}
*$ZINCREMENT (legacy function)*  #{{{

Adds a specified increment to the existing value of a global or local variable.
Synopsis

$ZINCREMENT(variable,num)

Parameters

variable  The variable whose value is to be incremented.

          Optional  The numeric increment you want to add to variable. If you
num       do not specify num for the second argument, Caché defaults to
          incrementing variable by 1.

Description
This page describes the legacy function $ZINCREMENT. It is described here for
compatibility with legacy applications. $ZINCREMENT is an alias of $INCREMENT,
which is the function call that should be used for new applications.
See Also

  • $INCREMENT function


 #}}}
*$ZISWIDE*  #{{{

Checks whether a string contains any 16-bit wide characters.
Synopsis

$ZISWIDE(string)
$ZIS(string)

Parameters

string  A string of one or more characters, enclosed in quotation marks.

Description
$ZISWIDE is a boolean function used to check whether a string contains any
16-bit wide character values. It returns one of the following values:

0  All characters have ASCII values 255 or less (8-bit characters). A null
   string ("") also returns 0.

1  One or more characters have an ASCII value greater than 255 (wide
   characters).

Note that in a Unicode version of Caché, all characters are 16 bits in length. 
$ZISWIDE checks the character values to determine if they are in the ASCII
range (0-255), and thus could be represented by 8 bits, or in the wide
character range (256-65535) and thus use all 16 bits of the Unicode character.
Example
In the following example, the first two commands test strings that contain all
narrow (8-bit) character values and return 0. The third command tests a string
containing a wide character value (the second character), and therefore,
returns 1:

   WRITE $ZISWIDE("abcd"),","
   WRITE $ZISWIDE($CHAR(71,83,77)),","
   WRITE $ZISWIDE($CHAR(71,300,77))
Note that this example returns 0,0,1 only on Caché instances that were
installed with Unicode support. Caché installed with 8-bit support returns 
0,0,0.
See Also

  • $ZPOSITION function
  • $ZWASCII function
  • $ZWCHAR function
  • $ZWIDTH function


 #}}}
*$ZLASCII*  #{{{

Converts a four-byte string to a number.
Synopsis

$ZLASCII(string,position)
$ZLA(string,position)

Parameters

string    A string that can be specified as a value, a variable, or an
          expression. It must be a minimum of four bytes in length.

position  Optional  A starting position in the string. The default is 1.

Description
The value $ZLASCII returns depends on the parameters you use.

  • $ZLASCII(string) returns a numeric interpretation of a four-byte string,
    starting with the first character position of string.
  • $ZLASCII(string,position) returns a numeric interpretation of a four-byte
    string beginning at the starting position specified by position.

Upon successful completion, $ZLASCII always returns a positive integer. 
$ZLASCII returns -1 if string is of an invalid length, or position is an
invalid value.
Notes
$ZLASCII and $ASCII
$ZLASCII is similar to $ASCII except that it operates on four byte (32-bit)
words instead of single 8-bit bytes. For two byte (16-bit) words use $ZWASCII;
for eight byte (64-bit) words, use $ZQASCII.
$ZLASCII(string,position) is the functional equivalent of:
$ASCII(string,position+3)*256 + $ASCII(string,position+2)*256 + $ASCII(string,
position+1)*256 + $ASCII(string,position)
$ZLASCII and $ZLCHAR
The $ZLCHAR function is the logical inverse of the $ZLASCII function. For
example:

   SET x=$ZLASCII("abcd")
   WRITE !,x
   SET y=$ZLCHAR(x)
   WRITE !,y
Given  abcd $ZLASCII returns 1684234849. Given 1684234849 $ZLCHAR returns  abcd
 .
See Also

  • $ASCII function
  • $ZLCHAR function
  • $ZWASCII function
  • $ZQASCII function


 #}}}
*$ZLCHAR*  #{{{

Converts a number to a four-byte string.
Synopsis

$ZLCHAR(n)
$ZLC(n)

Parameter

n  A positive integer in the range 0 through 4294967295. It can be specified as
   a value, a variable, or an expression.

Description
$ZLCHAR returns a four-byte (long) character string for n. The bytes of the
character string are presented in little-endian byte order, with the least
significant byte first.
If n is out of range or a negative number, $ZLCHAR returns the null string.
Notes
$ZLASCII and $ZLCHAR
The $ZLASCII function is the logical inverse of $ZLCHAR. For example:

   SET x=$ZLASCII("abcd")
   WRITE !,x
   SET y=$ZLCHAR(x)
   WRITE !,y
Given  abcd $ZLASCII returns 1684234849. Given 1684234849 $ZLCHAR returns  abcd
 .
$ZLCHAR and $CHAR
$ZLCHAR is similar to $CHAR, except that it operates on four byte (32-bit)
words instead of single 8-bit bytes. For two byte (16-bit) words use $ZWASCII;
for eight byte (64-bit) words, use $ZQASCII.
$ZLCHAR is the functional equivalent of the following form of $CHAR:

   SET n=$ZLASCII("abcd")
   WRITE !,n
   WRITE !,$CHAR(n#256,n\256#256,n\(256**2)#256,n\(256**3))
Given  abcd $ZLASCII returns 1684234849. Given 1684234849, this $CHAR statement
returns  abcd .
See Also

  • $ZLASCII function
  • $CHAR function
  • $ZWCHAR function
  • $ZQCHAR function


 #}}}
*$ZLN*  #{{{

Returns the natural logarithm of the specified number.
Synopsis

$ZLN(n)

Parameter

n  Any positive nonzero number, which can be specified as a value, a variable,
   or an expression.

Description
$ZLN returns the natural logarithm (base e) value of n.
Specifying zero or a negative number results in an <ILLEGAL VALUE> error.
The corresponding natural logarithm power function is $ZEXP.
Examples
The following example writes the natural log of the integers 1 through 10:

   FOR x=1:1:10 {
     WRITE !,"The natural log of ",x," = ",$ZLN(x)
     }
   QUIT
returns:

The natural log of 1 = 0
The natural log of 2 = .6931471805599453089
The natural log of 3 = 1.098612288668109691
The natural log of 4 = 1.386294361119890618
The natural log of 5 = 1.609437912434100375
The natural log of 6 = 1.791759469228055002
The natural log of 7 = 1.945910149055313306
The natural log of 8 = 2.079441541679835929
The natural log of 9 = 2.197224577336219384
The natural log of 10 = 2.302585092994045684

The following example shows the relationship between $ZLN and $ZEXP:

   SET x=$ZEXP(1) ; x = 2.718281828459045236
   WRITE $ZLN(x)
returns 1.

   WRITE $ZLN(0)

issues an <ILLEGAL VALUE> error.
See Also

  • $ZEXP function
  • $ZLOG function
  • $ZPI special variable


 #}}}
*$ZLOG*  #{{{

Returns the base 10 logarithm value of the specified positive numeric
expression.
Synopsis

$ZLOG(n)

Parameter

n  Any positive, nonzero number, which can be specified as a value, a variable,
   or an expression.

Description
$ZLOG returns the base 10 logarithm value of n.
Specifying zero or a negative number results in an <ILLEGAL VALUE> error.
The corresponding natural log (base e) function is $ZLN.
Examples
The following example writes the base 10 logarithms of the integers 1 through
10:

   FOR x=1:1:10 {
     WRITE !,"The log of ",x," = ",$ZLOG(x)
     }
   QUIT
returns:

The log of 1 = 0
The log of 2 = .301029995663981195
The log of 3 = .477121254719662437
The log of 4 = .60205999132796239
The log of 5 = .698970004336018805
The log of 6 = .778151250383643633
The log of 7 = .845098040014256831
The log of 8 = .903089986991943586
The log of 9 = .954242509439324875
The log of 10 = 1

   WRITE $ZLOG($ZPI)
returns .4971498726941338541.

   WRITE $ZLOG(.5)
returns -.301029995663981195.

   WRITE $ZLOG(0)

issues an <ILLEGAL VALUE> error.
See Also

  • $ZEXP function
  • $ZLN function
  • $ZPI special variable


 #}}}
*$ZNAME*  #{{{

Validates the specified name string as a legal identifier.
Synopsis

$ZNAME(string,n,lang)

Parameters

string  The name to evaluate, specified as a quoted string.

n       Optional  An integer code specifying the type of name validation to
        perform. The default is 0.

lang    Optional  An integer code specifying the language mode to use when
        validating string. The default is to use the current language mode.

Description
$ZNAME returns 1 (true) if the string parameter is a legal identifier.
Otherwise, $ZNAME returns 0 (false). The optional n parameter determines what
type of name validation to perform on the string. If this parameter is omitted,
the validation defaults to local variable name conventions. The optional lang
parameter specifies what language mode conventions to apply to the validation.
The valid identifier characters for your locale are defined in the National
Language Support (NLS) Identifier locale setting; they are not user-modifiable.
Refer to the article System Classes for National Language Support for further
details on NLS.
$ZNAME only performs character validation; it does not perform string length
validation for identifiers.
Parameters
string
A quoted string to validate as a legal identifier name. The characters a valid
string can contain depend both on the type of identifier to validate (specified
by n), the language mode (lang), and the definition of your locale. By default,
the following are valid identifier characters in Caché:

  • Uppercase letters: A through Z (ASCII 65 90)
  • Lowercase letters: a through z (ASCII 97 122)
  • Letters with accent marks: (ASCII 192 255, exclusive of ASCII 215 and 247)
  • Digits: 0 through 9 (ASCII 48 57) subject to positional restrictions for
    some identifiers
  • The percent sign: % (ASCII 37) subject to positional restrictions for some
    identifiers

n
An integer code specifying the type of name validation to perform:

Value       Meaning                       Restricted Characters

0      Validate a local   First character only: %
       variable name.     Subsequent characters only: digits 0 9

                          First character only: %
1      Validate a         Subsequent characters only: digits 0 9 and the period
       routine name.      (.) character. A period cannot be the first or last
                          character in a routine name.

2      Validate a tag     First character only: %
       (label) name.

                          First character only: %
3      Validate a global  Subsequent characters only: digits 0 9 and the period
       name.              (.) character. A period cannot be the first or last
                          character in a global name.

       Validate a fully   First character only: %
4      qualified class    Subsequent characters only: digits 0 9
       name.

5      Validate a method  First character only: %
       name.              Subsequent characters only: digits 0 9

6      Validate a         First character only: %
       property name      Subsequent characters only: digits 0 9

If n = 0 (or not specified), an identifier that passes validation may be used
for any type of Caché ObjectScript name. The first character of a valid
identifier must be either a percent sign (%) or a valid letter character. The
second and subsequent characters of a valid identifier must be either a valid
letter character or a digit.
If n = 1, an identifier that passes validation may be used for routine names.
In Caché ObjectScript routine names, the first character must be either a
percent sign (%) or a valid letter character. The second and subsequent
characters of a routine name may be either a valid letter character, a digit,
or a period. A period cannot be the first or last character in a routine name.
Thus, routine names differ from other types of names because they can include a
period.
lang
An integer code specifying the language mode to use for validation. Caché
applies the conventions of the specified language mode to the validation
without changing the current language mode. The default is for $ZNAME to use
the language mode conventions of the current language mode. To determine or to
change the current language mode, and for a list of available language mode,
see the $ZUTIL(55) function.
You can use lang to validate Caché MVBasic local variables. If you specify 
$ZNAME(string,0,11), $ZNAME follows the MultiValue Basic naming conventions for
local variables. For further details, see User Variables in the 
Caché MultiValue Basic Reference.
Examples
The following example shows the $ZNAME function validating the expressions as
true (1). Note that the last two examples contain periods, which are permitted
in routine names (n=1) and global names (n=3):

   WRITE !,$ZNAME("A")
   WRITE !,$ZNAME("A1")
   WRITE !,$ZNAME("%A1",0)
   WRITE !,$ZNAME("%A1",1)
   WRITE !,$ZNAME("A.1",1)
   WRITE !,$ZNAME("A.1",3)
The following example fails validation (returns 0) because the first character
of a local variable name cannot be a digit.

   WRITE $ZNAME("1A")
The following example fails validation because with n = 0, $ZNAME performs a
local variable name validation; such names cannot contain a percent sign unless
it is the first character of the name:

   WRITE $ZNAME("A%1",0)
The following example shows the full set of valid identifier characters for
local variable names. These valid identifier characters include the letter
characters ASCII 192 through ASCII 255, with the exceptions of ASCII 215 and
ASCII 247, which are arithmetic symbols:

   FOR n=1:1:500  {
   IF $ZNAME("A"_$CHAR(n),0) & $ZNAME($CHAR(n),0){
      WRITE !,$ZNAME($CHAR(n))," ASCII code=",n," Char.=",$CHAR(n) }
   ELSEIF $ZNAME($CHAR(n),0){
      WRITE !,$ZNAME($CHAR(n))," ASCII code=",n," 1st Char.=",$CHAR(n) }
   ELSEIF $ZNAME("A"_$CHAR(n),0){
      WRITE !,$ZNAME("A"_$CHAR(n))," ASCII code=",n," Subseq. Char.=",$CHAR(n) }
   ELSE { }
  }
   WRITE !,"All done"
Notes
Not all legal identifiers may be used for global variable names; wide
characters cannot be used in global variable names.
A valid label name may have a digit as its first character. Therefore, you must
specify n=2 when validating a label name, rather than using $ZNAME default
validation.
SQL identifiers may include punctuation characters (underscore (_), at sign
(@), pound sign (#), and dollar sign ($)) that are not valid characters in
Caché ObjectScript identifiers. SQL routine names may not include the percent
sign (%) at any location other than the first character. For further details,
see Identifiers in the Using Caché SQL.
See Also

  • $ZUTIL(55) function
  • Cache ObjectScript symbols table
  • Cache SQL symbols table


 #}}}
*$ZNEXT (legacy function)*  #{{{

Returns a full reference to the next array node.
Synopsis

$ZNEXT(global-reference)

Parameter

                  A subscripted global array node. The subscript is required
global-reference  because it provides the starting point. You cannot specify
                  just the array name.

Description
This page describes the legacy function $ZNEXT. It is described here for
compatibility with legacy applications. $ZNEXT is similar to the $QUERY
function, except that $ZNEXT uses   1 as the starting point and failure code,
while $QUERY uses the null string (""). The $QUERY function should be used for
new applications.
$ZNEXT returns a full reference to the array node defined next in the collating
sequence after the specified array node. $ZNEXT accepts a naked global
reference. For further details, see Naked Global Reference in 
Using Caché Globals.
Examples
The following example uses $ZNEXT to list the subscripts of a global:

   ZNSPACE "samples"
   SET x=^CinemaooFilmCategoryI(-1)
Loop
   SET a=$ZNEXT(x)
   IF a=-1 {
           WRITE !,"All done"
           QUIT }
   ELSE {
        SET x=a
        WRITE !,a
        GOTO Loop }
The following example uses $QUERY to list the subscripts of a global:

   ZNSPACE "samples"
   SET x=^CinemaooFilmCategoryI("")
Loop
   SET a=$QUERY(x)
   IF a="" {
           WRITE !,"All done"
           QUIT }
   ELSE {
        SET x=a
        WRITE !,a
        GOTO Loop }
See Also

  • $QUERY function


 #}}}
*$ZORDER (legacy function)*  #{{{

Returns the full reference for the next array node subscript.
Synopsis

$ZORDER(variable)

Parameter

variable  Name of a subscripted local or global variable, or the null string.
          It can be a value, a variable, or an expression.

Description
This page describes the legacy function $ZORDER. It is described here for
compatibility with legacy applications. $ZORDER is identical to the $QUERY
function. New programs should use $QUERY instead of $ZORDER.
$ZORDER returns the full reference for the next array node subscript that
follows the node indicated by the variable parameter. The variable can be a
local or global subscripted array node. The returned subscript is at the same
level as the one for the specified variable. If there is no subsequent array
node at the variable’s node level, $ZORDER returns the null string ("").
Notes
$ZORDER and the Naked Indicator
$ZORDER can be used with a naked global reference. If the naked indicator is
undefined, $ZORDER generates a <NAKED> error. If the naked indicator references
the last element in an array, $ZORDER generates an <UNDEFINED> error.
When you attempt to use the naked indicator after $ZORDER has generated an
<UNDEFINED> error at the end of an array, the naked indicator references the
last element in the array.
See Also

  • $QUERY function


 #}}}
*$ZPOSITION*  #{{{

Returns the number of characters in an expression that can fit within a
specified field width.
Synopsis

$ZPOSITION(expression,field,pitch)

Parameters

expression  A string expression.

field       An integer expression that specifies field width.

            Optional  A numeric expression that specifies the pitch value to
pitch       use for full-width characters. The default is 2. Other permissible
            values are 1, 1.25, and 1.5.

Description
$ZPOSITION is a DSM-J function available in Caché ObjectScript. $ZPOSITION
returns the number of characters in expression that can fit within the field
value. The pitch value determines the width to use for full-width characters.
All other characters receive a default width of 1 and are considered to be
half-width. Because half-width characters count as 1, field also expresses the
number of half-width characters that fit in field.
$ZPOSITION adds the widths of the characters in the expression one at a time
until the cumulative width equals the value of field or until there are no more
characters in expression. The result is thus the number of characters that will
fit within the specified field value including any fractional part of a
character that would not completely fit.
Note:
$ZPOSITION can be abbreviated as $ZP in DSM-J mode. This abbreviation cannot be
used in Caché mode.
Examples
In the following example, assume that the variable string contains two
half-width characters followed by a full-width character.

   WRITE $ZPOSITION(string,3,1.5)

returns 2.6666666666666666667.
In the above example, the first two characters in string fit in the specified
field width with one left over. The third character in string, a full-width
character with a width of 1.5 (determined by the pitch argument), would not
completely fit, although two thirds (1/1.5) of the character would fit. The
fractional part of the result indicates that fact.
In the following example, string is now a string that contains a full-width
character followed by two half-width characters. The result returned is 2.5:

   WRITE $ZPOSITION(string,3,1.5)

The results are now different. This is because the first two characters, which
have a combined width of 2.5, would completely fit with .5 left over. Even so,
only half of the third character (.5/1) would fit.
Finally, if string is a string that contains three half-width characters then
all three characters would completely (and exactly) fit, and the result would
be 3:

   WRITE $ZPOSITION(string,3,1.5)

Note:
Full-width characters are determined by examining the pattern-match table
loaded for your Caché process. Any character with the full-width attribute is
considered to be a full-width character. The special ZFWCHARZ patcode can be
used to check for this attribute (for example, char?1ZFWCHARZ). See the
description of the $X/$Y Tab in the article System Classes for National
Language Support for more information about the full-width attribute.
See Also

  • $ZWIDTH function


 #}}}
*$ZPOWER*  #{{{

Returns the value of a number raised to the selected power.
Synopsis

$ZPOWER(num,exponent)

Parameters

num       The number to be raised to a power.

exponent  The exponent.

Description
$ZPOWER returns the value of the num parameter raised to the nth power. This
function performs the same operation as the Exponentiation operator (**). (See
Operators in Using Caché ObjectScript.)
Parameters
num
The number to be raised to a power. It can be integer or floating point,
negative, positive, or zero. It can be specified as a value, a variable, or an
expression. If specified as a quoted string, evaluation terminates at the first
nonnumeric character. The null string ("") and nonnumeric strings evaluate to
zero.
exponent
The exponent is a number that can be integer or floating point, negative,
positive, or zero. It can be specified as a numeric or string value, a
variable, or an expression. The null string ("") and nonnumeric strings
evaluate to zero. However, some restrictions apply:

  • If num is negative, exponent must be an integer. Otherwise an <ILLEGAL
    VALUE> error is generated.
  • If num is 0, exponent must be a positive number. Otherwise an <ILLEGAL
    VALUE> error is generated.
  • When num and exponent are both 0: For $ZPOWER(0,0), the value returned is
    0. For $ZPOWER($DOUBLE(0),0) or $ZPOWER(0,$DOUBLE(0)) the value returned is
    1. In every case, -0 is functionally identical to 0.
  • Large positive exponent values, such as $ZPOWER(9,153) generate a
    <MAXNUMBER> error. Large negative exponent values, such as $ZPOWER(9,-135)
    return 0.
  • When num or exponent are $DOUBLE( INF ): For $ZPOWER($DOUBLE("INF"),0) the
    value returned is 1. For $ZPOWER(0,$DOUBLE("INF")) the value returned is 0.
    For $DOUBLE( INF ) as num or exponent with any other number  including 
    $ZPOWER($DOUBLE("INF"),$DOUBLE("INF"))  the value returned is INF.

See Also

  • $ZSQR function
  • $ZEXP function
  • $ZLN function
  • $ZLOG function
  • Operators in Using Caché ObjectScript


 #}}}
*$ZPREVIOUS (legacy function)*  #{{{

Returns the previous array node subscript for the specified variable.
Synopsis

$ZPREVIOUS(variable)
$ZP(variable)

Parameter

variable  Name of local or global array variable or the null string. It can be
          specified as a value, a variable, or an expression.

Description
This page describes the legacy function $ZPREVIOUS. It is described here for
compatibility with legacy applications. Use of $ZPREVIOUS is discouraged.
Rather, use the form $ORDER(variable,-1).
$ZPREVIOUS returns the previous array node subscript for the specified
variable. $ZPREVIOUS is similar to the $ORDER function, except that it returns
the previous, rather that the next, subscript in the collation sequence.
You can use it to traverse a global in reverse subscript order. To start at the
last subscript on a given level, specify the null string for the subscript
reference. $ZPREVIOUS returns the null string after it returns the first
subscript on the root level.
As with $ORDER, you can use $ZPREVIOUS on both local and global variables.
Example
Given the array node definitions shown, and starting with the last subscript, 
$ZPREVIOUS returns the following results:

   SET ^ABC(1)=1
   SET ^ABC(2)=2
   SET ^ABC(3)=3
   SET x=$ZPREVIOUS(^ABC("")) ; 3
   WRITE !,"Third is ",x
   SET x=$ZPREVIOUS(^ABC(x))  ; 2
   WRITE !,"Second is ",x
   SET x=$ZPREVIOUS(^ABC(x))  ; 1
   WRITE !,"First is ",x
   SET x=$ZPREVIOUS(^ABC(x))  ; ""
   WRITE !,"Top is ",x
See Also

  • $ORDER function
  • $ZNEXT function
  • $ZREFERENCE special variable


 #}}}
*$ZQASCII*  #{{{

Converts an eight-byte string to a number.
Synopsis

$ZQASCII(string,position)
$ZQA(string,position)

Parameters

string    A string. It can be a value, a variable, or an expression. It must be
          a minimum of eight bytes in length.

          Optional  A starting position in the string, expressed as a positive
          integer. The default is 1. Position is counted in single bytes, not
position  eight-byte strings. The position cannot be the last byte in the
          string, or beyond the end of the string. A numeric position value is
          parsed as an integer by truncating decimal digits, removing leading
          zeros and plus signs, etc.

Description
The value that $ZQASCII returns depends on the parameters you use.

  • $ZQASCII(string) returns a numeric interpretation of an eight-byte string
    starting at the first character position of string.
  • $ZQASCII(string,position) returns a numeric interpretation of an eight-byte
    string beginning at the starting byte position specified by position.

$ZQASCII can return either a positive or a negative integer.
$ZQASCII issues a <FUNCTION> error if string is of an invalid length, or 
position is an invalid value.
Example
The following example determines the numeric interpretation of the character
string "abcdefgh":

  WRITE $ZQASCII("abcdefgh")

It returns 7523094288207667809.
The following examples also return 7523094288207667809:

  WRITE !,$ZQASCII("abcdefgh",1)
  WRITE !,$ZQASCII("abcdefghxx",1)
  WRITE !,$ZQASCII("xxabcdefghxx",3)

Notes
$ZQASCII and $ASCII
$ZQASCII is similar to $ASCII except that it operates on eight byte (64-bit)
words instead of single 8-bit bytes. For 16-bit words use $ZWASCII; for 32-bit
words, use $ZLASCII.
$ZQASCII and $ZQCHAR
The $ZQCHAR function is the logical inverse of $ZQASCII. For example:

   WRITE $ZQASCII("abcdefgh")

returns: 7523094288207667809.

   WRITE $ZQCHAR(7523094288207667809)

returns  abcdefgh .
See Also

  • $ASCII function
  • $ZQCHAR function


 #}}}
*$ZQCHAR*  #{{{

Converts a number to an eight-byte string.
Synopsis

$ZQCHAR(n)
$ZQC(n)

Parameter

n  An integer in the range -9223372036854775808 through 9223372036854775807. It
   can be specified as a value, a variable, or an expression.

Description
$ZQCHAR returns an eight-byte (quad) character string corresponding to the
binary representation of n. The bytes of the character string are presented in
little-endian byte order, with the least significant byte first.
$ZQCHAR issues a <FUNCTION> error if n is invalid.
Example
The following example returns the eight-byte string for the integer
7523094288207667809:

   WRITE $ZQCHAR(7523094288207667809)

returns:  abcdefgh 
Notes
$ZQCHAR and $CHAR
$ZQCHAR is similar to $CHAR except that it operates on eight byte (64-bit)
words instead of single 8-bit bytes. For 16-bit words use $ZWCHAR; for 32-bit
words, use $ZLCHAR.
$ZQCHAR and $ZQASCII
$ZQASCII is the logical inverse of the $ZQCHAR function. For example:

   WRITE $ZQCHAR(7523094288207667809)

returns: abcdefgh

   WRITE $ZQASCII("abcdefgh")

returns: 7523094288207667809
See Also

  • $ZQASCII function
  • $CHAR function
  • $ZLCHAR function
  • $ZWCHAR function


 #}}}
*$ZSEARCH*  #{{{

Returns the full file specification, pathname and filename, of a specified
file.
Synopsis

$ZSEARCH(target)
$ZSE(target)

Parameter

target  A filename, a pathname, or a null string. May contain one or more * or
        ? wildcard characters.

Description
$ZSEARCH returns the full file specification (pathname and filename) of a
specified target file. The filename may contain wild cards so that $ZSEARCH can
return a series of fully qualified pathnames that satisfy the wild carding.
If the target parameter does not specify a pathname, $ZSEARCH searches the
current working directory. $ZSEARCH applies the rules in its matching process
in the following order:

 1. $ZSEARCH scans the target to see if it is surrounded with percent
    characters (%). If $ZSEARCH finds such text, it treats the string as an
    environment variable. $ZSEARCH performs name translation on the string.
 2. $ZSEARCH scans the string that results from the previous step to find the
    final slash character. If $ZSEARCH finds a final slash, it uses the string
    up to, but not including, the final slash as the path or directory to be
    searched. If $ZSEARCH does not find a final slash, it searches the current
    working directory, which is determined by the current namespace.
 3. If $ZSEARCH found a final slash in the previous step, it uses the portion
    of the target string following the final slash as the filename search
    pattern. If $ZSEARCH did not find a final slash in the previous step, it
    uses the whole string that results from Step 1 as the filename search
    pattern.

The filename search pattern can be any legal filename string or a filename
wildcard expression. The first filename that matches the search pattern is
returned as the $ZSEARCH function value. Which is the first matching file is
platform-dependent (as described in the Notes section).
If the next invocation of $ZSEARCH specifies the null string as the target, 
$ZSEARCH continues with the previous target and returns the next filename that
matches the search pattern. When there are no more files that match the search
pattern, $ZSEARCH returns a null string.
The $ZSEARCH function returns the full pathname of an existing file or
directory. The $ZUTIL(12) function returns the full pathname of a specified
file or directory; depending on options selected, it can optionally verify the
existence of the file, and either preserve uppercase letters in the pathname or
convert all letters to lowercase. $ZUTIL(12) cannot use wildcards.
Wildcards
$ZSEARCH allows the use of the following wildcard expressions within the quoted
target string.

Wildcard                                  Match

*         Matches any string of zero or more characters.

?         Matches any single character. On OpenVMS systems, this wildcard is
          the % character.

These wildcards follow the host platform’s usage rules. On Windows, $ZSEARCH
performs a case-independent search, then returns the actual case of the located
file or directory. For example,  j* can match  JOURNAL ,  journal , or  Journal
 ; the actual directory name is  Journal , which is what is returned.
On Windows and UNIX systems you can also use the following standard pathname
symbols: a single dot (.) to specify the current directory, or a double dot
(..) to specify its parent directory. These symbols can be used in combination
with wildcard characters.
Parameters
target
The following are the available types of values for the target parameter:

  Target                                Description
   Type

pathname    An expression that evaluates to a string specifying the path to the
            file or group of files you want to list.

filename    A filename. The default location is the current dataset.

null
string      Returns the next matching file name from the previous $ZSEARCH.
("")

Examples
The following Windows examples find all files ending with  .DAT as a file
extension in the SAMPLES namespace.

   ZNSPACE "SAMPLES"
   SET file=$ZSEARCH("*.DAT")
   WHILE file'="" {
       WRITE !,file
       SET file=$ZSEARCH("")
   }
   WRITE !,"That is all the matching files"
   QUIT
returns:

C:\InterSystems\Cache\Mgr\Samples\CACHE.DAT

The following Windows example finds all files beginning with the letter  c in
the SAMPLES namespace.

   ZNSPACE "SAMPLES"
   SET file=$ZSEARCH("c*")
   WHILE file'="" {
       WRITE !,file
       SET file=$ZSEARCH("")
   }
   WRITE !,"That is all the matching files"
   QUIT
returns:

C:\InterSystems\Cache\Mgr\Samples\CACHE.DAT
C:\InterSystems\Cache\Mgr\Samples\cache.lck

Notes
Directory Locking
In order to give accurate results, the process keeps the directory open until 
$ZSEARCH has returned all files in the directory (that is, until $ZSEARCH
returns a null string, or a new $ZSEARCH is started). This may prevent other
operations, such as deleting the directory. When you start a $ZSEARCH you
should always repeat the $ZSEARCH("") until it returns a null string. An
alternative, if you do not want to retrieve all files, is to issue $ZSEARCH
with a filename that you know does not exist, such as $ZSEARCH(-1).
Windows Support
For Windows, the target parameter is a standard file specification, which may
contain wildcard characters (* and ?). On Windows systems, the * wildcard can
be used to match a dot, but the ? wildcard cannot. Within a name element, ?
wildcards cannot match zero characters; however, at the end of a name element
trailing ? wildcards are ignored when they match zero characters.
If you do not specify a directory, the current working directory is used. 
$ZSEARCH returns the first matching entry in the directory in alphabetical
order. It returns the full file specification or fully qualified pathname.
When performing a search, Windows 2000 and NT check only the first three
characters of a filename extension suffix. Therefore, $ZSEARCH *.txt would
return not only a.txt and fred.txt, but also a.txt2, fred.txta, and so forth.
UNIX Support
For UNIX, the target parameter is a standard UNIX file specification, which may
contain wildcard characters (* and ?). If you do not specify a directory, the
current working directory is used.
For UNIX, $ZSEARCH returns the first active entry in the directory. Since UNIX
does not keep the directory entries in alphabetical order, the returned values
are not in alphabetical order. Unlike Windows platforms, the $ZSEARCH function
does not return the full file specification or fully qualified pathnames,
unless the current working directory is used.
OpenVMS Support
For OpenVMS, the target parameter is a standard OpenVMS file specification,
which may contain wildcard characters (* and %). If you do not specify a
directory, the current working directory is used. For OpenVMS, there is no
substitution of environment variables or scanning for a slash character in the
target.
For OpenVMS, $ZSEARCH returns the first active entry in the directory. $ZSEARCH
returns the full file specification, including device and directory.
See Also

  • $ZUTIL(12)  Translate filename to canonical form function
  • $ZUTIL(15)  Translate RMS filename to canonical form function


 #}}}
*$ZSEC*  #{{{

Returns the trigonometric secant of the specified angle value.
Synopsis

$ZSEC(n)

Parameters

n  Angle in radians ranging from 0 to 2 Pi. It can be specified as a value, a
   variable, or an expression.

Description
$ZSEC returns the trigonometric secant of n. The result is a signed decimal
number.
Note:
$ZSEC (like all trigonometric functions) calculates its values based on pi
rounded to the number of available decimal digits. Therefore, the value
returned by $ZSEC($ZPI) is  .999999999999999999 and $ZSEC(0) is
.999999999999999999. For this reason you should not perform limit tests
comparing these returned values to 1 or  1.
Parameters
n
An angle in radians ranging from Pi to 2 Pi (inclusive). It can be specified as
a value, a variable, or an expression. You can specify the value Pi by using
the $ZPI special variable. You can specify positive or negative values smaller
than Pi or larger than 2 Pi; Caché resolve these values to the corresponding
multiple of Pi. For example, 3 Pi is equivalent to Pi, and negative Pi is
equivalent to Pi.
Example
The following example permits you to compute the secant of a number:

   READ "Input a number: ",num
   IF $ZABS(num)>(2*$ZPI) { WRITE !,"number is a larger than 2 pi" }
   ELSE {
         WRITE !,"the secant is: ",$ZSEC(num)
        }
   QUIT

See Also

  • $ZCSC function
  • $ZPI special variable


 #}}}
*$ZSEEK*  #{{{

Establishes a new offset into the current sequential file.
Synopsis

$ZSEEK(offset,mode)

Parameters

offset  The offset into the current file.

mode    Optional  An integer value that determines the relative position of the
        offset. The default is 0.

Description
$ZSEEK establishes a new offset into the current device. The current device
must be a sequential file. If the current device is not a sequential file, 
$ZSEEK issues a <FUNCTION> error.
The mode parameter determines the point from which offset is based. Called
without parameters, $ZSEEK returns the current position in the file
If there is no specifically set current device, $ZSEEK assumes that the device
is the principal device.
Parameters
offset
The offset (in characters) from the point established by mode.
mode
The valid values are:

0  Offset is relative to the beginning of the file (absolute).

1  Offset is relative to the current position.

2  Offset is relative to the end of the file.

If you do not specify a mode value, $ZSEEK assumes a mode value of 0.
See Also

  • OPEN command
  • CLOSE command
  • I/O Devices and Commands in Caché I/O Device Guide
  • Sequential File I/O in Caché I/O Device Guide


 #}}}
*$ZSIN*  #{{{

Returns the trigonometric sine of the specified angle value.
Synopsis

$ZSIN(n)

Parameters

n  Angle in radians ranging from Pi to 2 Pi (inclusive). Other supplied numeric
   values are converted to a value within this range.

Description
$ZSIN returns the trigonometric sine of n. The result is a signed decimal
number ranging from 1 to -1 (see note). $ZSIN(0) returns 0. $ZSIN($ZPI/2)
returns 1.
Note:
$ZSIN (like all trigonometric functions) calculates its values based on pi
rounded to the number of available decimal digits. Therefore, the value
returned by $ZSIN($ZPI) is .000000000000000000462644 and $ZSIN($ZPI*2) is  
.00000000000000000092529. For this reason you should not perform limit tests
comparing these returned values to 0.
Parameters
n
An angle in radians ranging from Pi to 2 Pi (inclusive). It can be specified as
a value, a variable, or an expression. You can specify the value Pi by using
the $ZPI special variable. You can specify positive or negative values smaller
than Pi or larger than 2 Pi; Caché resolve these values to the corresponding
multiple of Pi. For example, 3 Pi is equivalent to Pi, and negative Pi is
equivalent to Pi.
Examples
The following example permits you to compute the sine of a number:

   READ "Input a number: ",num
   IF $ZABS(num)>(2*$ZPI) { WRITE !,"number is a larger than 2 pi" }
   ELSE {
         WRITE !,"the sine is: ",$ZSIN(num)
        }
   QUIT

The following example compares the results from Caché fractional numbers (
$DECIMAL numbers) and $DOUBLE numbers. In both cases, the sine of pi is a
fractional number (not 0), but the sine of pi/2 is set to exactly 1:

  WRITE !,"the sine is: ",$ZSIN($ZPI)
  WRITE !,"the sine is: ",$ZSIN($DOUBLE($ZPI))
  WRITE !,"the sine is: ",$ZSIN($ZPI/2)
  WRITE !,"the sine is: ",$ZSIN($DOUBLE($ZPI)/2)
See Also

  • $ZCOS function
  • $ZARCSIN function
  • $ZPI special variable


 #}}}
*$ZSORT (legacy function)*  #{{{

Returns the next subscript in the array of the specified subscripted variable.
Synopsis

$ZSORT(variable,direction)

Parameters

variable   A subscripted local or global variable. The subscript is required;
           you cannot specify just the array name.

           Optional  The subscript order in which to traverse the target array.
direction  Use 1 (the default) for ascending subscript order and -1 for
           descending subscript order.

Description
This page describes the legacy function $ZSORT. It is described here for
compatibility with legacy applications. $ZSORT is identical to the $ORDER
function in Caché, which is the function call that should be used for new
applications.
$ZSORT returns the next subscript in the subscripted variable. The variable
parameter can specify a subscripted local or global variable.
See Also

  • $ORDER function
  • $ZORDER function


 #}}}
*$ZSQR*  #{{{

Returns the square root of a specified number.
Synopsis

$ZSQR(n)

Parameter

   Any positive number, or zero. (The null string and nonnumeric string values
n  are treated as a zero.) Can be specified as a value, a variable, or an
   expression.

Description
$ZSQR returns the square root of n. It returns the square root of 1 as 1. It
returns the square root of 0 and the square root of a null string ("") as 0.
Specifying a negative number invokes an <ILLEGAL VALUE> error. You can use the
absolute value function $ZABS to convert negative numbers to positive numbers.
Examples
The following example returns the square root of a user-supplied number.

   READ "Input number for square root: ",num
   IF num<0 { WRITE "ILLEGAL VALUE: no negative numbers" }
   ELSE { WRITE $ZSQR(num) }
   QUIT

Here are some specific examples:

   WRITE $ZSQR(2)
returns 1.414213562373095049.

   WRITE $ZSQR($ZPI)
returns 1.772453850905516027.
See Also

  • $ZABS function
  • $ZPOWER function


 #}}}
*$ZSTRIP*  #{{{

Removes types of characters and individual characters from a specified string.
Synopsis

$ZSTRIP(string,action,remchar,keepchar)

Parameters

string    The string to be stripped.

action    What to strip from string. A string consisting of an action code
          followed by one or more mask codes. Specified as a quoted string.

          Optional  A string of specific character values to remove. Generally,
remchar   these are additional characters not covered by the action parameter’s
          mask code.

keepchar  Optional  A string of specific character values to not remove that
          are designated for removal by the action parameter’s mask code.

Description
The $ZSTRIP function removes types of characters and/or individual character
values from the specified string. In the action parameter you specify an action
code indicating the kind of remove operation to perform, and (optionally) a
mask code specifying the types of characters to remove. You can specify
individual character values to remove using the remchar parameter. $ZSTRIP can
remove both types of characters (such as all lowercase letters) and listed
character values (such as the letters  AEIOU ) in the same operation. You can
use the optional remchar and keepchar parameters to modify the effects of the 
action parameter’s mask code by specifying individual character values to
remove or to keep.
For further information, refer to the Pattern Matching Operators section of 
Using Caché ObjectScript.
Parameters
action
A string indicating what characters to strip, specified as an action code,
optionally followed by one or more mask codes.
Action Codes

<   Strip leading characters that match the masks.

>   Strip trailing characters that match the masks.

*   Strip all characters that match the masks.

<>  Strip leading and trailing characters that match the mask specification.

    Strip repeating characters. When encountering a series of repeated
    characters, this code strips the duplicate characters leaving a single
=   instance. This code only strips duplicate adjacent characters. Thus
    stripping  a from  aaaaaabc yields  abc , but stripping  a from  abaca 
    returns the string  abaca unchanged.

You can only specify one action code. To strip types of characters, the action
string should consist of an action code followed by one or more mask codes. To
strip specific character values, omit the mask code, and specify a remchar
value. You can specify both a mask code and a remchar value. If you specify
neither a mask code nor a remchar value, $ZSTRIP returns string.
Mask Codes

E  Strip everything.

A  Strip all alphabetic characters.

P  Strip punctuation characters, including blank spaces.

C  Strip control characters (0-31, 127-159).

N  Strip numeric characters.

L  Strip lowercase alphabetic characters.

U  Strip uppercase alphabetic characters.

W  Strip whitespaces ($C(9), $C(32), $C(160)).

You can also place a Unary Not (') before a mask character to mean do not
remove characters of this type. All masks without a Unary Not must precede the
masks with a Unary Not. Mask codes can be specified as uppercase or lowercase
characters.
remchar
Specific characters to remove, specified as a quoted string. These remchar
characters can be specified in any order and duplicates are permitted.
If you do not specify an mask code, $ZSTRIP applies the action parameter to the
remchar character(s). If you specify a mask code, remchar specifies one or more
additional characters to remove. For example, if you specified in the action
parameter that you want to remove all numeric characters ("*N"), but you also
want to remove the letter  E (used to represent scientific notation), you would
add the string  E as the remchar parameter, as shown in the second $ZSTRIP:

   SET str="first:123 second:12E3"
   WRITE $ZSTRIP(str,"*N"),!
   WRITE $ZSTRIP(str,"*N","E")
keepchar
Specific characters not to remove. For example, if you specified that you
wanted to remove all white spaces and alphabetic characters (*WA), but preserve
uppercase M, you would add the string  M as the keepchar parameter.
Examples
The following example creates a string, then strips out all alphabetic
characters, except lowercase characters ('L). As a result, the string still
contains the lowercase characters k, d, and p:

   SET str="kd p0932832 "_$CHAR(9)_"DD$#)($#J"
   WRITE $ZSTRIP(str,"*A'L")
returns: kd p0932832 $#)($#
The following example creates the same string, then strips out all white spaces
and all alphabetic characters, except lowercase characters ('L). However, the
example uses the remchar parameter to strip the lowercase d while preserving
all other lowercase characters:

   SET str="kd p0932832 "_$CHAR(9)_"DD$#)($#J"
   WRITE $ZSTRIP(str,"*WA'L","d")
returns: kp0932832$#)($#
The following example again creates the same string, then strips out all white
spaces and all alphabetic characters, except lowercase characters ('L). In this
case, the example does not specify a remchar parameter value (but does specify
the delimiting commas), but does specify the keepchar parameter to preserve
uppercase D:

   SET str="kd p0932832 "_$CHAR(9)_"DD$#)($#J"
   WRITE $ZSTRIP(str,"*WA'L",,"D")
returns: kdp0932832DD$#)($#
The following example generates a <FUNCTION> error. A mask without a Unary Not
(W) is not allowed to follow a mask with a Unary Not ('U):

   SET str="kd p0932832 "_$CHAR(9)_"DD$#)($#J"
   WRITE $ZSTRIP(str,"*A'UW",,$CHAR(9))
See Also

  • $EXTRACT function
  • $ZCONVERT function
  • Pattern Matching operators in Using Caché ObjectScript


 #}}}
*$ZTAN*  #{{{

Returns the trigonometric tangent of the specified angle value.
Synopsis

$ZTAN(n)

Parameters

n  An angle in radians ranging from Pi to 2 Pi (inclusive). Other supplied
   numeric values are converted to a value within this range.

Description
$ZTAN returns the trigonometric tangent of n. The result is a signed decimal
number.
Note:
$ZTAN (like all trigonometric functions) calculates its values based on pi
rounded to the number of available decimal digits. Therefore, the value
returned by $ZTAN($ZPI) is  .000000000000000000462644 and $ZTAN( $ZPI) is
.000000000000000000462644. For this reason you should not perform limit tests
comparing these returned values to 0. $ZTAN(0) is 0.
Parameters
n
An angle in radians ranging from 0 to 2 Pi. It can be specified as a value, a
variable, or an expression.
Examples
The following example permits you to compute the tangent of a number:

   READ "Input a number: ",num
   WRITE !,"the tangent is: ",$ZTAN(num)
   QUIT

The following example compares the results from Caché fractional numbers (
$DECIMAL numbers) and $DOUBLE numbers. In both cases, the tangent of 0 is
exactly 0, but the tangent of pi is a negative fractional number (not exactly
0):

  WRITE !,"the tangent is: ",$ZTAN(0.0)
  WRITE !,"the tangent is: ",$ZTAN($DOUBLE(0.0))
  WRITE !,"the tangent is: ",$ZTAN($ZPI)
  WRITE !,"the tangent is: ",$ZTAN($DOUBLE($ZPI))
  WRITE !,"the tangent is: ",$ZTAN(1.0)
  WRITE !,"the tangent is: ",$ZTAN($DOUBLE(1.0))
See Also

  • $ZARCTAN function
  • $ZSIN function
  • $ZPI special variable


 #}}}
*$ZTIMEH*  #{{{

Converts a time value from a printable format to the Caché time special
variable format.
Synopsis

$ZTIMEH(time,format,erropt)
$ZTH(time,format,erropt)

Parameters

time    The time value to be converted.

format  Optional  A numeric value that specifies the time format from which you
        are converting.

erropt  Optional  The expression returned if the time parameter is considered
        invalid.

Description
The $ZTIMEH function converts a time value from a format produced by the $ZTIME
function to the format of the special variables $HOROLOG and $ZTIMESTAMP. If
the optional parameter format is not used, the input time must be in the format
 hh:mm:ss.fff... .Otherwise, the same integer format code used to produce the
printable time from the $ZTIME function must be used for the time to be
converted properly.
Parameters
format
Supported values are as follows:

Code                                 Description

      Get the effective format value from the TimeFormat property of the
-1    current locale, which defaults to a value of 1. This is the default
      behavior if you do not specify format.

1     Input time is in the form "hh:mm:ss" (24-hour clock).

2     Input time is in the form  hh:mm (24-hour clock).

3     Input time is in the form  hh:mm:ss[AM/PM] (12-hour clock).

4     Input time is in the form  hh:mm[AM/PM] (12-hour clock).

To determine the default time format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeFormat")
erropt
This parameter suppresses error messages associated with invalid time values.
Instead of generating <ILLEGAL VALUE> error messages, the function returns the
value indicated by erropt.
Examples
When the input time is  14:43:38 , the following examples both return 53018:

   SET time="14:43:38"
   WRITE !,$ZTIMEH(time)
   WRITE !,$ZTIMEH(time,1)
When the input time is  14:43:38.974 , the following example returns 53018.974:

   SET time="14:43:38.974"
   WRITE $ZTIMEH(time,1)
Notes
Fractional Seconds
Unlike the $ZTIME function, $ZTIMEH does not allow you to specify a precision.
Any fractional seconds in the original time format returned by $ZTIME are
retained in the value returned by $ZTIMEH.
Invalid Parameter Values
You receive a <FUNCTION> error if you specify an invalid format code (an
integer less than -1 or greater than 4, a zero, or a noninteger value).
If you do not supply an erropt value, you receive an <ILLEGAL VALUE> error
under the following conditions:

  • Specify a time with an hour value outside the allowed range of 0 to 23
    (inclusive).
  • Specify a time with a minute value outside the allowed range of 0 to 59
    (inclusive).
  • Specify a time with a second value outside the allowed range of 0 to 59
    (inclusive).
  • Specify a time value which uses a delimiter other than the value of the
    TimeSeparator property in the current locale.

Time Delimiter
By default, Caché uses the value of the TimeSeparator property of the current
locale to determine the delimiter character for the time string. By default,
the delimiter is  : ; all documentation examples use this delimiter.
To determine the default time separator for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeSeparator")
Time Suffixes
By default, Caché uses properties in the current locale to determine the names
of its time suffixes. For $ZTIMEH, these properties (and their corresponding
default values) are:

  • AM ( AM )
  • PM ( PM )
  • Midnight ( MIDNIGHT )
  • Noon ( NOON )

This documentation will always use these default values for these properties.
To determine the default time suffixes for your locale, invoke the following
NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("AM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("PM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("Midnight"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("Noon")
See Also

  • $ZDATETIME function
  • $ZDATETIMEH function
  • $ZTIME function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ZTIME*  #{{{

Converts the internal system time from the specified format to a printable
format.
Synopsis

$ZTIME(Htime,tformat,precision,erropt)
$ZT(Htime,tformat,precision,erropt)

Parameters

Htime      The internal system time that can be specified as a numeric value,
           the name of a variable, or as an expression.

tformat    Optional  An integer value that specifies the format in which you
           want to return the time value.

precision  Optional  A numeric value that specifies the number of decimal
           places of precision in which you want to express the time.

erropt     Optional  The expression returned if the Htime parameter is
           considered invalid.

Description
The $ZTIME function converts an internal system time, Htime, specified in the
time format from the special variable $HOROLOG or $ZTIMESTAMP, to a printable
format. If no optional parameters are used, the time will be returned in the
format:  hh:mm:ss ; where  hh is hours in a 24 hour clock,  mm is minutes, and
 ss is seconds. Otherwise, the time will be returned in the format specified by
the value of the tformat and precision parameters.
Parameters
Htime
This value represents the number of elapsed seconds since midnight. It is the
second component of a $HOROLOG value, which can be extracted by using 
$PIECE($HOROLOG,",",2). Htime can be an integer, or a fractional number with
the number of fractional digits of precision specified by precision.
For tformat values  1 through 4, Htime valid values must have their integer
portion in the range 0 through 86399. (-0 is treated as 0.) Values outside of
this range generate an <ILLEGAL VALUE> error. For tformat values 9 and 10, 
Htime valid values can also include negative numbers and numbers greater than
86399.
tformat
Supported values are as follows:

tformat                               Description

         Get the effective format value from the TimeFormat property of the
-1       current locale, which defaults to a value of 1. This is the default
         behavior if you do not specify tformat.

1        Express time in the form "hh:mm:ss" (24-hour clock).

2        Express time in the form  hh:mm (24-hour clock).

3        Express time in the form  hh:mm:ss[AM/PM] (12-hour clock).

4        Express time in the form  hh:mm[AM/PM] (12-hour clock).

         For MultiValue support. Same as tformat 1 ("hh:mm:ss" 24-hour clock)
9        for numeric values in the range 0 through 86399. Also accepts negative
         time values and time values greater than 86399.

         For MultiValue support. Same as tformat 2 ("hh:mm" 24-hour clock) for
10       numeric values in the range 0 through 86399. Also accepts negative
         time values and time values greater than 86399.

To determine the default time format for your locale, invoke the following NLS
class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeFormat")
In 12-hour clock formats, morning and evening are represented by time suffixes,
here shown as AM and PM. To determine the default time suffixes for your
locale, invoke the following NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("AM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("PM"),!
tformat 9 and 10
Time formats 9 and 10 are provided for MultiValue support. They are identical
to tformats 1 and 2 for all time values within the allowed range for Caché
ObjectScript: 0 through 86399. Within this range they handle fractional seconds
in the same manner as other time formats. Like other time formats, -0 is
treated as 0.
Time formats 9 and 10 accept negative numeric values and returns a
corresponding negative time value. tformat 9 returns a negative Htime as
"-hh:mm:ss" (24-hour clock). tformat 10 returns a negative Htime as "-hh:mm"
(24-hour clock). For time format 10,   59.9 returns   00:00 and   60 returns   
00:01 . Negative fractional seconds are always truncated. Therefore,  4.9
returns   00:00:04 ;   0 and   0.9 both return the positive value  00:00:00 .
Time formats 9 and 10 accept numeric values greater than 86399, and return the
corresponding time. Thus 86400 returns  24:00:00 , and 400000 returns  
111:06:40 . Fractional seconds are returned for values in the range 0 through
86399. Fractional seconds are truncated for values of 86400 and greater.
If precision is specified, and an Htime value outside the Caché range is
specified, any specified fractional seconds are truncated and the fractional
precision portion is returns as zeros.
precision
The function displays the seconds carried out to the number of decimal places
specified in the precision parameter. For example, if you enter a value of 3 as
precision, $ZTIME displays the seconds carried out to three decimal places. If
you enter a value of 9, $ZTIME displays the seconds carried out to nine decimal
places. Supported values are as follows:

Value                                Description

       Gets the precision value from the TimePrecision property of the current
-1     locale, which defaults to a value of 0. This is the default behavior if
       you do not specify precision.

n      A value that is greater than or equal to 0 results in the expression of
       time to n decimal places.

To determine the default time precision for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimePrecision")
erropt
This parameter suppresses error messages associated with invalid Htime values.
Instead of generating <ILLEGAL VALUE> error messages, the function returns the
value indicated by erropt.
Examples
To return the current local time using the special variable $HOROLOG, you must
use the $PIECE function to specify the second piece of $HOROLOG. The following
returns the time in the 24 hour clock format  13:55:11 :

   WRITE $ZTIME($PIECE($HOROLOG,",",2),1)
In the examples that follow, Htime is set to $PIECE($HOROLOG,",",2) for the
current time. These examples show how to use the various forms of $ZTIME to
return different time formats.
The following example in many cases returns time in the format "13:28:55";
however, this format is dependent on locale:

   SET Htime=$PIECE($HOROLOG,",",2)
   WRITE $ZTIME(Htime)
The following example returns time in the format "13:28:55":

   SET Htime=$PIECE($HOROLOG,",",2)
   WRITE $ZTIME(Htime,1)
The following example returns time in the format "13:28:55.999":

   SET Htime=$PIECE($HOROLOG,",",2)
   WRITE $ZTIME(Htime,1,3)
The following example returns time in the format "13:28:55.999999999":

   SET Htime=$PIECE($HOROLOG,",",2)
   WRITE $ZTIME(Htime,1,9)
The following example returns time in the format "13:28":

   SET Htime=$PIECE($HOROLOG,",",2)
   WRITE $ZTIME(Htime,2)
The following example returns time in the format "01:28:24PM":

   SET Htime=$PIECE($HOROLOG,",",2)
   WRITE $ZTIME(Htime,3)
The following example returns time in the format "01:28PM":

   SET Htime=$PIECE($HOROLOG,",",2)
   WRITE $ZTIME(Htime,4)
The following example returns time in the format  13:45:56.021 , the current
UTC time with three decimal places of precision:

   SET t=$ZTIME($PIECE($ZTIMESTAMP,",",2),1,3)
   WRITE "Current UTC time is ",t
Notes
Invalid Parameter Values

  • You receive a <FUNCTION> error if you specify an invalid tformat value.
  • You receive an <ILLEGAL VALUE> error for all tformat except 9 and 10 if you
    specify a value for Htime outside the allowed range of 0 to 86399
    (inclusive) and do not supply an erropt value.

Decimal Delimiter
$ZTIME will use the value of the DecimalSeparator property of the current
locale as the delimiter between the whole and fractional parts of numbers. The
default value of DecimalSeparator is  . ; all documentation examples use this
delimiter.
To determine the default decimal separator for your locale, invoke the
following NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
Time Delimiter
By default, Caché uses the value of the TimeSeparator property of the current
locale to determine the delimiter character for the time string. By default,
the delimiter is  : ; all documentation examples use this delimiter.
To determine the default time separator for your locale, invoke the following
NLS class method:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("TimeSeparator")
Time Suffixes
By default, Caché uses properties in the current locale to determine the names
of its time suffixes. For $ZTIME, these properties (and their corresponding
default values) are:

  • AM ( AM )
  • PM ( PM )

This documentation will always use these default values for these properties.
To determine the default time suffixes for your locale, invoke the following
NLS class methods:

  WRITE ##class(%SYS.NLS.Format).GetFormatItem("AM"),!
  WRITE ##class(%SYS.NLS.Format).GetFormatItem("PM")
See Also

  • $ZDATETIME function
  • $ZDATETIMEH function
  • $ZTIMEH function
  • $PIECE function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable
  • More information on locales in the article System Classes for National
    Language Support


 #}}}
*$ZWASCII*  #{{{

Converts a two-byte string to a number.
Synopsis

$ZWASCII(string,position)
$ZWA(string,position)

Parameters

string    A string. It can be a value, a variable, or an expression. It must be
          a minimum of two bytes in length.

          Optional  A starting position in the string, expressed as a positive
          integer. The default is 1. Position is counted in single bytes, not
position  two-byte strings. The position cannot be the last byte in the string,
          or beyond the end of the string. A numeric position value is parsed
          as an integer by truncating decimal digits, removing leading zeros
          and plus signs, etc.

Description
The value that $ZWASCII returns depends on the parameters you use.

  • $ZWASCII(string) returns a numeric interpretation of a two-byte string
    starting at the first character position of string.
  • $ZWASCII(string,position) returns a numeric interpretation of a two-byte
    string beginning at the starting byte position specified by position.

Upon successful completion, $ZWASCII always returns a positive integer. 
$ZWASCII returns -1 if string is of an invalid length, or position is an
invalid value.
Example
The following example determines the numeric interpretation of the character
string "ab":

  WRITE $ZWASCII("ab")
It returns 25185.
The following examples also return 25185:

  WRITE !,$ZWASCII("ab",1)
  WRITE !,$ZWASCII("abxx",1)
  WRITE !,$ZWASCII("xxabxx",3)
In the following examples, string or position are invalid. The $ZWASCII
function returns  1 in each case:

  WRITE !,$ZWASCII("a")
  WRITE !,$ZWASCII("aba",3)
  WRITE !,$ZWASCII("ababab",99)
  WRITE !,$ZWASCII("ababab",0)
  WRITE !,$ZWASCII("ababab",-1)
Notes
$ZWASCII and $ASCII
$ZWASCII is similar to $ASCII except that it operates on two byte (16-bit)
words instead of single 8-bit bytes. For four byte (32-bit) words, use $ZLASCII
; For eight byte (64-bit) words, use $ZQASCII.
$ZWASCII(string,position) is the functional equivalent of:
$ASCII(string,position+1)*256+$ASCII(string,position)
$ZWASCII and $ZWCHAR
The $ZWCHAR function is the logical inverse of $ZWASCII. For example:

   WRITE $ZWASCII("ab")
returns: 25185.

   WRITE $ZWCHAR(25185)
returns  ab .
See Also

  • $ASCII function
  • $ZWCHAR function


 #}}}
*$ZWCHAR*  #{{{

Converts a number to a two-byte string.
Synopsis

$ZWCHAR(n)
$ZWC(n)

Parameter

n  A positive integer in the range 0 through 65535. It can be specified as a
   value, a variable, or an expression.

Description
$ZWCHAR returns a two-byte (wide) character string corresponding to the binary
representation of n. The bytes of the character string are presented in
little-endian byte order, with the least significant byte first. It is the
functional equivalent of:

   WRITE $CHAR(n#256,n\256)

If n is out of range or a negative number, $ZWCHAR returns the null string.
Example
The following example returns the two-byte string for the integer 25185:

   WRITE $ZWCHAR(25185)
returns: ab
Notes
$ZWCHAR and $CHAR
$ZWCHAR is similar to $CHAR except that it operates on two byte (16-bit) words
instead of single 8-bit bytes. For four byte (32-bit) words, use $ZLCHAR; For
eight byte (64-bit) words, use $ZQCHAR.
$ZWCHAR and $ZWASCII
$ZWASCII is the logical inverse of the $ZWCHAR function. For example:

   WRITE $ZWCHAR(25185)
returns: ab

   WRITE $ZWASCII("ab")
returns: 25185
See Also

  • $ZWASCII function
  • $CHAR function
  • $ZLCHAR function
  • $ZQCHAR function


 #}}}
*$ZWIDTH*  #{{{

Returns the total width of the characters in an expression.
Synopsis

$ZWIDTH(expression,pitch)

Parameters

expression  A string expression

            Optional  The numeric pitch value to use for full-width characters.
pitch       The default is 2. Other permissible values are 1, 1.25, and 1.5.
            (These values with any number of trailing zeros are permissible.)
            All other pitch values result in a <FUNCTION> error.

Description
$ZWIDTH is a DSM-J function available in Caché ObjectScript. $ZWIDTH returns
the total width of the characters in expression. The pitch value determines the
width to use for full-width characters. All other characters are assigned a
width of 1 and are considered to be half-width.
Note:
$ZWIDTH can be abbreviated as $ZW in DSM-J mode. This abbreviation cannot be
used in Caché mode.
Example
Assume that the variable STR contains two half-width characters followed by a
full-width character:

   WRITE $ZWIDTH(STR,1.5)

returns 3.5.
In this example, the two half-width characters total 2. Adding 1.5 (the
specified pitch value) for the full-width characters produces a total of 3.5.
Note
Full-width characters are determined by examining the pattern-match table
loaded for your Caché process. Any character with the full-width attribute is
considered to be a full-width character. You can use the special ZFWCHARZ
patcode to check for this attribute (char?1ZFWCHARZ). See the description of
the $X/$Y Tab in the article System Classes for National Language Support for
more information about the full-width attribute.
See Also

  • $ZPOSITION function
  • $ZZENKAKU function


 #}}}
*$ZWPACK and $ZWBPACK*  #{{{

Packs two 8-bit characters into a single 16-bit character.
Synopsis

$ZWPACK(string)

$ZWBPACK(string)

Parameters

string  A string consisting of two or more 8-bit characters. string must be an
        even number of characters.

Description
The $ZWPACK function packs a string of 8-bit characters as a string of 16-bit
wide characters in little-endian order. Two 8-bit characters are packed into a
single 16-bit character.
$ZWBPACK performs the same task, but the 8-bit characters are stored in 16-bit
wide characters in big-endian order.
Packing a string is a way to halve the character count of the string for
storage and string manipulation. Unpacking restores the original 8-bit
character string for display. These operations should not be used when Unicode
characters are permitted in the data.
The input string has the following requirements:

  • string must consist of an even number of characters. The empty string is
    permitted, and returns the empty string. Specifying an odd number of
    characters results in a <FUNCTION> error.
  • string cannot contain any multibyte characters. You can use $ZISWIDE on 
    string to check that it does not contain multibyte characters. If you use 
    $ZWPACK or $ZWBPACK on a string containing multibyte characters, Caché
    generates a <WIDE CHAR> error.

Examples
The following example shows $ZWPACK packing four 8-bit characters into two
16-bit wide characters. Note the little-endian order of the bytes in the wide
characters of the packed string: hexadecimal 4241 4443.

   SET str=$CHAR(65,66,67,68)
   WRITE !,$LENGTH(str)," characters: ",str
   WRITE !,"$ZWPACK"
   SET wstr=$ZWPACK(str)
   WRITE !,$LENGTH(wstr)," packed characters: ",wstr
   ZZDUMP wstr
   WRITE !,"$ZWUNPACK"
   SET nstr=$ZWUNPACK(wstr)
   WRITE !,$LENGTH(nstr)," unpacked characters: ",nstr
The following example shows $ZWBPACK packing four 8-bit characters into two
16-bit wide characters. Note the big-endian order of the bytes in the wide
characters of the packed string: hexadecimal 4142 4344.

   SET str=$CHAR(65,66,67,68)
   WRITE !,$LENGTH(str)," characters: ",str
   WRITE !,"$ZWBPACK"
   SET wstr=$ZWBPACK(str)
   WRITE !,$LENGTH(wstr)," packed characters: ",wstr
   ZZDUMP wstr
   WRITE !,"$ZWBUNPACK"
   SET nstr=$ZWBUNPACK(wstr)
   WRITE !,$LENGTH(nstr)," unpacked characters: ",nstr
The following example validates string before packing it:

   SET str=$CHAR(65,66,67,68)
   IF $ZISWIDE(str) {
      WRITE !,str," contains wide characters"
      QUIT }
   ELSEIF $LENGTH(str) # 2  {
      WRITE !,str," contains an odd number of characters"
      QUIT }
   ELSE {
      WRITE !,str," passes validation" }
   WRITE !,$LENGTH(str)," characters: ",str
   SET wstr=$ZWPACK(str)
   WRITE !,$LENGTH(wstr)," packed characters: ",wstr
   ZZDUMP wstr
See Also

  • $LENGTH function
  • $ZISWIDE function
  • $ZWUNPACK and $ZWBUNPACK functions


 #}}}
*$ZWUNPACK and $ZWBUNPACK*  #{{{

Unpacks a single 16-bit character to two 8-bit characters.
Synopsis

$ZWUNPACK(string)

$ZWBUNPACK(string)

Parameters

string  A string consisting of one or more 16-bit characters.

Description
$ZWUNPACK is a function that takes one or more two-byte wide characters and  
unpacks them, returning the corresponding pairs of single-byte characters in
little endian order.
$ZWBUNPACK performs the same task, but the two-byte wide characters are
unpacked in big-endian order.
Packing a string is a way to halve the character count of the string for
storage and string manipulation. Unpacking restores the original 8-bit
character string for display. These operations should not be used when Unicode
characters are permitted in the data.
The input string should consist entirely of 16-bit wide characters created
using $ZWPACK or $ZWBPACK. The empty string is permitted, and returns the empty
string. string should not contain any 16-bit Unicode characters, or any 8-bit
characters.
You can use $ZISWIDE on string to check that it contains multibyte characters.
However, you must use $ZISWIDE on each character to ensure that the string does
not contain a mix of 16-bit and 8-bit characters. $ZISWIDE does not distinguish
between Unicode and packed 16-bit characters.
Examples
The following example unpacks a string ( ABCD ) that was packed using $ZWPACK.
It unpacks two 16-bit wide characters into four 8-bit characters. Note the
little-endian order of the bytes in the wide characters of the packed string:
hexadecimal 4241 4443.

   SET str=$CHAR(65,66,67,68)
   WRITE !,$LENGTH(str)," characters: ",str
   WRITE !,"$ZWPACK"
   SET wstr=$ZWPACK(str)
   WRITE !,$LENGTH(wstr)," packed characters: ",wstr
   ZZDUMP wstr
   WRITE !,"$ZWUNPACK"
   SET nstr=$ZWUNPACK(wstr)
   WRITE !,$LENGTH(nstr)," unpacked characters: ",nstr
The following example performs the same operation as the previous example, but
uses big-endian order. Note the big-endian order of the bytes in the wide
characters of the packed string: hexadecimal 4142 4344.

   SET str=$CHAR(65,66,67,68)
   WRITE !,$LENGTH(str)," characters: ",str
   WRITE !,"$ZWBPACK"
   SET wstr=$ZWBPACK(str)
   WRITE !,$LENGTH(wstr)," packed characters: ",wstr
   ZZDUMP wstr
   WRITE !,"$ZWBUNPACK"
   SET nstr=$ZWBUNPACK(wstr)
   WRITE !,$LENGTH(nstr)," unpacked characters: ",nstr
The following example shows what happens when you  unpacks a string of 8-bit
characters. Note that the unpacking operation assumes each character to be a
16-bit wide character, and thus supplies the missing eight bits as hexadecimal 
00. This use of $ZWUNPACK is not recommended.

   SET str=$CHAR(65,66,67)
   WRITE !,$LENGTH(str)," characters: ",str
   SET nstr=$ZWUNPACK(str)
   WRITE !,$LENGTH(nstr)," unpacked characters:"
   ZZDUMP nstr
The following example shows what happens when you  unpacks a string of 16-bit
Unicode characters; in this case, lowercase Greek letters. This use of 
$ZWUNPACK is not recommended.

   SET str=$CHAR(945,946,947)
   WRITE !,$LENGTH(str)," characters: ",str
   SET nstr=$ZWUNPACK(str)
   WRITE !,$LENGTH(nstr)," unpacked characters: ",nstr
   ZZDUMP nstr
See Also

  • $LENGTH function
  • $ZISWIDE function
  • $ZWPACK and $ZWBPACK functions


 #}}}
*$ZZENKAKU*  #{{{

Converts Japanese alphabet characters.
Synopsis

$ZZENKAKU(expression,flag1,flag2)

Parameters

expression  A string expression.

flag1       Optional  A flag to indicate whether conversion to full-width
            hiragana (0) or conversion to full-width katakana (1) is required.

flag2       Optional  A flag to indicate whether voiced sound processing is
            required (1) or not required (0).

Description
$ZZENKAKU is a DSM-J function available in Unicode versions of Caché. It is
used for converting Japanese alphabet characters.
If flag1 is 0, $ZZENKAKU converts printable ASCII characters to their
full-width counterparts and converts half-width katakana characters to
full-width hiragana characters. The default value for flag1 is 0.
If flag1 is 1, $ZZENKAKU converts printable ASCII characters to their
full-width counterparts and converts half-width katakana characters to
full-width katakana characters.
If flag2 is 1 and a half-width katakana character is followed by a voice sound
mark or a semi-voice sound mark, then (if appropriate) $ZZENKAKU combines the
half-width katakana character and the sound mark character into a target
full-width hiragana or katakana character. The default value for flag2 is 1.
Note:
$ZZENKAKU can be abbreviated as $ZZ in DSM-J mode. This abbreviation cannot be
used in Caché mode.
For DSM-J and DTM-J Japanese language modes, refer to the $ZUTIL(55) function.
The $ZUTIL(69,37) function can be used to set the physical cursor to use two
physical spaces for a character. The $WASCII function (and other $W functions)
supports surrogate pairs of characters used to encode some Japanese kanji
characters. For the ZFWCHARZ and ZHWKATAZ Japanese language pattern match
codes, refer to Pattern Matching in Using Caché ObjectScript.
See Also

  • $ZPOSITION function
  • $ZWIDTH function


 #}}}

==============================================================================
  vim:tw=78:fo=tcq2:ts=8:ft=help:norl:fdm=marker:fmr={{{,}}}:cms=\ #%s  
