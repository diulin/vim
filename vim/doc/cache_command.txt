*cache_command.txt*	For Vim version 7.2.  Last change: 2009 Nov 11


                	  VIM REFERENCE MANUAL 
                               adopted by 
                     Andriy Diulin <diulin at gmail dot com>
		          Caché manual pages
			      Commands

For instructions on installing this file, type
	:help add-local-help
|add-local-help| inside Vim.

Abbreviations #{{{
*B*          |BREAK| command
*C*          |CLOSE| command
*D*          |DO| command
*E*          |ELSE| command (legacy version only)
*F*          |FOR| command
*G*          |GOTO| command
*H*          |HALT| command (no arguments) or HANG command (with argument)
*I*          |IF| command
*J*          |JOB| command
*K*          |KILL| command
*L*          |LOCK| command
*M*          |MERGE| command
*MVC*        |MVCRT| command
*MVP*        |MVPRINT| command
*N*          |NEW| command
*O*          |OPEN| command
*P*          |PRINT| command
*Q*          |QUIT| command
*R*          |READ| command
*S*          |SET| command
*TC*         |TCOMMIT| command
*TRO*        |TROLLBACK| command
*TS*         |TSTART| command
*U*          |USE| command
*V*          |VIEW| command
*W*          |WRITE| command
*X*          |XECUTE| command
*ZB*         |ZBREAK| command
*ZI*         |ZINSERT| command
*ZK*         |ZKILL| command
*ZL*         |ZLOAD| command
*ZN*         |ZNSPACE| command
*ZP*         |ZPRINT| command
*ZQ*         |ZQUIT| command (only the abbreviation is valid).
*ZR*         |ZREMOVE| command
*ZS*         |ZSAVE| command
*ZW*         |ZWRITE| command
 #}}}

*BREAK*  #{{{

Argumentless: Interrupts execution of the current routine and returns control
to programmer mode. With an argument: Enables or disables interrupts.
Synopsis

BREAK:pc status
B:pc status

BREAK:pc "extend"
B:pc "extend"

Arguments

pc      Optional  A postconditional expression.

        Optional  Switch to enable or disable interrupts. Valid values are: 0
status  disable, 1 enable. Cannot be used with the extend argument. The default
        is determined by context (see below).

        Optional  A code indicating the kind of interrupts to enable or
extend  disable, specified as a quoted string. Valid values are listed in BREAK
        Extended Arguments. Cannot be used with the status argument.

Description
The BREAK command has two forms:

  • Without an argument
  • With an argument

BREAK without an Argument
Argumentless BREAK inserted into routine code interrupts execution of the
current routine and returns control to programmer mode for debugging purposes.
Argumentless BREAK included in code sets a breakpoint, which interrupts routine
execution and returns the process to programmer mode. InterSystems, however,
recommends that you use the ZBREAK command to invoke the Caché debugger, rather
than setting breakpoints with BREAK.
BREAK with an Argument
BREAK status enables or disables interrupts.
BREAK extend enables or disables a specified type of breakpoints, as described
in BREAK Extended Arguments.
Arguments
pc
An optional postconditional expression. Caché executes the BREAK command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
status
A switch to enable or disable interrupts. If set to 0, interrupts are disabled.
If set to 1, interrupts are enabled.
Examples
The following example, issued at programmer prompt or included in source code,
enables user interrupts with a CTRL-C

   B 1   ; Enable user interrupts with <CTRL C>

Notes
Break Command Syntax
Older versions of Caché ObjectScript accepted only the abbreviation (B) for the
BREAK command. Current versions accept either form.
The Argumentless BREAK Command
You can use the argumentless BREAK command in program source code, with or
without a postconditional, to interrupt program execution and return to the
programmer prompt.
If you include an argumentless BREAK within a routine, it designates a
breakpoint. By imbedding breakpoints in your code, you can establish specific
contexts for debugging. Each time execution reaches a BREAK, Caché suspends the
routine and returns you to the programmer prompt. You can then use other Caché
ObjectScript commands to perform debugging activities. For example, you might
use the WRITE command to examine the values of variables at the current
stopping point and the SET command to supply new values for these or other
variables. You can also invoke the Routine Line Editor (XECUTE ^%), which
provides basic editing capabilities for modifying the routine After you suspend
routine execution with a BREAK, you can resume normal execution by using an
argumentless GOTO. Alternatively, you can resume execution at a different
location by specifying this location as an argument of the GOTO command.
Note:
InterSystems recommends that you use the ZBREAK command to invoke the Caché
Debugger, rather than using the BREAK command in code. The Debugger provides
much more extensive debugging capabilities.
Using Argumentless BREAK with a Condition
You may find it useful to specify a condition on an argumentless BREAK command
in code so that you can rerun the same code simply by setting a variable rather
than having to change the routine. For example, you may have the following line
in a routine:

   BREAK:$DATA(debug)

You can then set the variable debug to suspend the routine and return the job
to programmer mode or clear the variable debug to continue running the routine.
Using BREAK status to Enable or Disable Interrupts
Use BREAK status to control whether user interrupts, such as CTRL-C, are
enabled or disabled. The valid values for status are 1 (enabled) and 0
(disabled).

  • BREAK 1 enables interrupts from any terminal owned by the process.
  • BREAK 0 disables interrupts from any terminal owned by the process.

The default status behavior of BREAK is dependent upon the login mode, as
follows:

  • If you log in as programmer mode, the default is BREAK 1. Interrupts, such
    as CTRL-C, are always enabled. The B (/break) protocol specified in an OPEN
    or USE command has no effect.
  • If you log in as application mode, the default is BREAK 0. Interrupts, such
    as CTRL-C, are enabled or disabled by the B (/break) protocol specified in
    an OPEN or USE command.

For further details on OPEN and USE mode protocols, refer to Terminal I/O in
the Caché I/O Device Guide.
BREAK Extended Arguments
You do not have to place argumentless BREAK commands at every location where
you want to suspend your routine. BREAK has a series of "extended" arguments (
extend) that can periodically suspend a routine as if you scattered
argumentless BREAKs throughout the code. BREAK command extended arguments are
listed in the following table.

Argument                               Description

          Use BREAK "S" (Single Step) to step through your code a single
          command at a time, breaking on every Caché ObjectScript command. The
"S"       system stops breaking when a DO command, an XECUTE command, a FOR
          loop, or a user-defined function is encountered, and resumes when the
          command or loop is done.

"S-"      Use BREAK "S-" to disable single stepping at the current level and
          enable command stepping at the previous level.

          BREAK "S+" acts like BREAK "S", except that Caché continues to break
"S+"      on every command, including when a DO command, an XECUTE command, a 
          FOR loop, or a user-defined function is encountered.

          Use BREAK "L" (Line Break) to step through your code a single routine
          line at a time, breaking at the beginning of every line. The system
"L"       stops breaking when a DO command, an XECUTE command, or user-defined
          function is encountered, and resumes when the command or loop is
          done.

"L-"      Use BREAK "L-" to disable single stepping at the current level and
          enable line stepping at the previous level.

          BREAK "L+" acts like BREAK "L", except that Caché continues to break
"L+"      at the beginning of every routine line when a DO command, XECUTE
          command, or user-defined function is encountered.

          Use BREAK "C" (Clear Break) to stop breaking. Breaking resumes at a
"C"       higher routine level after the job executes a QUIT if a BREAK state
          is in effect at that higher level.

          BREAK "OFF" removes all debugging that has been established for the
"OFF"     process. It removes all breakpoints and watchpoints, and turns off
          stepping at all program stack levels. It also removes the association
          with the debug and trace devices, but does not close them.

See Debugging in Using Caché ObjectScript for more information about these
extended arguments.
Issuing a BREAK "OFF" command is equivalent to issuing the following series of
commands:

  ZBREAK /CLEAR
  ZBREAK /TRACE:OFF
  ZBREAK /DEBUG:""
  ZBREAK /ERRORTRAP:ON
  BREAK "C"    ; applied to all stack levels

See Also

  • ZBREAK command
  • OPEN command
  • USE command
  • $ZUTIL(68,5) Argumentless BREAK Process Switch function
  • $ZUTIL(69,5) Argumentless BREAK System Default function
  • Debugging in Using Caché ObjectScript
  • Terminal I/O in Caché I/O Device Guide


 #}}}
*CATCH*  #{{{

Identifies a block of code to execute when an exception occurs.
Synopsis

CATCH exceptionvar
{
   . . .
}

Arguments

              Optional  An exception variable. Specified as a local variable,
exceptionvar  with or without subscripts, that receives a reference to a Caché
              Object. This argument can, optionally, be enclosed with
              parentheses.

Description
The CATCH command defines an exception handler, a block of code to execute when
an exception occurs in a TRY block of code. The CATCH command is followed by a
block of code statements, enclosed in curly braces. A CATCH block must
immediately follow its TRY block.
The CATCH command has two forms:

  • Without an argument
  • With an argument

CATCH without an Argument
Argumentless CATCH execute the block of code within its curly braces.
CATCH with an Argument
CATCH exceptionvar receives a Caché Object reference (oref) from the THROW
command or from the system runtime environment in the event of a system error.
This Object provides properties that contain information about the exception,
such as the Name of the error and the Location where it occurred. The
user-written CATCH exception handler code can use this information to analyze
the exception.
Disabling CATCH
Issuing a ZBREAK /ERRORTRAP:OFF command disables CATCH exception handling.
Arguments
exceptionvar
A local variable, used to receive the exception object reference from the THROW
command or from the system runtime environment in the event of a system error.
When a system error occurs, exceptionvar receives a reference to an object of
type %Exception.SystemException. For further details, refer to the
%Exception.AbstractException class in the Caché Class Reference.
The exceptionvar argument can optionally be enclosed with parentheses, thus: 
CATCH(var) { code block }. This parentheses syntax is provided for
compatibility, and has no effect on functionality.
Examples
The following example shows an argumentless CATCH invoked by a runtime error:

  TRY {
    WRITE !,"x is an undefined variable"
    SET a=x
    WRITE !,"this should not display"
  }
  CATCH {
      WRITE !,"this is the exception handler"
      WRITE !,"$ECODE is:",$ECODE
  }
  WRITE !,"this is where the code falls through"
The following example shows a CATCH invoked by a runtime error. The myvar
argument receives a system-generated exception object:

  TRY {
    WRITE !,"about to divide by zero"
    SET a=7/0
    WRITE !,"this should not display"
  }
  CATCH myvar {
      WRITE !,"this is the exception handler"
      WRITE !,"Error code=",myvar.Code
      WRITE !,"Error name=",myvar.Name
  }
  WRITE !,"this is where the code falls through"
The following example shows a CATCH invoked by the THROW command. The myvar
argument receives a user-defined exception object:

  TRY {
    SET total=1234
    WRITE !,"Throw an exception!"
    THROW ##class(Sample.MyException).%New("Example Error",45)
    WRITE !,"this should not display"
  }
  CATCH myvar {
      WRITE !,"this is the exception handler"
      WRITE !,"Error code=",myvar.Code
      WRITE !,"Error name=",myvar.Name
  }
  WRITE !,"this is where the code falls through"
See Also

  • THROW command
  • TRY command
  • ZBREAK command
  • Error Processing in Using Caché ObjectScript


 #}}}
*CLOSE*  #{{{

Shuts down a device.
Synopsis

CLOSE:pc closearg,...
C:pc closearg,...

where closearg is :

device:parameters

Arguments

pc          Optional  A postconditional expression.

device      The device to be closed.

parameters  Optional  A list of parameters used to set characteristics of the
            device.

Description
CLOSE device releases ownership of the specified device, optionally sets
certain device characteristics, and returns it to the pool of available
devices. If the process does not own the specified device, the system ignores
the CLOSE.
Arguments
pc
An optional postconditional expression. Caché executes the CLOSE command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
device
The device to be closed. It is required and can be specified as a single device
ID or as a comma-separated list of device IDs. Specify the same device ID
(mnemonic or number) as specified on the corresponding OPEN command. For more
information on specifying device IDs, refer to the OPEN command.
The device ID of the current device is contained in the $IO special variable.
parameters
A colon-separated list of parameters used to set certain characteristics of the
specified device. The available parameters are as follows:

"D"          closes and deletes a sequential file

"R":newname  closes and renames a sequential file

Refer to RMS and Sequential File I/O in the Caché I/O Device Guide for further
information.
Examples
In the following UNIX example, the CLOSE command closes device C (/dev/tty02),
but only if it is not the current device. The postconditional uses the $IO
special variable to check for the current device.

CloseDevC
  SET C="/dev/tty02"
  OPEN C
    ; ...
  CLOSE:$IO'=C C

Notes
Acquiring Ownership of a Device
A process acquires ownership of a device with the OPEN command and makes it
active with the USE command. If the closed device is the active (that is,
current) device, the default I/O device becomes the current device. (The
default I/O device is established at login.) When a process is terminated (for
example, after a HALT), all its opened devices are automatically closed and
returned to the system.
If the process’s default device is closed, any subsequent output (such as error
messages) to that device causes the process to hang. In this case, you must
explicitly reopen the default device.
See Also

  • OPEN command
  • I/O Devices and Commands in Caché I/O Device Guide


 #}}}
*CONTINUE*  #{{{

Jumps to FOR, WHILE, or DO WHILE command and re-executes test and loop.
Synopsis

CONTINUE:pc

Argument

pc  Optional  A postconditional expression.

Description
The CONTINUE command is used within the code block following a FOR, WHILE, or
DO WHILE command. CONTINUE causes execution to jump back to the FOR, WHILE, or
DO WHILE command. The FOR, WHILE, or DO WHILE command evaluates its test
condition, and, based on that evaluation, re-executes the code block loop.
Thus, the CONTINUE command has exactly the same effect on execution as reaching
the closing curly brace ( } ) of the code block.
CONTINUE takes no arguments (other than the postconditional). At least two
blank spaces must separate it from a command following it on the same line.
A CONTINUE can cause execution to jump out of a TRY or CATCH block to return to
its control flow statement.
Arguments
pc
An optional postconditional expression that can make the command conditional.
Caché executes the CONTINUE command if the postconditional expression is true
(evaluates to a nonzero numeric value). Caché does not execute the command if
the postconditional expression is false (evaluates to zero). For further
details, refer to Command Postconditional Expressions in 
Using Caché ObjectScript.
Examples
The following example uses a CONTINUE with a postconditional expression. It
loops through and prints out all the numbers from 1 to 10, except 3:

Loop
  FOR i=1:1:10 {
    IF i # 2 {
      CONTINUE:i=3
      WRITE !,i," is odd" }
    ELSE { WRITE !,i," is even" }
    }
  WRITE !,"done with the loop"
  QUIT
The following example shows two nested FOR loops. The CONTINUE jumps back to
the FOR in the inner loop:

Loop
  FOR i=1:1:3 {
    WRITE !,"outer loop: i=",i
    FOR j=2:2:10 {
      WRITE !,"inner loop: j=",j
      IF j '= 8 {CONTINUE  }
      ELSE { WRITE " crazy eight"}
      }
    WRITE !,"back to outer loop"
  }
  QUIT
The following example shows a CONTINUE that exits a TRY block. The CONTINUE
jumps back to the FOR statement outside the TRY block.

TryLoop
  FOR i=1:1:10 {
  WRITE !,"Top of FOR loop"
    TRY {
    WRITE !,"In TRY: i=",i
    IF i=7 {
      WRITE " lucky seven" }
      ELSE { CONTINUE }
    }
    CATCH {
      WRITE !,"Found an error"
    }
    WRITE !,"Bottom of the FOR loop"
  }
  QUIT
See Also

  • DO WHILE command
  • FOR command
  • WHILE command


 #}}}
*DO*  #{{{

Calls a routine.
Synopsis

DO:pc doargument,...
D:pc doargument,...

where doargument is:

entryref(param,...):pc

Arguments

pc        Optional  A postconditional expression.

entryref  Optional  The label name of the routine to be called.

param     Optional  Parameter values to be passed to the called routine.

Description
The DO command and the DO WHILE command are separate and unrelated commands.
This page documents the DO command. In the DO WHILE command, the DO keyword and
the WHILE keyword may be separated by several lines of code; however, you can
immediately identify a DO WHILE command because the DO keyword is followed by
an open curly brace.
The DO command has two forms:

  • Without an argument
  • With an argument

DO without an argument calls the next inner routine in a block structure. That
is, Caché executes the block of code that immediately follows the DO command,
then executes the next command after that block of code.
Note:
DO without an argument uses an older block structure syntax that has been
superseded by the curly brace block structure. Therefore, DO without an
argument is considered obsolete and should only be used to maintain existing
applications and should not be used in new code.
DO with an argument calls a specified object method, subroutine, function, or
procedure. Caché executes this block of code, then executes the next command
after the DO command. You can call the routine with or without parameter
passing.
The DO command cannot accept a return value from the called routine. If the
called routine concludes with an argumented QUIT, the DO command completes
successfully, but ignores the QUIT value.
DO can be used to call a $ZUTIL function when the return value may be ignored.
For example: DO $ZUTIL(4,360),$ZUTIL(4,796) to end terminal processes 360 and
796 and close the terminal windows.
Each invocation of DO places a new context frame on the call stack for your
process. The $STACK special variable contains the current number of context
frames on the call stack. This context frame establishes a new execution level,
incrementing $STACK and $ESTACK, and providing scope for NEW and SET $ZTRAP
operations issued during the DO operation. Upon successful completion, DO
decrements $STACK and $ESTACK and reverts NEW and SET $ZTRAP operations.
Arguments
pc
An optional postconditional expression. If the postconditional expression is
appended to the DO command keyword, Caché executes the DO command if the
postconditional expression is TRUE (evaluates to a nonzero numeric value).
Caché does not execute the DO command if the postconditional expression is
FALSE (evaluates to zero).
If the postconditional expression is appended to an argument, Caché executes
the argument if the postconditional expression is TRUE (evaluates to a nonzero
numeric value). If the postconditional expression is FALSE (evaluates to zero),
Caché skips that argument and proceeds to evaluate the next argument (if there
is one) or the next command. Note that because Caché processes expressions from
left to right, any parts of the argument containing expressions (such as a
parameter value or an object reference) is evaluated and can cause an error
before the postconditional expression is evaluated. If DO invokes an object
method with an appended postconditional, the maximum number of object method
parameters is 253.
For further details, refer to Command Postconditional Expressions in 
Using Caché ObjectScript.
entryref
The name of the routine (Object Method, Subroutine, Procedure, or Extrinsic
Function) to be called. You can specify multiple routines as a comma-separated
list.
entryref can take any of the following forms.

         Specifies a line label within the current routine. The optional 
         +offset can only be used when calling a subroutine to which no
label+   parameters are passed; it cannot be used when calling a procedure or
offset   when passing parameters to a subroutine. offset is a nonnegative
         integer that specifies the number of lines after the label at which
         execution of the subroutine is to start.

label+   Specifies a line label within the named routine that resides on disk.
offset^  Caché loads the routine from disk and begins execution at the
routine  indicated label. The +offset is optional.
 

         Specifies a routine that resides on disk. The system loads the routine
^        from disk and begins execution at the first executable line of the
routine  routine. A routine located in another namespace can be specified using
         an extended global reference.

         Specifies an object method. The system accesses the object and
         executes the specified method, passing the arguments (if any)
         specified in param, the method’s argument list. Object calls use dot
oref.    syntax: oref (the object reference) and Method() are separated by a
Method   dot; blank spaces are not permitted. A method must specify its open
()       and close parentheses, even if there are no param arguments.
         The following syntactic forms are supported: DO oref.Method(), 
         DO (oref).Method(), DO ..Method(), DO $ZOBJVAL(or,slot).Method(), 
         DO ##class(cname).Method().

If you specify a nonexistent label, Caché issues a <NOLINE> error message. If
you specify a nonexistent routine, Caché issues a <NOROUTINE> error message. If
you specify a nonexistent method, Caché issues a <METHOD DOES NOT EXIST> error
message. For further details on these errors, refer to the $ZERROR special
variable.
If you specify an offset that points to the middle of a multi-line statement,
Caché starts execution at the beginning of the next statement.
param
Parameter values to be passed to the subroutine, procedure, extrinsic function
or object method. You can specify a single param value, or a comma-separated
list of param values. A param list is enclosed in parentheses. When no param is
specified, the enclosing parentheses are required when calling a procedure or
extrinsic function, optional when calling a subroutine. Parameters can be
passed by value or by reference. The same call can mix parameters passed by
value and parameters passed by reference. When passing by value, you can
specify a parameter as a value constant, expression, or unsubscripted local
variable name. (See Passing By Value.) When passing by reference, the
parameters must reference the name of a local variable or unsubscripted array
in the form .name (See Passing By Reference.)
The Argumentless DO Command
The argumentless DO command executes a block of code that immediately follows
it in the same program. Argumentless DO blocks can be nested, and a
postconditional expression on the DO command can be used to determine whether
or not to execute a code block.
The block structures provided by the IF, FOR, DO WHILE, and WHILE commands are
a preferable means to perform the same operations. The argumentless DO command
continues to be supported, but its use in new coding is discouraged. Note that 
DO establishes a new execution level; DO WHILE and the other block structure
commands do not change execution level. For further details, see Argumentless
DO (legacy version).
The DO Command with Arguments
The DO command with entryref arguments invokes the execution of one or more
blocks of code that are defined elsewhere. Each block of code to execute is
specified by its entryref. The DO command can specify multiple blocks of code
to execute as a comma-separated list. The execution of the DO command, and the
execution of each entryref in a comma-separated list can be governed by
optional postconditional expressions.
DO can invoke the execution of a subroutine (with or without parameter
passing), a procedure, or an extrinsic function. Upon completion of the
execution of the block of code, execution resumes at the next command after the
DO command. A block of code invoked by the DO command cannot return a value to
the DO command; any value returned is ignored. Thus DO can execute an extrinsic
function, but cannot receive the return value of that function.
You can specify a $CASE function as a DO command argument.
The DO Command without Parameter Passing
The DO command without parameter passing is only used with subroutines. Use of 
DO entryref without parameter passing (that is, without specifying the param
option) takes advantage of the fact that a calling routine and its called
subroutine share the same variable environment. Any variable updates made by
the subroutine are automatically available to the code following the DO
command.
When using DO without parameter passing, you must make sure that both the
calling routine and the called subroutine reference the same variables.
Note:
Procedures handle variables entirely differently. Refer to Procedures in 
Using Caché ObjectScript.
In the following example, Start (the calling routine) and Exponent (the called
subroutine) share access to three variables: num, powr, and result. Start sets 
num and powr to the user-supplied values. These values are automatically
available to Exponent when it is called by the DO command. Exponent references 
num and powr and places the calculated value in result. When Exponent executes
the QUIT command, control returns to the WRITE command immediately after the DO
. The WRITE command outputs the calculated value by referencing result.

Start  ; Raise an integer to a specified power.
  READ !,"Integer= ",num QUIT:num=""
  READ !,"Power= ",powr QUIT:powr=""
  DO Exponent
  WRITE !,"Result= ",result!
  QUIT
Exponent
  SET result=num
  FOR i=1:1:powr-1 { SET result=result*num }
  QUIT

In the following example, DO invokes the Admit() method on the object referred
to by pat. The method does not receive parameters or return a value.

   DO pat.Admit()

In the following example, the DO command calls, in succession, the subroutines
Init and Read1 in the current routine and the subroutine Convert in routine
Test.

   DO Init,Read1,Convert^Test

DO and GOTO
The DO command can be used to invoke a subroutine (with or without parameter
passing), a procedure, or an extrinsic function. At the completion of the call,
Caché executes the next command following the DO command.
The GOTO command can only be used to invoke a subroutine without parameter
passing. At the completion of the call, Caché issues a QUIT, ending execution.
DO with Parameter Passing
When used with parameter passing, DO entryref explicitly passes one or more
values to the called subroutine, procedure, extrinsic function or object
method. The passed values are specified as a comma-separated list with the 
param option. With parameter passing, you must make sure that the called
subroutine is defined with a parameter list. The subroutine definition takes
the form:
>label( param)
where label is the label name of the subroutine, procedure, extrinsic function
or object method, and param is a comma separated list of one or more
unsubscripted local variable names. For example,

Main
  SET x=1,y=2,z=3
  WRITE !,"In Main ",x,y,z
  DO Sub1(x,y,z)
  WRITE !,"Back in Main ",x,y,z
  QUIT
Sub1(a,b,c)
  WRITE !,"In Sub1 ",a,b,c
  QUIT
The list of parameters passed by the DO command is known as the 
actual parameter list. The list of parameter variables defined as part of the
label of the coded routine is known as the formal parameter list. When DO calls
the routine, the parameters in the actual parameter list are mapped, by
position, to the corresponding variables in the formal parameter list. In the
above example, the value of the first actual parameter (x) is placed in the
first variable (a) of the subroutine’s formal parameter list; the value of the
second actual parameter (y) is placed in the second variable (b); and so on.
The subroutine can then access the passed values by using the appropriate
variables in its formal parameter list.
If there are more variables in the actual parameter list than there are
parameters in the formal parameter list, Caché issues a <PARAMETER> error.
If there are more variables in the formal parameter list than there are
parameters in the actual parameter list, the extra variables are left
undefined. In the following example, the formal parameter c is left undefined:

Main
  SET x=1,y=2,z=3
  WRITE !,"In Main ",x,y,z
  DO Sub1(x,y)
  WRITE !,"Back in Main ",x,y,z
  QUIT
Sub1(a,b,c)
  WRITE !,"In Sub1 "
  IF $DATA(a) {WRITE !,"a=",a}
     ELSE {WRITE !,"a is undefined"}
  IF $DATA(b) {WRITE !,"b=",b}
     ELSE {WRITE !,"b is undefined"}
  IF $DATA(c) {WRITE !,"c=",c}
     ELSE {WRITE !,"c is undefined"}
  QUIT
You can specify a default value for a formal parameter, to be used when no
actual parameter value is specified.
You can leave any variable undefined by omitting the corresponding parameter
from the DO command’s actual parameter list. However, you must include a comma
as a place holder for each omitted actual parameter. In the following example,
the formal parameter b is left undefined:

Main
  SET x=1,y=2,z=3
  WRITE !,"In Main ",x,y,z
  DO Sub1(x,,z)
  WRITE !,"Back in Main ",x,y,z
  QUIT
Sub1(a,b,c)
  WRITE !,"In Sub1 "
  IF $DATA(a) {WRITE !,"a=",a}
     ELSE {WRITE !,"a is undefined"}
  IF $DATA(b) {WRITE !,"b=",b}
     ELSE {WRITE !,"b is undefined"}
  IF $DATA(c) {WRITE !,"c=",c}
     ELSE {WRITE !,"c is undefined"}
  QUIT
The DO command can pass parameters either by value (for example, DO Sub1(x,y,z)
) or by reference (for example, DO Sub1(.x,.y,.z)). You can mix passing by
value and passing by reference within the same DO command. For further details,
refer to Parameter Passing in Using Caché ObjectScript.
DO with Indirection
You can use indirection to supply a target subroutine location for DO. For
example, you might implement a generalized menu program by storing the various
menu functions at different locations in a separate routine. In your main
program code, you could use name indirection to provide the DO command with the
location of the function corresponding to each menu choice.
You cannot use indirection with Caché object dot syntax. This is because dot
syntax is parsed at compile time, not at runtime.
In name indirection, the value of the expression to the right of the
indirection operator (@) must be a name (that is, a label or a routine name).
In the following code segment, name indirection supplies the DO with the
location of a target function in the routine Menu.

  READ !,"Enter the number for your choice: ",num QUIT:num=""
  DO @("Item"_num)^Menu

The DO command invokes the subroutine in Menu whose label is Item concatenated
with the user-supplied num value (for example, Item1, Item2, and so on).
You can also use the argument form of indirection to substitute the value of an
expression for a complete DO argument. For example, consider the following DO
command:

   DO @(eref_":fstr>0")

This command calls the subroutine specified by the value of eref if the value
of fstr is greater than 0.
For more information, refer to Indirection in Using Caché ObjectScript.
DO with Argument Postconditionals
You can use argument postconditional expressions to select a target subroutine
for a DO command. If the postconditional expression evaluates to FALSE (0),
Caché ignores the associated subroutine call. If the postconditional expression
evaluates to TRUE (1), Caché executes the associated subroutine call, then
returns to the DO command. You can use postconditionals on both the DO command
and on its arguments.
For example, consider the command:

   DO:F>0 A:F=1,B:F=2,C

The DO command has a postconditional expression; if F is not greater than 0, no
part of the DO is executed. The DO command’s arguments also have
postconditional expressions. DO uses these argument postconditionals to select
which subroutine(s) (A, B, or C) to execute. All subroutines that fulfill the
truth condition are executed, in the order presented. Thus, in the above
example, C, with no postconditional, is always executed: if F=1 both A and C
are executed; if F=2, B and C are executed; if F=3 (or any other number) C is
executed. To establish C as a true default, do the following:

   DO:F>0 A:F=1,B:F=2,C:((F'=1)&&(F'=2))

In this example, one and only one subroutine is executed.
In the following example, the DO command takes a postconditional, and each of
its arguments also takes a postconditional. In this case, the first argument is
not executed, because its postconditional is 0. The second argument is executed
because its postconditional is 1.

Main
  SET x=1,y=2,z=3
  WRITE !,"In Main ",x,y,z
  DO:1 Sub1(x,y,z):0,Sub2(x,y,z):1
  WRITE !,"Back in Main ",x,y,z
  QUIT
Sub1(a,b,c)
  WRITE !,"In Sub1 ",a,b,c
  QUIT
Sub2(d,e,f)
  WRITE !,"In Sub2 ",d,e,f
  QUIT
Most Object (oref) methods invoked by DO can take an argument postconditional.
However, $SYSTEM object methods cannot take an argument postconditional.
Attempted to do so generates a <SYNTAX> error.
Note that because Caché evaluates expressions in strict left-to-right order, an
argument that contains expressions is evaluated (and can generate an error)
before Caché evaluates the argument postconditional.
When using argument postconditionals, make sure there are no unwanted side
effects. For example, consider the following command:

   DO @^Control(i):z=1

In this case, ^Control(i) contains the name of the subroutine to be called if
the postconditional z=1 tests TRUE. Whether or not z=1, Caché evaluates the
value of ^Control(i) and resets the current global naked indicator accordingly.
If z=1 is FALSE, Caché does not execute the DO. However, it does reset the
global naked indicator just as if it had executed the DO. For more details on
the naked indicator, see Naked Global Reference in Using Caché Globals.
For more information on how postconditional expressions are evaluated, see
Command Postconditional Expressions in Using Caché ObjectScript.
$TEST Behavior with DO
Argumentless DO always preserves the value of the $TEST special variable.
When you use DO to call a procedure, Caché preserves the value of $TEST by
restoring it to its state at the time of the call upon quitting the procedure.
However, when you use DO to call a subroutine (either with or without parameter
passing), Caché does not preserve the value of $TEST across the call.
To save the $TEST value across a DO call, you can explicitly assign it to a
variable before the call. You can then reference the variable in code that
follows the call.
The following code illustrates some unexpected $TEST behavior that can result
when using DO with the legacy IF command (which sets $TEST). This behavior does
not occur with the standard (code block) IF command, because the standard IF
does not set $TEST.

Start ; This routine uses the legacy IF command syntax
  SET x=1
  IF x=1 DO Sub1(x) ; sets $TEST to TRUE (1)
  ELSE  DO Sub2(x)
  QUIT
Sub1(y)  ; a subroutine that evaluates a FALSE IF
  WRITE !,"hello from subroutine 1"
  IF y=2 WRITE " - IF in Sub1 was TRUE" ; Set $TEST to FALSE (0)
  ELSE  WRITE " - IF in Sub1 was FALSE"
  QUIT
Sub2(z)  ; another subroutine
  WRITE !,"hello from subroutine 2"
  QUIT

At first glance, you might expect that Start will call only Sub1 and then exit.
In fact, execution of this code produces the following:

USER>DO ^Start
hello from subroutine 1 - IF in Sub1 was FALSE
hello from subroutine 2

This unexpected behavior results from the fact the $TEST value is reset in
Sub1, that causes Caché to execute the ELSE command in Start. The processing
sequence is as follows:

 1. Caché evaluates the IF command expression in Start as TRUE. It sets $TEST
    to TRUE and calls Sub1.
 2. Caché evaluates the IF command expression in Sub1 as FALSE. It sets $TEST
    to FALSE and then executes the following ELSE command.
 3. Caché returns to Start when it encounters the QUIT.
 4. Caché executes the ELSE in Start and performs the DO call to Sub2. It
    executes the ELSE because $TEST was set to FALSE in Sub1, replacing the
    TRUE value set by the IF command in Start.
    To produce the expected behavior, you could replace the ELSE in either
    Start or Sub1 with an additional IF. For example, you might recast Start as
    follows:
   
    Start
      SET x=1
      IF x=1 DO Sub1(x)
      IF x'=1 DO Sub2(x)
      QUIT

See Also

  • GOTO command
  • XECUTE command
  • NEW command
  • QUIT command
  • Argumentless DO (legacy version) command
  • IF (legacy version) command
  • $CASE function
  • $ESTACK special variable
  • $STACK special variable
  • Subroutines in Using Caché ObjectScript
  • Procedures in Using Caché ObjectScript
  • Parameter Passing in Using Caché ObjectScript


 #}}}
*DO (legacy version)*  #{{{

Argumentless: executes the block of code that immediately follows it in the
same program.
Synopsis

DO:pc
. blockcommand
. blockcommand
nextcommand

Arguments

pc            Optional  A postconditional expression.

              One or more Caché ObjectScript commands executed as a code block.
blockcommand  Note the presence of a period (.) prefix before each command in
              this block. Comments and blank lines must also have a period
              prefix.

              The next Caché ObjectScript command following the DO code block.
nextcommand   This is the first line of code after the argumentless DO that is
              not prefixed by a period.

Description
Note:
This page describes the legacy argumentless DO command. The argumentless
version of the DO command is considered legacy as of Caché 4.0, and should not
be used in new programming. It is described here solely for compatibility with
legacy applications.
The legacy argumentless DO command uses a period prefix to group lines of code
together into an code block. Curly braces are not used and line formatting is
restrictive. This syntax has been superseded by the curly brace syntax.
Argumentless DO is no longer needed within IF or FOR commands, and the DO:pc
operation has been superseded by the block-structured IF command. This syntax
is not compatible with curly brace syntax; therefore, current Caché block
structure commands such as IF and FOR that use curly brace syntax may not be
used within an argumentless DO code block.
The argumentless DO command executes a block of code that immediately follows
it in the same program. Argumentless DO blocks can be nested, and a
postconditional expression on the DO command can be used to determine whether
or not to execute a code block.
Caché executes the block of code that immediately follows the DO command, then
executes the next command after that block of code.
The lines of code executed by an argumentless DO must be written using a
special block structure syntax. This syntax uses periods (.) at the beginning
of code lines. This block structure syntax is used only with the argumentless 
DO command.
You can specify the argumentless DO with a postconditional expression. If the
postconditional expression tests FALSE (0), Caché skips the immediately
following block of code (and any nested blocks of code within it) and continues
execution at the same line level as the DO command.
Argumentless DO Block Structure
Because block structures immediately follow argumentless DO commands, you can
use them to make your programs easier to read and maintain. As a rule, you
should consider using block structures to replace short routines that are
called only once and that might otherwise be spread throughout your code. The
placement of block structures after their related DO commands makes it easier
to find them. The obvious levels of the structures themselves make it easier to
read the code.
A block structure consists of one or more blocks of code, with each block
consisting of one or more lines on the same level of nesting. All of the lines
on a given level are distinguished by having the same number of periods (.) as
prefix to the line of code.
Code Block Syntax
Periods used to indicate the lines belonging to a code block take the following
syntax:

  • The argumentless DO command should be the last command on its code line. It
    may be followed, after one or more whitespace characters, by a comment
    indicator character (; or //) on the same line.
  • The code line immediately following the argumentless DO command, and every
    line within the block of code must have a period prefix, even if it is a
    comment line or a blank line.
  • The periods must prefix the code line. Therefore, no commands or comments
    may appear before the periods or between the periods on a code line.
  • The period must be indented. That is, it cannot be in the first column of
    the code line. Usually, the initial period is indented to the same level as
    the code line containing the argumentless DO command.
  • Nested code blocks mark each level of nesting by using additional prefix
    periods. To indicate nesting, place the first period at the level of the
    code line containing the outermost DO, and indent with additional periods
    for each additional level of nesting.
  • A code block cannot contain labels. It can contain comment lines and blank
    lines, but these lines must be prefixed by a period, following the same
    rules as code lines.
  • A period must be followed by at least one whitespace character (a blank
    space or tab).
  • This space character must be followed by either a command keyword, another
    prefix period (.), a comment indicator (; or //), or a line return.
    Therefore, line breaks within a command should not be used with this
    syntax.
  • Period prefix code blocks should not be combined with code blocks
    delineated by curly braces.

Nesting
Period prefix code blocks can be nested within each other. Because the lines
belonging to a given code block all have the same number of prefix periods, you
can easily visually distinguish the contents of each block.
When viewed in a listing, the lines in nested code blocks appear indented
relative to each other. For example, the lines in an inner block contain one
more prefix period character than the lines in the outer block that contains
it.
When a block ends, as indicated by a line at with fewer prefix periods than the
current line, Caché ObjectScript issues an implicit QUIT that exits the block
of code, and resumes execution at the previous level. You can code an explicit 
QUIT command as the last line of the block, but it is not necessary.
Variables
All code blocks share the same local variables. Therefore, you can supply a
value to an inner block by setting a variable before invoking that code block
level. Similarly, any results from the execution of an inner block can be
preserved at the next higher level by changing the values of shared local
variables.
The $TEST special variable is handled differently by argumentless DO, than by a
DO command calling a subroutine or procedure. The argumentless DO preserves the
initial value of $TEST during execution of its code block. If the block
includes a command (such as a legacy IF command, or a timed OPEN) that resets
the value of $TEST, this change is not passed back to the next higher level.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
blockcommand
One or more Caché ObjectScript commands executed as a code block. Each 
blockcommand line (including comments and blank lines) must be prefixed by one
or more periods, as specified in the Code Block Syntax.
Examples
Note:
Note that the following examples use the legacy versions of the IF and FOR
commands. Commands that delineate a block of code using curly braces (such as
the current version of IF and FOR) do not need to use the argumentless DO, and
are not compatible with period prefix syntax.
In the following example, the two argumentless DO commands each invoke a block
of code. Which DO is executed and, consequently, which block is invoked depends
on which operation the user requests, as determined by the IF command. In each
case, the result is passed back to the WRITE command through the same shared
local variable. The first block (which calculates the square of an integer)
contains an implicit QUIT while the second block (which calculates the cube of
an integer) contains an explicit QUIT.

Start   ; Square or cube an integer.
  READ !,"Square (S) or cube (C): ",op QUIT:op=""
  READ !,"Integer: ",num QUIT:num=""
  IF (op["S")!(op["s") DO
  .  SET result=num*num            ; Square block
  .  WRITE !,"Result: ",result
  ELSE  DO
  .  SET result=num*num*num        ; Cube block
  .  WRITE !,"Result: ",result
  .  QUIT
  GOTO Start

In the following example, the argumentless DO repeatedly executes the code
block until the FOR control variable (i) equals the value of y.

  FOR i=1:1:y DO
  .  SET z=z*x
  .  WRITE !,z
  .  QUIT

The following example shows nested code blocks in Caché ObjectScript, using
implicit QUIT commands to end each block.

MyRoutine ; Routine label
  WRITE !,"At top level" ; Mainline code (Level count = 0)
  DO
  . ; Outermost block (Level count = 1)
  .
  .  DO
  .  . ; Inner block 1 (Level count = 2)
  .  .
  .  .  DO
  .  .  . ; Inner block 2 (Level count = 3)
  .  .  .
  .  . ; (Level count = 2)
  . ; (Level count = 1)
  .
  .  QUIT ; (Level count = 0)
  WRITE !,"Back at top level" ; Mainline code resumes

As shown in the preceding example, the first argumentless DO begins execution
of the lines in the outermost block of code. Caché ObjectScript saves the line
level at which the DO resides. If Caché ObjectScript encounters subsequent
argumentless DO commands, it executes the next inner block of code and
increments the line level by one for each such command. When it finds an
implicit or explicit QUIT in a block, Caché ObjectScript decrements the line
level count by one and continues execution at the command that follows the DO
for that block.
See Also

  • DO command
  • $TEST special variable


 #}}}
*DO WHILE*  #{{{

Executes code while a condition exists.
Synopsis

DO {code} WHILE expression,...

Arguments

code        A block of Caché Objectscript commands enclosed in curly braces.

expression  A test condition expression.

Description
DO WHILE executes code, then evaluates expression. If expression evaluates to
TRUE, DO WHILE loops and re-executes code. If expression is not TRUE, code is
not re-executed, and the next command following DO WHILE is executed.
Note that DO WHILE is always written in block-oriented form. The code to be
executed is placed between the DO and the WHILE keywords, and is enclosed by
curly braces. There are no whitespace requirements before or after a curly
brace.
DO WHILE (unlike the unrelated DO command) does not create a new execution
level. Commands that are sensitive to the execution level, such as NEW and 
SET $ZTRAP, that are invoked during the DO WHILE loop remain in effect after
the loop concludes.
Arguments
code
A block of one or more Caché ObjectScript commands. The code block may span
several lines. The code block is enclosed by curly braces. The commands and
comments within the code block and arguments within commands may be separated
from one another by one or more blank spaces and/or line returns. However, as
in all Caché ObjectScript commands, each command keyword must be separated from
its first argument by exactly one space.
expression
A test condition which can take the form of a single expression or a
comma-separated list of expressions. For an expression list, Caché evaluates
the individual expressions in left to right order. It stops evaluation if it
encounters an expression that is FALSE. If all expressions evaluate to TRUE,
Caché re-executes the code commands. DO WHILE executes repeatedly, testing 
expression for each loop. If any expression evaluates to FALSE, Caché ignores
any remaining expressions, and does not loop. It executes the next command
after DO WHILE.
Examples
The following examples show first a DO WHILE in which expression is TRUE, and
then a DO WHILE in which expression is FALSE. When expression is FALSE, the
code block is executed once.

DoWhileTrue
   SET x=1
   DO {
     WRITE !,"Looping",x
     SET x=x+1
   } WHILE x<10
   WRITE !,"DONE"
This program writes Looping1 through Looping9 and then DONE.

DoWhileFalse
   SET x=11
   DO {
      WRITE !,"Looping",x
      SET x=x+1
   } WHILE x<10
   WRITE " DONE"
This program writes Looping11 DONE.
Notes
DO WHILE and WHILE
The DO WHILE command executes the loop once and then tests expression. The 
WHILE command tests expression before executing the loop.
DO WHILE and CONTINUE
Within the code block of a DO WHILE command, encountering a CONTINUE command
causes execution to immediately jump back to the DO WHILE command. The DO WHILE
command then evaluates its expression test condition, and, based on that
evaluation, determines whether to re-execute the code block loop. Thus, the 
CONTINUE command has exactly the same effect on execution as reaching the
closing curly brace of the code block.
QUIT and GOTO
The QUIT command within the code block ends the DO WHILE loop and transfers
execution to the command following the WHILE keyword, as shown in the following
example:

Testloop
   SET x=1
   DO {
      WRITE !,"looping "
      SET x=x+1
      WRITE " x=",x
      QUIT
    } WHILE x<10
    WRITE !,"done"
looping x=2 done
A GOTO command within the code block may direct execution to a tag outside the
loop, terminating the loop. A GOTO command within the code block may direct
execution to a tag within the same code block. A GOTO can be used to exit a
nested code block. Other uses of GOTO, though supported, are not recommended.
The following example uses GOTO to exit a DO WHILE loop:

mainloop
  DO {
      WRITE !,"In an infinite DO WHILE loop"
      GOTO tag
      WRITE !,"This should not display"
  } WHILE 1=1
  WRITE !,"This should not display"
tag
  WRITE !,"Went to tag and quit"
  QUIT
The following example uses GOTO to transfer execution within a DO WHILE loop:

mainloop ; Example of a GOTO to within the code block
  SET x=1
  DO {
      WRITE !,"In the DO WHILE loop"
      GOTO tag
      WRITE !,"This should not display"
tag
      WRITE !,"Still in the DO WHILE loop after GOTO"
      SET x=x+1
      WRITE !,"x= ",x
      } WHILE x<3
  WRITE !,"DO WHILE loop done"
See Also

  • WHILE command
  • FOR command
  • IF command
  • CONTINUE command
  • GOTO command
  • QUIT command


 #}}}
*ELSE*  #{{{

Clause of block-oriented IF command.
Synopsis

ELSE { code_block }

Refer to IF command.
Description
ELSE is not a separate command, but a clause of the block-oriented IF command.
Refer to the IF command for details.
Note:
An earlier version of the ELSE command may exist in legacy applications where
it is used with a line-oriented IF command. These commands may be recognized
because they do not use curly braces. The old and new forms of IF and ELSE are
syntactically different and should not be combined; therefore, an IF of one
type should not be paired with an ELSE of the other type.
The earlier line-oriented ELSE command could be abbreviated as E. The
block-oriented ELSE keyword cannot be abbreviated.
The ELSE keyword must be followed by an opening and closing curly brace ({) and
(}). Usually these curly braces enclose a block of code. However, an ELSE with
no code block is permissible, as in the following:

   SET x=1
Loop
   IF x=1{
          WRITE "Once only"
          SET x=x+1
          GOTO Loop
          }
   ELSE{}
   WRITE !,"All done"
There are no whitespace restrictions on the ELSE keyword.
See Also

  • IF command
  • IF (legacy version) command
  • Flow Control Commands in Using Caché ObjectScript


 #}}}
*ELSEIF*  #{{{

Clause of block-oriented IF command.
Synopsis

Refer to IF command for syntax

Description
ELSEIF is not a separate command, but a clause of the block-oriented IF
command. Refer to the IF command for details.
See Also

  • IF command


 #}}}
*FOR*  #{{{

Executes a block of code repeatedly, testing at the beginning of each loop.
Synopsis

FOR variable=forparameter,...{. . .}
F variable=forparameter,...{. . .}

where forparameter can be:

expr
start:increment
start:increment:end

Arguments

variable   Optional  A counter variable for the FOR loop.

expr       Optional  The value of variable before executing the loop commands.

start      Optional  The value of variable on the first iteration of the FOR
           loop.

increment  Optional  The value used to increment variable after each iteration
           of the FOR loop.

end        Optional  The value used to terminate the FOR loop.

Description
FOR is a block-oriented command. The block of code that constitutes the loop is
enclosed in curly braces. This block of code can contain line returns, indents,
and blank spaces as needed. When the loop concludes, execution continues with
next command after the closing curly brace. This next command may be on the
same line or on the next line.
There are no whitespace requirements before or after a curly brace.
The FOR command has two basic forms:

  • Without an argument
  • With an argument

FOR Without an Argument
FOR without an argument executes the loop code block indefinitely. Caché
repeats the commands within the curly braces until it encounters a QUIT or GOTO
command.
FOR With an Argument
The action FOR performs depends on the argument form you use.
FOR variable=expr executes the looping commands once, setting variable to the
value of expr.
FOR variable=start:increment executes the looping commands indefinitely. On the
first iteration, Caché sets variable to the value of start. Each execution of
the FOR command increments the variable value by the specified increment value.
Caché repeats the commands until it encounters a QUIT or GOTO command.
FOR variable=start:increment:end sets variable to the value of start. Caché
then executes the looping commands based on the conditions described in this
table:

         increment is positive                   increment is negative

If start > end, do not execute FOR.      If start < end, do not execute FOR.
When variable > (end-increment), or if   When variable < (end-increment), or if
Caché encounters a QUIT or GOTO          Caché encounters a QUIT or GOTO
command, stop.                           command, stop.

Caché evaluates the start, increment, and end values when it begins execution
of the loop. Any changes made to these values within the loop are ignored and
have no effect on the number of loop executions.
When the loop terminates, variable contains a value that reflects the increment
resulting from the last execution of the loop. However, variable is never
incremented beyond the maximum value specified in end.
Arguments
variable
A variable that holds the current count for the FOR loop. It is a local
variable name which holds the numeric value specified by the other arguments of
the FOR command.
expr
The numeric value Caché assigns to variable before executing the loop commands.
The value of expr can be specified as a literal or any valid expression; Caché
evaluates expr for its numeric value.
start
The numeric value Caché assigns to variable on the first iteration of the FOR
loop. The value of start can be specified as a literal or any valid expression;
Caché evaluates start for its numeric value.
increment
The numeric value Caché uses to increment variable after each iteration of the 
FOR loop. It is required if you specify start. The value of increment can be
specified as a literal or any valid expression; Caché evaluates increment for
its numeric value. increment can be an integer or a fractional number; it can
be a positive number (to increment) or a negative number (to decrement).
end
The numeric value Caché uses to terminate a FOR loop. When variable equals this
value, the FOR loop is executed one last time and then terminated. The value of
end can be specified as a literal or any valid expression; Caché evaluates end
for its numeric value.
Examples
Argumentless FOR
In the following example, demonstrating argumentless FOR, the user is prompted
repeatedly for a number that is then passed to the Calc subroutine by the DO
command. The FOR loop terminates when the user enters a null string (presses
ENTER without inputting a number), which causes the QUIT command to execute.

Mainloop
  FOR {
    READ !,"Number: ",num
    QUIT:num=""
    DO Calc(num)
  }
Calc(a)
   WRITE !,"The number squared is ",a*a
   QUIT

Using FOR variable=expr
When you specify variable=expr, Caché executes the FOR loop once. The value in 
expr can be a literal or any valid expression. If you specify an expression, it
must evaluate to a single numeric value.
In the following example, the WRITE command within the curly braces of the FOR
command executes once, with num having the value 4. It writes the number 12:

Loop
  SET val=4
  FOR num=val {
    WRITE num*3 }
  QUIT
Using FOR variable=start:increment:end
The arguments start, increment, and end specify a start, increment, and end
value, respectively. All three are evaluated as numbers. They can be integer or
real, positive or negative. If you supply string values, they are converted to
their numeric equivalents at the start of the loop.
When Caché first enters the loop, it assigns the start value to variable and
compares the variable value to the end value. If the variable value is less
than the end value (or greater than it, in the case of a negative increment
value), Caché executes the loop commands. It then updates the variable value
using the increment value. (The variable value is decremented if a negative 
increment is used.)
Execution of the loop continues until the incrementing of the variable value
would exceed the end value (or until Caché encounters a QUIT or GOTO). At that
point, to prevent variable from exceeding end, Caché suppresses variable
assignment and loop execution ends. If the increment causes the variable value
to equal the end value, Caché executes the FOR loop one last time and then
terminates the loop.
The following code executes the WRITE command repetitively to output, in
sequence, all of the characters in string1, except for the last character.
Because the end value is specified as len-1, the last character is not output.
This is because the test is performed at the top of the loop, and the loop is
terminated when the variable value (index) exceeds (not just matches) the end
value (len-1).

Stringwriteloop
  SET string1="123 Primrose Path"
  SET len=$LENGTH(string1)
  FOR index=1:1:len-1 {
    WRITE $EXTRACT(string1,index)
  }
Using FOR variable=start:increment
In this form of the FOR command there is no end value; the loop must contain a 
QUIT or GOTO command to terminate the loop.
The start and increment values are evaluated as numbers. They can be integer or
real, positive or negative. If string values are supplied, they are converted
to their numeric equivalents at the start of the loop. Caché evaluates the 
start and increment values when it begins execution of the loop. Any changes
made to these values within the loop are ignored.
When Caché first enters the loop, it assigns the start value to variable and
executes the loop commands. It then updates the variable value using the 
increment value. (The variable value is decremented if a negative increment is
used.) Execution of the loop continues until Caché encounters a QUIT or GOTO
within the loop.
The following example illustrates use of the FOR variable=start:increment form
to compute an average for a series of user supplied numbers. The
postconditional QUIT is included to terminate execution of the loop when the
user enters a null string (that is, presses ENTER without inputting a value).
When the postconditional expression (num="") tests TRUE, Caché executes the 
QUIT and terminates the loop.
The loop counter (the i variable) is used to keep track of how many numbers
have been entered. i is initialized to 0 because the counter increment occurs
after the user inputs a number. Caché terminates the loop when the user enters
a null. After the loop is terminated, the SET command references i (as a local
variable) to calculate the average.

Averageloop
  SET sum=0
  FOR i=0:1 {
    READ !,"Number: ",num
    QUIT:num=""
    SET sum=sum+num
  }
  SET average=sum/i

Further Examples of FOR with Increment Syntax
The following example of the FOR variable=start:increment form prompts the user
for a number and then passes the number and the current value of x to the Calc
subroutine invoked by the DO command. The value of x is initialized to 1 and is
incremented by 1 for each execution of the loop. The FOR loop terminates when
the user presses ENTER, which causes the QUIT command to execute.

Mainloop
  FOR x=1:1 {
    READ !,"Number: ",num
    QUIT:num=""
    DO Calc(num,x)
  }
Calc(a,b)

The following example of the FOR variable=start:increment:end form prompts the
user for a number and then passes the number to the Calc subroutine invoked by 
DO. The value of x is initialized to 1 and is incremented by 1 for each
execution of the loop. The FOR loop terminates either when the value of x would
exceed the end value (3) or when the user presses ENTER, causing the QUIT
command to execute.

Mainloop
  FOR x=1:1:3 {
    READ !,"Number: ",num
    QUIT:num=""
    DO Calc(num)
  }
Calc(a)

The following example of the FOR variable=start:increment:end form shows a FOR
loop which is never executed, since the first value of i (10) is already
greater than the end value (1) minus the increment value (1).

   WRITE !,"Before the FOR"
   FOR i=10:1:1 {
       WRITE !,"In the FOR loop, i=",i
       }
   WRITE !,"After the FOR"
The following example shows a FOR loop that executes the WRITE command 10
times, then completes with i=10.

Writeloop1
  FOR i=1:1:10 {
    WRITE i,!
  }
  WRITE "i=",i
  QUIT
The following example shows a FOR loop that executes the WRITE command 10
times, then completes with i=11.

Writeloop2
  FOR i=1:0:10 {
    WRITE i,!
    SET i=i+1
  }
  WRITE "i=",i
  QUIT
Using FOR with Multiple forparameters
A single FOR command can contain both types of parameter syntax. The following
is an example of FOR with multiple forparameters. The first forparameter is the
expr syntax. The second forparameter is the start:increment:end syntax. The two
forparameters are separated by a comma. The first time through the FOR, Caché
uses the expr syntax, and invokes the Test subroutine with x equal to the value
of y. In the second (and subsequent) iterations, Caché uses the start:increment
:end syntax. It sets x to 1, then 2, etc. On the final iteration, x=10.

Mainloop
  SET y="beta"
  FOR x=y,1:1:10 {
    DO Test
  }
  QUIT
Test
  WRITE !,"Running test number ",x
  QUIT
Incrementing with Argumentless FOR
The argumentless FOR operates the same as the FOR variable=start:increment
form. The only difference is that it does not provide a way to keep track of
the number of loop executions.
The following example shows how the previous loop counter example might be
rewritten using the argumentless FOR. The assignment i=i+1 replaces the loop
counter.

Average2loop
  SET sum=0
  SET i=0
  FOR {
    READ !,"Number: ",num QUIT:num=""
    SET sum=sum+num,i=i+1
  }
  SET average=sum/i
  WRITE !!,"Average is: ",average
  QUIT

Notes
FOR and NEW
A NEW command can affect variable. Issuing an argumentless NEW command or an
exclusive NEW command (that does not specifically exclude variable) in the body
of the FOR loop can result in variable being undefined in the new frame
context.
A NEW command that does not include variable has no effect on FOR loop
execution, as shown in the following example:

   SET a=1,b=1,c=8
   FOR i=a:b:c {
     WRITE !,"count is ",i
     NEW a,c
     WRITE " loop"
     NEW (i)
     WRITE " again"
   }
FOR and Watchpoints
You have limited use of watchpoints with FOR. If you establish a watchpoint for
the control (index) variable of a FOR command, Caché triggers the specific
watchpoint action only on the initial evaluation of each FOR command argument.
This restriction is motivated by performance considerations.
The following example contains three kinds of FOR command arguments for the
watched variable x: a range, with initial value, increment, and limit (final
value); a single value; and a range with initial value, increment, and no
limit. Breaks occur when x has the initial values 1, 20, and 50.

USER>ZBREAK *x
USER>FOR x=1:1:10,20,50:2 {SET t=x QUIT:x>69}
<BREAK>
USER 2f0>WRITE
x=1
USER 2f0>g
USER>FOR x=1:1:10,20,50:2 {SET t=x QUIT:x>69}
<BREAK>
USER 2f0>WRITE
t=10
x=20
USER> 2f0>g
USER>FOR x=1:1:10,20,50:2 {SET t=x QUIT:x>69}
<BREAK>
USER 2f0>WRITE
t=20
x=50
USER 2f0>g
USER>WRITE
t=70
x=70

FOR and CONTINUE
Within the code block of a FOR command, encountering a CONTINUE command causes
execution to immediately jump back to the FOR command. The FOR command then
increments and evaluates its arguments, and, based on that evaluation,
determines whether to re-execute the code block loop. Thus, the CONTINUE
command has exactly the same effect on execution as reaching the closing curly
brace of the code block.
Terminating a FOR Loop with QUIT or GOTO
A FOR loop is terminated by a QUIT only if the QUIT appears within the code
block. If Caché encounters a QUIT in a subroutine called by the DO command, it
terminates only the subroutine, not the FOR loop itself.
A FOR loop is terminated by a GOTO that transfers control outside of its code
block. A FOR loop is not terminated by a GOTO that transfers control within its
code block. If a GOTO exits from a subroutine called by the DO command, Caché
exits only the DO command, not the FOR loop.
See Also

  • FOR (legacy version) command
  • DO WHILE command
  • WHILE command
  • IF command
  • CONTINUE command
  • GOTO command
  • DO command
  • QUIT command


 #}}}
*FOR (legacy version)*  #{{{

Executes a command loop repeatedly, testing at the beginning of each loop.
Synopsis

FOR variable=forparameter,... command
F variable=forparameter,... command

where forparameter can be:

expr
start:increment
start:increment:end

and command is one or more Caché ObjectScript commands on the same program
line. This command (or commands) are executed repeatedly, based on the FOR
test.
Arguments

variable   Optional  A counter variable for the FOR loop.

expr       Optional  The value of variable before executing the loop commands.

start      Optional  The value of variable on the first iteration of the FOR
           loop.

increment  Optional  The value used to increment variable after each iteration
           of the FOR loop.

end        Optional  The value used to terminate the FOR loop.

Description
Note:
This page describes the legacy version of the FOR command. This version is
considered legacy as of Caché 4.0, and should not be used in new programming.
It is described here solely for compatibility with legacy applications.
The legacy FOR command is line-oriented; the loop it executes consists of
commands that follow it on the same program line. Curly braces are not used and
line formatting is restrictive. The new FOR command is block structured; the
loop it executes consists of commands found within the curly braces that follow
the FOR command. Line formatting (white space, line breaks) is unrestrictive.
The FOR command has two basic forms:

  • Without an argument
  • With an argument

FOR Without an Argument
FOR without an argument executes the command(s) that follow it on the same line
indefinitely. Caché repeats these commands until it encounters a QUIT or GOTO
command.
The FOR keyword without an argument must be separated from the command that
follows it by at least two blank spaces.
FOR With an Argument
The action FOR performs depends on the argument form you use.
FOR variable=expr executes the commands that follow it on the same line once,
setting variable to the value of expr.
FOR variable=start:increment executes the commands that follow it on the same
line indefinitely. On the first iteration, Caché sets variable to the value of
start. Each execution of the FOR command increments the variable value by the
specified increment value. Caché repeats the commands until it encounters a 
QUIT or GOTO command.
FOR variable=start:increment:end sets variable to the value of start. Caché
then executes the commands that follow it on the same line based on the
conditions described in this table:

         increment is positive                   increment is negative

If start>end, do not execute FOR. When   If start<end, do not execute FOR. When
variable > (end-increment), or if Caché  variable<(end-increment), or if Caché
encounters a QUIT or GOTO command,       encounters a QUIT or GOTO command,
stop.                                    stop.

Caché evaluates the start, increment, and end values when it begins command
execution. Any changes made to these values within the loop are ignored and
have no effect on the number of loop executions.
When the loop terminates, variable contains a value that reflects the increment
resulting from the last execution of the loop. However, variable is never
incremented beyond the maximum value specified in end.
Arguments
variable
A variable that holds the current count for the FOR loop. It is a local
variable name which holds the numeric value specified by the other arguments of
the FOR command.
expr
The numeric value Caché assigns to variable before executing the loop commands.
The value of expr can be specified as a literal or any valid expression; Caché
evaluates expr for its numeric value.
start
The numeric value Caché assigns to variable on the first iteration of the FOR
loop. The value of start can be specified as a literal or any valid expression;
Caché evaluates start for its numeric value.
increment
The numeric value Caché uses to increment variable after each iteration of the 
FOR loop. It is required if you specify start. The value of increment can be
specified as a literal or any valid expression; Caché evaluates increment for
its numeric value.
end
The numeric value Caché uses to terminate a FOR loop. When variable equals this
value, the FOR loop is executed one last time and then terminated. The value of
end can be specified as a literal or any valid expression; Caché evaluates end
for its numeric value.
Examples
Argumentless FOR
In the following example, demonstrating argumentless FOR, the user is prompted
repeatedly for a number that is then passed to the Calc subroutine by the DO
command. The FOR loop terminates when the user enters a null string (presses 
ENTER without inputting a number), which causes the QUIT command to execute.
The argumentless FOR keyword must be followed by two (or more) spaces.

FOR  READ !,"Number: ",num QUIT:num=""  DO Calc(num)

Using FOR variable=expr
When you specify variable=expr, Caché executes the FOR command(s) once. The
value in expr can be a literal or any valid expression. If you specify an
expression, it must evaluate to a single numeric value.
In the following example, the WRITE command on the line with the FOR command
executes once, with num having the value 4. It writes the number 12:

  SET val=4
  FOR num=val WRITE num*3 QUIT

Using FOR variable=start:increment:end
The arguments start, increment, and end specify a start, increment, and end
value, respectively. All three are evaluated as numbers. They can be integer or
real, positive or negative. If you supply string values, they are converted to
their numeric equivalents at the start of the loop.
When Caché first enters the loop, it assigns the start value to variable and
compares the variable value to the end value. If the variable value is less
than the end value (or greater than it, in the case of a negative increment
value), Caché executes the loop commands. It then updates the variable value
using the increment value. (The variable value is decremented if a negative 
increment is used.)
Execution of the loop continues until the incrementing of the variable value
would exceed (not just equal) the end value (or until Caché encounters a QUIT
or GOTO). At that point, to prevent variable from exceeding end, Caché
suppresses variable assignment and loop execution ends. If the increment causes
the variable value to equal the end value, Caché executes the FOR loop one last
time and then terminates the loop.
The following code executes the WRITE command repetitively to output, in
sequence, all of the characters in string1, except for the last one. Even
though the end value is specified as len-2, only the last character will be
skipped. This is because the loop is terminated only when the variable value
exceeds (not just matches) the end value.

  SET len=$LENGTH(string1)
  FOR index=1:1:len-2 WRITE $EXTRACT(string1,index)

Using FOR variable=start:increment
In this form of the FOR command there is no end value; the commands following
the FOR must contain a QUIT or GOTO command to terminate the loop. In many
cases, the FOR invokes a DO loop, which contains the QUIT or GOTO command.
The start and increment values are evaluated as numbers. They can be integer or
real, positive or negative. If string values are supplied, they are converted
to their numeric equivalents at the start of the loop. Caché evaluates the 
start and increment values when it begins execution of the loop. Any changes
made to these values within the loop are ignored.
When Caché first enters the loop, it assigns the start value to variable and
executes the loop commands. It then updates the variable value using the 
increment value. (The variable value is decremented if a negative increment is
used.) Execution of the loop continues until Caché encounters a QUIT or GOTO
within the loop.
The following example illustrates use of the FOR variable=start:increment form
to compute an average for a series of user-supplied numbers. The
postconditional QUIT is included to terminate execution of the loop when the
user enters a null string (that is, presses ENTER without inputting a value).
When the postconditional expression (num="") tests TRUE, Caché executes the 
QUIT and terminates the DO loop.
The loop counter (the i variable) is used to keep track of how many numbers
have been entered. i is initialized to 0 because the counter increment occurs
after the user inputs a number. Caché terminates the loop when the user enters
a null. After the loop is terminated, the SET command references i (as a local
variable) to calculate the average.

  SET sum=0
  FOR i=0:1 DO Averageloop
  SET average=sum/i
Averageloop
    READ !,"Number: ",num
    QUIT:num=""
    SET sum=sum+num

Further Examples of FOR with Increment Syntax
The following example of the FOR variable=start:increment form prompts the user
for a number and then passes the number and the current value of x to the Calc
subroutine invoked by the DO command. The value of x is initialized to 1 and is
incremented by 1 for each execution of the loop. The FOR loop terminates when
the user presses ENTER, which causes the QUIT command to execute.

  FOR x=1:1 READ !,"Number: ",num QUIT:num="" DO Calc(num,x)
Calc(a,b)

The following example of the FOR variable=start:increment:end form prompts the
user for a number and then passes the number to the Calc subroutine invoked by 
DO. The value of x is initialized to 1 and is incremented by 1 for each
execution of the loop. The FOR loop terminates either when the value of x would
exceed the end value (3) or when the user presses ENTER, causing the QUIT
command to execute.

Mainloop
  FOR x=1:1:3 READ !,"Number: ",num QUIT:num="" DO Calc(num)
Calc(a)

The following example of the FOR variable=start:increment:end form shows a FOR
loop where the WRITE command is never executed, since the first value of i (10)
is already greater than the end value (1) minus the increment value (1).

   FOR i=10:1:1 WRITE i

The following example shows a FOR loop that executes the WRITE command 10 times
then completes with i=10.

   FOR i=1:1:10 WRITE i

The following example shows a FOR loop that executes the WRITE command 10 times
then completes with i=11.

  SET i=1
  FOR i=1:0:10 WRITE i,! SET i=i+1

Using FOR with Multiple forparameters
A single FOR command can contain both types of parameter syntax. The following
is an example of FOR with multiple forparameters. The first forparameter is the
expr syntax. The second forparameter is the start:increment:end syntax. The two
forparameters are separated by a comma. The first time through the FOR, Caché
uses the expr syntax, and invokes the Test subroutine with x equal to the value
of y. In the second (and subsequent) iterations, Caché uses the start:increment
:end syntax. It sets x to 1, then 2, etc. On the final iteration, x=10.

Mainloop
  FOR x=y,1:1:10 DO Test
Test

Incrementing with Argumentless FOR
The argumentless FOR operates the same as the FOR variable=start:increment
form. The only difference is that it does not provide a way to keep track of
the number of loop executions. Two (or more) spaces are required after the FOR
keyword in an argumentless FOR command.
The following example shows how the previous loop counter example might be
rewritten using the argumentless FOR. The assignment i=i+1 replaces the loop
counter. Note the two spaces following the argumentless FOR keyword.

Average2loop
  SET sum=0
  SET i=0
  FOR  READ !,"Number: ",num QUIT:num="" SET sum=sum+num,i=i+1
  SET average=sum/i
  WRITE !!,"Average is: ",average
  QUIT

Notes
FOR and Watchpoints
You have limited use of watchpoints with FOR. If you establish a watchpoint for
the control (index) variable of a FOR command, Caché triggers the specific
watchpoint action only on the initial evaluation of each FOR command argument.
This restriction is motivated by performance considerations.
The following example contains three kinds of FOR command arguments for the
watched variable X: a range, with initial value, increment, and limit (final
value); a single value; and a range with initial value, increment, and no
limit. Breaks occur when X has the initial values 1, 20, and 50.

USER>ZBREAK *X
USER>FOR X=1:1:10,20,50:2 SET T=X QUIT:X>69
<BREAK>
USER 2f0>w
X=1
USER 2f0>g
USER>FOR X=1:1:10,20,50:2 SET T=X QUIT:X>69
<BREAK>
USER 2f0>w
T=10
X=20
USER> 2f0>g
USER>FOR X=1:1:10,20,50:2 SET T=X QUIT:X>69
<BREAK>
USER 2f0>w
T=20
X=50
USER 2f0>g
USER>w
T=70
X=70

Terminating a FOR Loop with QUIT or GOTO
A FOR loop is terminated by a QUIT only if the QUIT appears as one of the loop
commands. If Caché encounters a QUIT in a subroutine called by the DO command,
it terminates only the subroutine, not the FOR loop itself.
A FOR loop is terminated by a GOTO that appears anywhere within the loop. If a 
GOTO exits from a subroutine called by the DO command, Caché terminates both
the subroutine and the FOR loop.
See Also

  • FOR command
  • DO (legacy version) command
  • GOTO command
  • QUIT command


 #}}}
*GOTO*  #{{{

Transfers control.
Synopsis

GOTO:pc
GOTO:pc goargument,...

G:pc
G:pc goargument,...

where goargument is:

location:pc

Arguments

pc        Optional  A postconditional expression.

location  Optional  The point to which control will be transferred.

Description
The GOTO command has two forms:

  • Without an argument
  • With an argument

GOTO Without an Argument
GOTO without an argument resumes normal program execution after Caché
encounters a BREAK command in the currently executing code. You can use the
argumentless GOTO only from the programmer prompt.
The following example shows the use of an argumentless GOTO. In this example,
the first WRITE is not executed because of the <BREAK> error; issuing a GOTO
resumes execution, executing the second WRITE:

USER>WRITE "before" BREAK  WRITE "after"
<BREAK>
USER 1S0>GOTO
after
USER>

Note that there must be two spaces after the BREAK command.
GOTO With an Argument
GOTO with the argument location transfers control to the specified location. If
you specify a postconditional expression on either the command or the argument,
Caché transfers control only if the postconditional expression evaluates to 
TRUE (nonzero).
You can use GOTO location from the programmer prompt to resume at a different
location.
You can specify a $CASE function as a GOTO command argument.
Arguments
pc
An optional postconditional expression that can make the command conditional.
If the postconditional expression is appended to the GOTO command keyword,
Caché executes the GOTO command if the postconditional expression is true
(evaluates to a nonzero numeric value). Caché does not execute the GOTO command
if the postconditional expression is false (evaluates to zero). If the
postconditional expression is appended to an argument, Caché executes the
argument if the postconditional expression is true (evaluates to a nonzero
numeric value). If the postconditional expression is false (evaluates to zero),
Caché skips that argument and evaluates the next argument (if there is one) or
the next command. For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
location
The point to which control will be transferred. It is required in routine code.
It is optional from the programmer prompt. You can specify location as a single
value or as a comma-separated list of values (with postconditionals) and can
take any of the following forms:
label+offset specifies a line label within the current routine. The optional 
+offset is a nonnegative integer that specifies the number of lines after the
label at which execution is to start.
label+offset^routine specifies a line label within the named routine, which
resides on disk. Caché loads the routine from disk and continues execution at
the indicated label. The optional +offset is a nonnegative integer that
specifies the number of lines after the label at which execution is to start.
^routine specifies a routine that resides on disk. Caché loads the routine from
disk and continues execution at the first line of executable code within the
routine. If you specify a nonexistent routine, Caché issues a <NOROUTINE> error
message. For more information, refer to the $ZERROR special variable.
You can also reference location as a variable containing any of the above
forms. In this case, though, you must use name indirection. location cannot
specify a subroutine label that is defined with a formal parameter list or the
name of a user-defined function or procedure. If you specify a nonexistent 
label, Caché issues a <NOLINE> error message. For more information, refer to
Indirection in Using Caché ObjectScript.
Example
In the following example, the GOTO directs execution to one of three locations
depending on the user-supplied age value. The location is a subroutine label
that is stored in variable loc and then referenced by means of name indirection
(@loc).

mainloop
  SET age=""
  READ !,"What is your age? ",age QUIT:age=""
  IF age<30 {
    SET loc="Young" }
  ELSEIF (age>29)&(age<60) {
    SET loc="Midage" }
  ELSEIF age>59 {
    SET loc="Elder" }
  ELSE {
    WRITE "data input error"
    QUIT }
  GOTO @loc
  QUIT
Young
  WRITE !,"You're still young"
  QUIT
Midage
  WRITE !,"You're in your prime"
  QUIT
Elder
  WRITE !,"You have a lifetime of wisdom to impart"
  QUIT

Note that this type of GOTO using name indirection is not permitted from within
a procedure block.
As an alternative, you could omit the IF command and code the GOTO with a
comma-separated list using postconditionals on the arguments, as follows:

   GOTO Young:age<30,Midage:(age>29)&(age<60),Elder:age>59

You might also code this example using a DO command to call the appropriate
subroutine location. In this case, though, when Caché encounters a QUIT, it
returns control to the command following the DO.
Notes
How Control Is Transferred When QUIT is Encountered
Unlike the DO command, GOTO transfers control unconditionally. When Caché
encounters a QUIT in a subroutine called by DO, it passes control to the
command following the most recent DO.
When Caché encounters a QUIT after a GOTO transfer, it does not return control
to the command following the GOTO. If there was a preceding DO, it returns
control to the command following the most recent DO. If there was no preceding 
DO, then it returns to the programmer prompt.
In the following code sequence, the QUIT in C returns control to the WRITE
command following the DO in A:

testgoto
A
  WRITE !,"running A"
  DO B
  WRITE !,"back to A, all done"
  QUIT
B
  WRITE !,"running B"
  GOTO C
  WRITE !,"this line in B should never execute"
  QUIT
C
  WRITE !,"running C"
  QUIT
Using GOTO with Code Blocks
GOTO can be used to exit a code block, but not to enter a code block.
If you use GOTO inside a FOR, IF, DO WHILE, or WHILE loop, you can go to a 
location outside of all code blocks, a location within the current code block,
or go from a nested code block to a location in the code block that encloses
it. You cannot go from a code block to a location within another code block,
either an independent code block, or a code block nested within the current
code block. For code examples, refer to the individual commands.
A GOTO to a location outside a code block terminates the loop. A GOTO to a 
location within a code block does not terminate the loop. A GOTO from a nested
code block to an enclosing code block terminates the inner (nested) loop, but
not the outer loop.
A GOTO can be used to exit a TRY or CATCH code block, but not to enter one of
these code blocks. You also cannot specify a GOTO to a label on the same line
as the TRY or CATCH keyword. Attempting to do so results in a <NOLINE> error.
GOTO Restrictions
The following GOTO operations are not permitted:

  • GOTO should not be used to enter or exit a procedure.
  • GOTO should not be used within nested argumentless DO code blocks to jump
    between levels.
  • GOTO cannot be used with name indirection (GOTO @name) within a procedure
    block.

See Also

  • DO command
  • FOR command
  • IF command
  • DO WHILE command
  • WHILE command
  • BREAK command
  • QUIT command
  • $CASE function


 #}}}
*HALT*  #{{{

Terminates execution of the current process.
Synopsis

HALT:pc
H:pc

Argument

pc  Optional  A postconditional expression.

Description
The HALT command terminates execution of the current process. If a $HALT
special variable is defined in the current context (or a prior context),
issuing a HALT command invokes the halt trap routine specified in $HALT, rather
than terminating the current process. Typically, a halt trap routine performs
some cleanup or reporting operations, then issues a second HALT command to
terminate execution.
HALT has the same minimum abbreviation as the HANG command. HANG is
distinguished by its required hangtime argument.
Arguments
pc
An optional postconditional expression that can make the command conditional.
Caché executes the HALT command if the postconditional expression is true
(evaluates to a nonzero numeric value). Caché does not execute the command if
the postconditional expression is false (evaluates to zero). For further
details, refer to Command Postconditional Expressions in 
Using Caché ObjectScript.
Examples
In the following example, HALT allows the user to end the current application
and return to the operating system. The system performs all necessary cleanup
for the user. Note the use of the postconditional on the command.

Main
  READ !,"Do you really want to stop (Y or N)? ",ans QUIT:ans=""
  HALT:(ans["Y")!(ans="y")
  GOTO Start
Start
  WRITE !,"This is the Start routine"
  QUIT

In the following example, HALT invokes the halt trap routine specified in $HALT
. In this case, it is the second HALT command that actually halts execution:

Main
   NEW $ESTACK
   SET $HALT="OnHalt"
   WRITE !,"Main $ESTACK= ",$ESTACK   // 0
   DO SubA
   WRITE !,"this should never display"
   QUIT
SubA
   WRITE !,"SubA $ESTACK= ",$ESTACK   // 1
   HALT    // invoke the OnHalt routine
   WRITE !,"this should never display"
   QUIT
OnHalt
   WRITE !,"OnHalt $ESTACK= ",$ESTACK   // 0
   // clean-up and reporting operations
   HALT   // actually halt the current process
   QUIT
Notes
Effects of HALT
When HALT terminates a process and causes an exit from Caché, the system
automatically relinquishes all locks and closes all devices owned by the
process. This ensures that the halted process does not leave behind locked
variables or unreleased devices.
HALT behaves the same whether it is encountered in routine code or entered from
the programmer mode prompt. In either case, you must log in again to return to
Caché ObjectScript.
HALT Traps
Execution of a HALT command is interrupted by a halt trap. Halt traps are
established using the $HALT special variable.
If a halt trap has been established for the current context frame, issuing a 
HALT command invokes the halt trap routine specified by $HALT. The HALT command
itself is not executed.
If a halt trap has been established for a lower context frame, a HALT command
removes context frames from the frame stack until the context frame with the
halt trap is reached. HALT then invokes the halt trap routine specified by 
$HALT and ceases execution.
See Also

  • $HALT special variable
  • Debugging in Using Caché ObjectScript


 #}}}
*HANG*  #{{{

Suspends execution for a specified number of seconds.
Synopsis

HANG:pc hangarg
H:pc hangarg

where hangarg can be:

hangtime,...

Arguments

pc        Optional  A postconditional expression.

          The amount of time to wait, in seconds. An expression that resolves
hangtime  to a positive numeric value, or a comma-separated list of numeric
          expressions.

Description
HANG suspends the executing routine for the specified time period. If there are
multiple arguments, Caché suspends execution for the duration of each argument
in the order presented.
HANG has the same minimum abbreviation (H) as the HALT command. HANG is
distinguished by its required hangtime argument.
Arguments
pc
An optional postconditional expression. Caché executes the HANG command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
hangtime
The amount of time to wait, in seconds. This time can be expressed as any
numeric expression. You can specify whole seconds as an integer, or fractional
seconds. You can use exponentiation (**), arithmetic expressions, and other
numeric operators.
You can set hangtime to 0 (zero), in which case no hang is performed. Setting 
hangtime to a negative number or a nonnumeric value is the same as setting it
to 0.
You can specify multiple hangtime arguments as a comma-separated list, as
described below.
Examples
The following example suspends the process for 10 seconds:

   WRITE !,$ZTIME($PIECE($HOROLOG,",",2))
   HANG 10
   WRITE !,$ZTIME($PIECE($HOROLOG,",",2))
The following example suspends the process for 1/2 second. $ZTIMESTAMP, unlike 
$HOROLOG, can return fractional seconds if the precision parameter of the 
$ZTIME function is specified.

   WRITE !,$ZTIME($PIECE($ZTIMESTAMP,",",2),1,2)
   HANG .5
   WRITE !,$ZTIME($PIECE($ZTIMESTAMP,",",2),1,2)
Returns values such as the following:

14:34:19.75
14:34:20.25

Notes
How HANG Time is Calculated
The HANG time is calculated using the system clock. If the clock is midway
between seconds when a HANG with 1 second or less is executed, the actual
elapsed HANG time is only the remaining portion of the current clock time
second.
Multiple HANG Arguments
You can specify hangtime as a comma-separated list of numeric expressions.
Caché suspends execution for the duration of each argument in the order
presented. Negative numbers are treated as zero. Therefore, a hangtime of
16,-15 would hang for 16 seconds.
That each hangtime argument is separately executed can affect operations that
use the current time in hang calculations, as shown in the following example:

  SET start=$ZHOROLOG
  SET a=$ZHOROLOG+5
  HANG 4,a-$ZHOROLOG
  SET end=$ZHOROLOG
  WRITE !,"elapsed hang=",end-start
In this example, HANG first suspends execution for 4 seconds, then suspends
execution for the current time before the hang plus 5 seconds, minus the
current time when the second hang argument is parsed. Because HANG executes
each argument in turn, the total hang time in this example is (roughly) 5
seconds, rather than the (roughly) 9 seconds one might otherwise expect.
HANG Compared with Timed READ
You can use HANG to pause the routine while the user reads an output message.
However, you can handle this type of pause more effectively with a timed READ
command. A timed READ allows the user to continue when ready, but a HANG does
not because it is set to a fixed duration.
See Also

  • READ command
  • $ZTIME function
  • $HOROLOG special variable
  • $ZTIMESTAMP special variable


 #}}}
*IF*  #{{{

Evaluates an expression, then selects which block of code to execute based on
the truth value of the expression.
Synopsis

IF expression1 {
  . . .
}
ELSEIF expression2 {
    . . .
}
ELSE {
    . . .
}

or

I expression1 {
  . . .
}
ELSEIF expression2 {
    . . .
}
ELSE {
    . . .
}

Arguments

expression1  A test condition for the IF clause. A single condition or a
             comma-separated list of conditions.

expression2  A test condition for an ELSEIF clause. A single condition or a
             comma-separated list of conditions.

Description
This page describes the IF, ELSEIF, and ELSE command keywords, all of which are
considered to be component clauses of the IF command. An IF command consist of
one IF clause, followed by any number of ELSEIF clauses, followed by one ELSE
clause. The ELSEIF and ELSE clauses are optional, but it is a good programming
practice to always specify an ELSE clause.
IF is a block-oriented command. Each command keyword is followed by a block of
code enclosed in curly braces. There are no whitespace requirements before or
after a curly brace. Within these curly braces you can freely use line returns,
indents, and blank spaces as desired.
Note:
An earlier, line-oriented version of the IF command may exist in legacy
applications. This form of IF does not use curly braces or support the ELSEIF
clause. These two forms of IF are syntactically different and should not be
combined. Thus, an IF of one type should not be paired with an ELSE of the
other type. The earlier line-oriented ELSE could be abbreviated as E; the
block-oriented ELSE keyword should not be abbreviated.
The IF command evaluates expression1 and, if expression1 is TRUE, it executes
the block of commands within the curly braces that follow it, and the IF
command completes.
If expression1 is FALSE, execution jumps to the next clause of the IF
statement. It evaluates the first ELSEIF clause (if present). If expression2 in
the ELSEIF clause is TRUE, the ELSEIF code block is executed and the IF command
completes. If expression2 is FALSE, the next ELSEIF clause is evaluated. Each
successive ELSEIF clause is tested in the order listed until one of them
evaluates TRUE, or all of them evaluate FALSE.
If the IF clause and all ELSEIF clauses evaluate to FALSE, execution continues
with the ELSE clause. The ELSE clause block of code executes, and the IF
command completes. If no ELSE clause is present, the IF command completes.
Arguments
expression1
A test condition for the IF clause. It can take the form of a single expression
or a comma-separated list of expressions. For an expression list, Caché
evaluates the individual expressions in left to right order. It stops
evaluation if it encounters an expression that is FALSE. If all expressions
evaluate to TRUE, Caché executes the block of code associated with the clause.
This block of code is enclosed in curly braces. If any expression evaluates to
FALSE, Caché ignores any remaining expressions, and does not execute the block
of code associated with the clause. An IF clause list of expressions should not
be broken into multiple lines.
expression2
A test condition for an ELSEIF clause. It can take the form of a single
expression or a comma-separated list of expressions. It is evaluated the same
way as expression1.
Notes
A block-oriented IF statement does not read or set the value of the $TEST
special variable. If expression evaluates to TRUE, it executes the block of
code within the curly braces, regardless of the setting of $TEST. If expression
evaluates to FALSE, it continues execution after the block of code enclosed in
curly braces.
An IF command can consist of an IF clause, one or more optional ELSEIF clauses,
and an optional ELSE clause. Only the block of code associated with one of
these clauses can be executed. Successful execution of an IF clause or an 
ELSEIF clause completes the execution of the IF command.
IF, ELSEIF, and ELSE clauses may use white space (line returns, indents, and
blank spaces) freely. However, each IF and ELSEIF keyword and the first
character of its expression must be on the same line, separated by one blank
space. An expression can span multiple lines and contain multiple blank spaces.
IF with GOTO and QUIT
If a GOTO or QUIT is encountered within an IF code block, program execution
obeys that statement, with certain restrictions.
A GOTO statement can jump to a location outside of the IF command, or within
the code block of the current clause. A GOTO statement cannot jump into another
code block: neither a code block that belongs to another clause of the current 
IF command, nor a code block that belongs to another IF, FOR, DO WHILE, or 
WHILE command.
A QUIT command breaks out of the IF code block. However, if the IF code block
is nested within a loop structure, such as a FOR loop, the QUIT breaks out of
that loop structure as well.
Examples
In the following example, the IF command is used to categorize responders into
one of three groups for subsequent processing. The three groups are females
aged 24 or less, males aged 24 or less, and either females or males aged 25 or
more. In this example, the test expressions use the Contains operator ( [ ).
(See Operators in Using Caché ObjectScript.)

Mainloop
  NEW sex,age
  READ !,"What is your sex? (M or F): ",!,sex QUIT:sex=""
  READ !,"What is your age? ",!,age QUIT:age=""
  IF "Ff"[sex,age<25 {
    GOTO Subrta
  }
  ELSEIF "Mm"[sex,age<25 {
    GOTO Subrtb
  }
  ELSEIF "FfMm"[sex,age>24 {
    GOTO Subrtc
  }
  ELSE {
    WRITE "Invalid data value input"
  }
  QUIT
Subrta
  WRITE "Young woman"
  QUIT
Subrtb
  WRITE "Young man"
  QUIT
Subrtc
  WRITE "Older person"
  QUIT

See Also

  • DO WHILE command
  • FOR command
  • WHILE command
  • GOTO command
  • QUIT command
  • $CASE function
  • IF (legacy version) command


 #}}}
*IF (legacy version)*  #{{{

Evaluates an expression, then selects which line of code to execute based on
the truth value of the expression.
Synopsis

IF expression command1
ELSE command2

I expression command1
E command2

Arguments

expression  Optional  An expression (or a comma-separated list of expressions)
            that evaluates to a boolean value.

command1    One or more Caché commands that are executed if expression
            evaluates to TRUE, or if expression is omitted.

ELSE        One or more Caché commands that are executed if expression
command2    evaluates to FALSE. The ELSE keyword is optional.

Description
Note:
This page describes the legacy version of the IF command. This version is
considered legacy as of Caché 4.0, and should not be used in new programming.
It is described here solely for compatibility with legacy applications.
The legacy IF command is line-oriented; commands to be executed must follow it
on the same program line. Curly braces are not used and line formatting is
restrictive. The new IF command is block structured; the block it executes
consists of commands found within the curly braces that follow the IF command.
Line formatting (white space, line breaks) is unrestrictive. The new version of
IF does not use the $TEST special variable.
The old and new forms of IF and ELSE are syntactically different and should not
be combined; therefore, an IF of one type should not be paired with an ELSE of
the other type.
The IF command has two forms:
Without an argument
With an argument
IF Without an Argument
IF without an expression argument executes the commands that follow it on the
same line if the current value of the $TEST variable is TRUE (nonzero). If 
$TEST is FALSE (0), Caché ignores the remaining commands on that line and
continues execution with the next line.
IF With an Argument
IF with an expression argument executes the commands that follow it on the same
line if expression evaluates to TRUE (nonzero). (Caché also sets $TEST to
TRUE.) If expression evaluates to FALSE, Caché sets $TEST to FALSE (0), ignores
the remaining commands on that line, and continues execution with the next
line.
The next line typically begins with an ELSE keyword, followed by one or more
commands on the same line. The ELSE keyword is optional, but is a recommended
programming practice. ELSE is not a separate command, but a clause of the IF
command. This line-oriented ELSE keyword can be abbreviated as E. (The newer
block-oriented ELSE keyword cannot be abbreviated.) The old and new forms of IF
and ELSE are syntactically different and should not be combined; therefore, an 
IF of one type should not be paired with an ELSE of the other type.
The expression argument can take the form of a single expression or a
comma-separated list of expressions. For an expression list, Caché evaluates
the individual expressions in left to right order. It stops evaluation if it
encounters an expression that is FALSE. If all expressions evaluate to TRUE,
Caché executes the command(s) following the expression argument on that line.
If any expression evaluates to FALSE, Caché ignores any remaining expressions,
and does not execute the commands on that line, but continues execution at the
next line of code.
See Also

  • IF command
  • DO (legacy version) command
  • GOTO command
  • QUIT command
  • $TEST special variable


 #}}}
*JOB*  #{{{

Runs a process in background.
Synopsis

JOB:pc jobargument,...
J:pc jobargument,...

where jobargument is one of the following:
Local Jobs:

routine(routine-params):(process-params):timeout
routine(routine-params)[joblocation]:(process-params):timeout
routine(routine-params)|joblocation|:(process-params):timeout

##class(className).methodName(args):(process-params):timeout
$ZOBJCLASSMETHOD(className,methodName,args):(process-params):timeout

Remote Jobs:

routine[joblocation]:(process-params)
routine|joblocation|:(process-params)

Arguments

pc              Optional  A postconditional expression.

routine         The routine to be executed by the process created by JOB.

                Optional  A comma-separated list of parameters to pass to the
                routine. These parameters can be values, expressions, or
routine-params  existing local variable names. If specified, the enclosing
                parentheses are required. Routine parameters can only be passed
                to local jobs.

                The class method to be executed by the process created by JOB.
                Only class methods can be jobbed. The className cannot be
                $SYSTEM; it can be %SYSTEM. You cannot specify the className as
className.      a class reference (oref), you must specify a class name. A
methodName(     comma-separated list of args arguments is optional; the
args)           enclosing parentheses are required. For further details on
                using $ZOBJCLASSMETHOD, refer to the section $ZOBJ... Functions
                in the  Object-specific ObjectScript Features chapter of 
                Using Caché Objects.

                Optional  A colon-separated list of positional parameters used
                to set various elements in the job’s environment. The 
                process-params list is enclosed in parentheses and the
process-params  parenthesized list preceded by a colon. All process-params are
                optional; the parentheses are required. To indicate a
                positional parameter is missing, its colon must be present,
                though trailing colons may be omitted.

                Optional  The number of seconds to wait for the jobbed process
timeout         to start. Fractional seconds are truncated to the integer
                portion. The preceding colon is required. Timeout can only be
                specified for local jobs.

                Optional  An explicit or implied namespace used to specify the
                system and directory on which to run a remote job. An implied
                namespace is a directory path or OpenVMS file specification
joblocation     preceded by two caret characters: "^^dir". Enclose joblocation
                in either square brackets or vertical bars. You cannot specify
                a joblocation when jobbing a class method. If joblocation
                specifies a remote system, you cannot specify routine-params or
                timeout.

Description
JOB creates a separate process known as a job, jobbed process, or batch job.
The created process runs in the background, independently of the current
process, usually without user interaction. A jobbed process inherits its
configuration environment from the invoking process, except what is explicitly
specified in the JOB command. For example, a jobbed process inherits the locale
settings of the parent process, not the system default locale.
By contrast, a routine invoked with the DO command runs in the foreground as
part of the current process.
JOB can create a local process on your local system, or it can invoke the
creation of a remote process on another system. For more on remote jobs, see
Starting Remote Jobs.
When a job begins, Caché can call a user-written JOB^%ZSTART routine. When a
job ends, Caché can call a user-written JOB^%ZSTOP routine. These entry points
can be used for maintaining a log of job activity and troubleshooting problems
encontered. For further details, refer to the article Using the Caché ^%ZSTART
and ^%ZSTOP Routines.
Arguments
pc
An optional postconditional expression. Caché executes JOB if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
routine
The process to be started. It can take any of the following forms:

   Process                               Description
Specification

label          Specifies a line label within the current routine.

               Specifies a routine that resides on disk. Caché loads the
^routine       routine from disk and starts execution at the first line of
               executable code within the routine.

               Specifies a line label within the named routine, which resides
label^routine  on disk. Caché loads the routine from disk and starts execution
               at the indicated label.

label+offset   Specifies an offset of a specified number of lines from the
label+offset^  label. Use of offsets can cause problems with program
routine        maintenance, and is discouraged.

If you are within a procedure block, calling the JOB command starts a child
process that is outside the scope of the procedure block. It therefore cannot
resolve a label reference within the procedure block. Therefore, for the JOB to
reference a label within a procedure, the procedure cannot use a procedure
block.
If you specify a nonexistent label, Caché issues a <NOLINE> error. If you
specify a nonexistent routine, Caché issues a <NOROUTINE> error. For further
details on these errors, refer to the $ZERROR special variable.
routine-params
A comma-separated list of values, expressions, or existing local variable
names. The enclosing parentheses are required. This list is known as the 
actual parameter list. The routine must have a formal parameter list with the
same or a greater number of parameters. If you specify extra actual parameters,
Caché issues a <PARAMPASS> error. Note that if the invoked routine contains a
formal parameter list, you must specify the enclosing parentheses, even if you
do not pass any parameters.
You can pass routine parameters only by value, which means that you cannot pass
arrays. This is different from the DO command where you can pass parameters by
value and by reference. A special consequence of this restriction is you cannot
pass arrays with the JOB command, since they are passed only by reference.
When the routine starts, Caché evaluates any expressions and maps the value of
each parameter in the actual list, by position, to the corresponding variable
in the formal list. If there are more variables in the formal list than there
are parameters in the actual list, Caché leaves the extra variables undefined.
Routine parameters can only be passed to local processes. You cannot specify
routine parameters when creating a remote job. See Starting Remote Jobs.
process-params
A colon-separated list of positional parameters used to set various elements in
the job’s environment. The preceding colon and enclosing parentheses are
required. All of the positional parameters are optional. You can specify up to
seven positional parameters for process-params. These seven parameters are:

(nspace:switch:principal-input:principal-output:priority:os-directory:process-name)

Since the parameters are positional, you must specify them in the order shown.
If you omit a parameter that precedes a specified parameter, you must include a
colon as a placeholder for it.
The following table describes the process parameters:

    Process                                Description
   Parameter

                  The default namespace of the process. The specified routine
                  is drawn from this namespace. If you omit nspace, your
nspace            current default namespace is the default namespace of the
                  jobbing process. An invalid namespace may prevent the job
                  from starting. A remote job cannot specify namespace as a
                  process parameter; see Starting Remote Jobs for details.

                  An integer consisting of the sum of one or more of the
                  following values:
                  An integer bit mask that can represent zero or more of the
                  following flags:
                  1 - Pass the symbol table to the spawned job.
                  2 - Do not use a JOB Server.
                  4 - Pass an open TCP/IP socket to the spawned job using the
                  principal I/O device ($PRINCIPAL).
                  8 - Establish the process-specific window for two-digit years
                  of the spawned job to be the system-wide default sliding
                  window definition. Otherwise, the spawned job inherits the
switch            sliding window definition of the process issuing the JOB
                  command.
                  16 - Pass an open TCP/IP socket to the spawned job using
                  current I/O device ($IO).
                  An additional integer value that specifies a partition size
                  for the JOBbed child process. Values (in kilobytes) can range
                  from 128 through 16384 in multiples of 32. See "Specifying
                  Child Process Partition Size for more information.
                  The switch value can be the sum of any combination of these
                  integers. For example, a switch value of 13 (1+4+8) passes
                  the symbol table (1), passes the open TCP/IP socket (4), and
                  establishes a process-specific window for two-digit years
                  that is the system-wide default (8).

                  Principal input device for the process.
                  UNIX: See principal-output for default.
                  OpenVMS: The default is your current input device. If your
                  current input device is your principal device and you log
                  off, the jobbed process will be unable to issue JOB commands
principal-input   to start new processes.
                  OpenVMS: If you do not specify a principal input and output
                  device, the JOB command may not know which device to open
                  and, as a result, does not start the process. To avoid this
                  situation, you should always specify a principal input and
                  output device. If you do not require any I/O, specify the
                  null device: NL:

                  Principal output device for the process. The default is the
                  device you specify for principal-input.
                  UNIX: If you do not specify either device, the process uses
                  the default principal device for processes started with the 
                  JOB command, which is /dev/null.
principal-output  OpenVMS: If you do not specify either device, the process
                  uses your current principal input and output devices.
                  OpenVMS: If the jobbed process is using your current device
                  and you log off, the jobbed process will be unable to issue 
                  JOB commands to start new processes. If you do not require
                  any I/O, specify the null device: NL:

                  UNIX and OpenVMS  An integer that specifies the priority for
                  the child process (subject to operating system constraints).
                  If not specified, the child process takes the parent process'
                  base priority plus the system-defined job priority modifier.
priority          You can use the $VIEW function to determine the current
                  priority of a job. Windows has a Normal priority of 7.
                  OpenVMS priority ranges between 0 and 15, with 4 as Normal
                  priority. UNIX priority ranges between -20 and 20, with 0 as
                  Normal priority. In UNIX, a process cannot give itself an
                  increased priority unless running as root.

                  An operating system working directory for file I/O. The
os-directory      default is to use the working directory inherited from the
                  parent process. This parameter may be ignored on some
                  systems.

                  OpenVMS only  A specified process name for the child process.
                  May be up to 31 characters in length. The default is to use a
process-name      Caché-generated child process name. If specified, it is the
                  user’s responsibility to ensure the uniqueness of this
                  process name.

timeout
The number of seconds to wait for the jobbed process to start before timing out
and aborting the job. The preceding colon is required. You must specify timeout
as an integer value or expression. If a jobbed process times out, Caché aborts
the process and sets $TEST to FALSE (0). Execution then proceeds to the next
command in the calling routine; no error message is issued.
Timeout can only be specified for a local process.
Examples
This example starts the monitor routine in the background. If the process does
not start in 20 seconds, Caché sets $TEST to FALSE (0).

   JOB ^monitor::20
   WRITE $TEST

This example starts execution of the monitor routine at the line label named
Disp.

   JOB Disp^monitor

The following example starts the Add routine, passing it the value in variable 
num1, the value 8, and the value resulting from the expression a+2. The Add
routine must contain a formal parameter list that includes at least three
parameters.

   JOB ^Add(num1,8,a+2)

The following example starts the Add routine, which has a formal parameter
list, but passes no parameters. In this case, the Add routine must include code
to assign default values to its formal parameters, since they receive no values
from the calling routine.

   JOB ^Add()

The following example creates a process running your current routine at label
AA. The process parameters pass your current symbol table to the routine. It
can use a JOB Server.

   JOB AA:("":1)

The following OpenVMS command creates a process running the ^REPORT routine in
implied namespace, the directory [USER.TEST]. An implied namespace is a
directory path or OpenVMS file specification preceded by two caret characters: 
"^^dir". Because ^REPORT does not require input from the principal device, the
null device is specified as principal input. The file report.L is the principal
output device.

   JOB ^REPORT:("^^[USER.TEST]"::"NL:":"report.L")

This following command passes the routine parameters VAL1 and the string "DR."
to the routine ^PROG, starting at entry point ABC, in the current namespace.
The routine expects two arguments. Caché does not pass the current symbol table
to this job, it will use a JOB Server if possible, and use tta5: as principal
input and output device.

   JOB ABC^PROG(VAL1,"DR."):(:0:"tta5:")

The following examples show the jobbing of a class method, with a timeout of
ten seconds. They use tta5: as principal input and output device.
The following example uses ##class syntax to invoke a class method:

   JOB ##class(MyClass).New():(:0:"tta5:"):10

The following example uses the $ZOBJCLASSMETHOD function to invoke a class
method:

   JOB $ZOBJCLASSMETHOD(MyClass,New):(:0:"tta5:"):10

The following example uses .. syntax to refer to a method of the current
object:

   JOB ..CleanUp():10

For further details, refer to  Object-specific ObjectScript Features in 
Using Caché Objects.
Notes
Caché Assigns Job Numbers and Memory Partitions
After you start a jobbed process, Caché allocates a separate memory partition
for it and assigns it a unique job number (also referred to as a Process ID or
pid). The job number is stored in the $JOB special variable. The status of the
job (including whether or not it was started by a JOB command) is stored in the
$ZJOB special variable.
Since jobbed processes have separate memory partitions, they do not share a
common local variable environment with the process that created them or with
each other. When you start a jobbed process, you can use parameter passing (
routine-params) to pass values from the current process to the jobbed process.
If the JOB command fails, it is usually because:

  • There are no free partitions.
  • There is not enough memory to create a partition with the characteristics
    specified by process-params.

Communicating Between Jobs
Parameter passing by value can occur in only one direction and only at job
start up. For processes to communicate with each other, they must use mutually
agreed upon global variables. Such variables are commonly known as 
scratch globals because their sole purpose is to allow processes to exchange
information among themselves.
Note:
You can pass all local variables in the current process to the invoked process
by specifying a special process parameter.
Processes can also communicate through the IPC (Interprocess Communication)
devices (device numbers 224 through 255) or, on UNIX operating systems, through
UNIX pipes.
Establishing Device Ownership
Caché assumes that the invoked routine includes code (that is, OPEN and USE
commands) to handle device ownership for the new process. The default device is
the null device.
Caché does not assign a default device to any process other than the process
started at sign in.
Setting Job Priority
The %PRIO utility allows you to control the priority at which a UNIX or OpenVMS
jobbed process runs. The available options are NORMAL (uses load balancing to
adjust CPU usage), LOW, and HIGH. A jobbed process with a priority of HIGH
competes on an equal basis with interactive processes for CPU resources.
Caché also allows you to establish default priorities for jobbed processes.
Using the JOB Command in a Raw Partition (UNIX)
You can use the JOB command in a raw partition in either of two ways:

  • Issue the JOB command while in the raw partition.
  • Issue the JOB command while in another namespace, and specify the raw
    partition as the nspace process parameter of the JOB command. Here nspace
    is an implied namespace. An implied namespace is a directory path or
    OpenVMS file specification preceded by two caret characters: "^^dir".
    Implied namespace syntax is described in Global Structure in 
    Using Caché Globals.

Commands and jobbed processes running in a raw partition must always specify
the full pathname when making references to filenames, and must not use any
pathname that starts with "." or ".." , as these are special UNIX files and are
not present in a raw partition. Violating either of these rules causes a
<DIRECTORY> error.
To obtain the full pathname of the current namespace, you can issue the
following command:

   WRITE $ZUTIL(12,"")
Alternatively, you can use the UNIX batch command & instead of the Caché
ObjectScript JOB command. For example, to start a routine called Test as a
batch job in a raw disk partition, you invoke Caché as follows:
$cache "^Test" &
Receiving Remote JOB Requests with DSM-DDP
With DSM-DDP networking, Caché can accept JOB requests from a remote DSM
system. The job request contains the name of a routine to start in a particular
namespace on a particular system, in the following format:
JOB label+offset^routine:"Namespace"
The network job request does not support parameter passing.
This feature allows you to port existing server applications from DSM to Caché.
The client portion of the application can operate without change on the DSM
host.
Starting Remote Jobs
You can send a remote job from one Caché system to another using the following
syntax:

JOB routine[joblocation]:(process-params)
JOB routine|joblocation|:(process-params)

The two forms are equivalent; you can use either square brackets or vertical
bars to enclose the joblocation parameter. A remote job cannot pass routine
parameters. A remote job also cannot specify a timeout.
Process parameters are optional. However, a remote job cannot specify the first
process parameter (nspace) because this would conflict with the joblocation
parameter. Therefore, only the second, third, and fourth process parameters can
be specified, and the missing nspace parameter must be indicated by a colon.

joblocation  A specification of the location of the job. The enclosing square
             brackets or vertical bars are required.

The action Caché takes depends on the job location syntax you are using.

 joblocation                                Result
   Syntax

               Caché checks whether this explicit namespace has its default
               dataset on the local system or on a remote system. If the
["namespace"]  default dataset is on the local system, Caché starts the job
               using the parameters you specify. If the default dataset is on a
               remote system, Caché starts the remote job in the directory of
               the namespace’s default dataset.

["dir","sys"]  Caché converts this location to the implied namespace form ["^
               sys^dir"].

               The job runs in the specified directory on the specified remote
["^sys^dir"]   system. Caché does not allow any routine parameters or timeout
               specification.

               The job runs in the specified directory (implied namespace) as a
["^^dir"]      local job on the current system using the parameters you
               specify. An implied namespace is a directory path or OpenVMS
               file specification preceded by two caret characters: "^^dir".

["dir",""]     Caché issues a <COMMAND> error.

Global Mapping with Remote Jobs (Windows)
Caché does not provide global mapping for remote jobs, whether or not global
mapping has been defined on the requesting system. To avoid the lack of global
mapping, use extended references with your global specifications that point to
the location of any globals not in that namespace. If the namespace you specify
in an extended reference is not defined on the system you specify, you receive
a <NAMESPACE> error. Namespaces and the syntax for extended global references
are described in Global Structure in Using Caché Globals.
Remote Job Success Confirmation
You do not receive a direct message on the requesting system that indicates
whether the job was successfully initiated on the target system. However, Caché
does write a message indicating job initiation success or failure on the
console log of the target system.
Configuration File on Remote Systems
You must configure the ability to receive remote job requests on any system
that will receive them.
On the receiving system, go to the System Management Portal, select [Home] >
[Configuration] > [Advanced Memory Settings]. Locate netjob to view and edit.
When  true , incoming remote job requests via DCP, DDP, or ECP will be honored
on this server. The default is  true .
The license on the remote system must support enough users to run remotely
initiated jobs.
Using the $ZCHILD and $ZPARENT Special Variables
$ZPARENT contains the pid (Process ID) of the process which jobbed the current
process, or 0 if the current process was not created through the JOB command.
$ZCHILD contains the pid of the last process created by the JOB command,
whether or not the attempt was successful.
Using JOB Servers
JOB Servers are Caché processes that wait to process job requests. Jobbed
processes that attach to JOB Servers avoid the added overhead of having to
create a new process. Whenever a user issues a JOB command with the switch
parameter set to use JOB Server if available, Caché checks to see if any JOB
Servers are available to handle it. If not, it will create a process. If there
is a free JOB Server, the job attaches to that JOB Server.
When a job halts while running in a JOB Server, the JOB Server hibernates until
it receives another job request. A jobbed process not running in a JOB Server
exits and the process is deleted.
There are some unavoidable differences between the JOB Server environment and
the jobbed process environment, which may be a security concern with jobbed
processes executing in JOB Servers. A jobbed process normally takes on the
security attributes of the process that issued the JOB command at both the
Caché and the OpenVMS level.
However, a jobbed process that runs in a JOB Server uses the UIC of the JOB
Server at the OpenVMS level. The UIC of a JOB Server is the same as the UIC of
the Caché system manager, usually [1,4]. This means that when the JOB Server
accesses OpenVMS RMS files or devices, OpenVMS grants maximum access. This
feature does not concern you if you run Caché in an application environment,
but does apply if you use Caché in Programmer mode.
Input and Output Devices
Only one process can own a device at a time. Under OpenVMS it is impossible to
close your principal input or output device. This means that a job executing in
a JOB Server is unable to perform input or output to your principal I/O devices
even though you may close device 0.
Therefore, if you expect a JOB Server to perform input, you must specify:

  • An alternative input device for it
  • The null device for an output device (if you do not want to see the output)

Failure to follow these guidelines may cause the job executing in the JOB
Server to hang if it needs to do any input or output from/to your principal I/O
devices. You may find that frequently job output does get through to your
terminal (for example, if you have the SHARE privilege), but typically it will
not.
Troubleshooting Jobs That Will Not Execute
If your job does not start, check your I/O specification. Your job will not
start if Caché cannot open the devices you requested. Note that the null device
(NL: on OpenVMS and /dev/null on UNIX) is always available.
If your job starts but then halts immediately, make sure you have sufficient
swap space. Your job receives an error if you do not have enough swap space.
If your job does not start, make sure that you have used the correct namespace
in the JOB command. You can test whether a namespace is defined by using 
$ZUTIL(90,10).
If the JOB command is still not working, try the following:

  • Execute the routine with the DO command.
  • OpenVMS: Jobbed processes all execute the system login file,
    SYS$MANAGER:SYLOGIN.COM. Check to make sure it contains no statements that
    will cause a jobbed process to hang.
  • OpenVMS: Jobbed processes that do not run in JOB Servers also execute your
    LOGIN.COM file. Check this file as well.
  • Make sure you are not exceeding the number of processes for which you are
    licensed in OpenVMS or Caché.
  • If there is a timeout parameter in your JOB command, check whether the
    speed of your system is using up the timeout period.

JOB Command Completion
A jobbed process continues to completion even if the process that created it
logs off before that completion.
JOB Command with TCP Devices
You can use the JOB command to implement a TCP concurrent server. A TCP
concurrent server allows multiple clients to be served simultaneously. In this
mode a client does not have to wait for the server to finish serving other
clients. Instead, each time a client requests the server, it spawns a separate
subjob for that client which remains open as long as the client needs it. As
soon as this subjob has been spawned (indicated by the return of the JOB
command), another client may request service and the server will create a
subjob for that client as well.
Client/Server Connections in the Non-Concurrent and Concurrent Modes
[rcos_cjob_]
A concurrent server uses the JOB command with the switch process parameter bit
mask bit 4 or bit 16 turned on, and passes to the spawned process the input and
output process parameters.

  • If you specify switch bit 4, you must specify the TCP device in both 
    principal input and principal output process parameters. You must use the
    same device for both principal input and principal output, as follows:
   
      JOB child:(:4:tcp:tcp)

    The spawned process then sets this single I/O device, as follows:
   
      SET tcp=$IO

  • If you specify switch bit 16, you can specify different devices for the TCP
    device, the principal input, and the principal output process parameters,
    as follows:
   
      USE tcp
      JOB child:(:16:input:output)

    USE tcp preceding the JOB command specifies the current device (rather than
    the principal device), as the TCP device. The spawned process can then set
    these devices, as follows:
   
      SET tcp=$ZUTIL(53)
      SET input=$PRINCIPAL
      SET output=$IO

It is important to note that the JOB command will pass the TCP socket to the
jobbed process if the 4 or 16 bit is set. This capability may be combined with
other features of the JOB command by adding the appropriate bit code for each
additional feature. For example, when switch includes the bit with value 1, the
symbol table is passed. To turn on concurrency and pass the symbol table, 
switch would have a value of 5 (4+1) or 17 (16+1).
Before you issue the JOB command, the TCP device must:

  • Be open
  • Be listening on a TCP port
  • Have accepted an incoming connection

After the JOB command, the device in the spawning process is still listening on
the TCP port, but no longer has an active connection. The application should
check the $ZA special variable after issuing the JOB command to make sure that
the CONNECTED bit in the state of the TCP device was reset.
The spawned process starts at the designated entry point using the specified
device(s) as TCP device, principal input, and principal output device. The TCP
device has the same name in the child process as in the parent process. The TCP
device has one attached socket. The USE command is used to establish the TCP
device in  M mode, which is equivalent to  PSTE . The  P (pad) option is needed
to pad output with record terminator characters. When this mode is set, WRITE !
sends LF (line feed) and WRITE # sends FF (form feed), in addition to flushing
the write buffer.
The TCP device in the spawned process is in a connected state: the same state
the device would receive after it is opened from a client. The spawned process
can use the TCP device with an explicit USE statement. It can also use the TCP
device implicitly.
The following example shows a very simple concurrent server that spawns off a
child job whenever it detects a connection from a client. JOB uses a switch
value of 17, consisting of the concurrent server bit 16 and the symbol table
bit 1:

server ;
     SET io="|TCP|1"
     SET ^serverport=7001
     OPEN io:(:^serverport:"MA"):200
     IF $TEST=0 {
      WRITE !,"Cannot open server port"
      QUIT }
     ELSE { WRITE !,"Server port opened" }
loop  ;
     USE io READ x   ; Read for accept
     USE 0  WRITE !,"Accepted connection"
     USE io
     JOB child:(:17::)  ; Concurrent server bit is on
     GOTO loop
child ;
     SET io=$ZUTIL(53)
     SET input=$PRINCIPAL
     SET output=$IO
     USE io:(::"M")  ; Ensure that "M" mode is used
     WRITE $JOB,!  ; Send job id on TCP device to be read by client
     QUIT
client ;
     SET io="|TCP|2"
     SET host="127.0.0.1"
     OPEN io:(host:^serverport:"M"):200  ; Connect to server
     IF $TEST=0 {
      WRITE !,"Cannot open connection"
      QUIT }
     ELSE { WRITE !,"Client connection opened" }
     USE io READ x#3:200  ; Reads from subjob
     IF x="" {
        USE 0
        WRITE !,"No message from child"
        CLOSE io
        QUIT }
     ELSE {
        USE 0
        WRITE !,"Child is on job ",x
        CLOSE io
        QUIT }

The child uses the inherited TCP connection to pass its job ID (in this case
assumed to be 3 characters) back to the client, after which the child process
exits. The client opens up a connection with the server and reads the child’s
job ID on the open connection. In this example, the IPv4 value "127.0.0.1" for
the variable "host" indicates a loopback connection to the local host machine
(the corresponding IPv6 value is "0:0:0:0:0:0:0:1"). You can set up a client on
a different machine from the server if "host" is set to the server’s IP address
or name. Further details on IPv4 and IPv6 formats can be found in the 
 Use of IPv6 Addressing section of the InterSystems Product Miscellany article.
In principle, the child and client can conduct extended communication, and
multiple clients can be talking concurrently with their respective children of
the server.
Specifying Child Process Partition Size
Caché supports specifying the partition size of the jobbed child process. By
default, the jobbed process has a partition size equal to the system-wide
default partition size in effect when you execute JOB, regardless of the
partition size of the parent process from which you issue JOB. The system-wide
partition size increases dynamically to a maximum of 16mb.
You can specify the partition size (in kilobytes) of the jobbed process in the
second process parameter of the JOB command. The value you use must be a
multiple of 32 and must range from 128 through 16384.
You can optionally specify the partition-size process parameter value in
combination with other process information that you would normally put in the
second process parameter of JOB. Consider the following JOB command: 
JOB ^routine:(:544+1)
This command specifies that the symbol table of the jobbing process should be
passed to the jobbed process and that the jobbed process should have a
partition size of 544K. Although you can specify this second parameter, which
passes two values (544 and 1) as 545, 544 +1 is clearer and has exactly the
same effect.
See Also

  • ^$JOB structured system variable
  • $JOB special variable
  • $TEST special variable
  • $ZJOB special variable
  • $ZCHILD special variable
  • $ZPARENT special variable
  • TCP Client/Server Communication in Caché I/O Device Guide
  • The Spool Device in Caché I/O Device Guide
  • Using the System Management Portal to monitor and control processes in
    Managing Caché in Caché System Administration Guide


 #}}}
*KILL*  #{{{

Deletes variables.
Synopsis

KILL:pc killargument,...
K:pc killargument,...

where killargument can be:
variable,...
(variable,...)
Arguments

pc        Optional  A postconditional expression.

          Optional  A variable name or comma-separated list of variable names.
variable  Without parentheses: the variable(s) to be deleted. With parentheses:
          the variable(s) to be kept.

Description
There are three forms of the KILL command:

  • KILL without an argument, known as an argumentless KILL.
  • KILL with a variable list, known as an inclusive KILL.
  • KILL with a variable list enclosed in parentheses, known as an exclusive 
    KILL.

The KILL command without an argument deletes all local variables. It does not
delete process-private globals, globals, or user-defined special variables.
KILL with a variable or comma-separated variable list as an argument:

KILL variable,...

is called an inclusive KILL. It deletes only the variable(s) you specify in the
argument. The variables can be local variables, process-private variables, or
globals. They do not have to be actual defined variables, but they must be
valid variable names. You cannot kill a special variable, even if its value is
user-specified. Attempting to do so generates a <SYNTAX> error.
KILL with a variable or comma-separated variable list enclosed in parentheses
as an argument:

KILL (variable,...)

is called an exclusive KILL. It deletes all local variables except those you
specify in the argument. The variables you specify can only be local variables.
The local variables you specify do not have to be actual defined variables, but
they must be valid local variable names.
Note:
KILL can delete local variables created by Caché objects. Therefore, do not use
either argumentless KILL or exclusive KILL in any context where they might
affect system structures (such as %objTX currently used in %Save) or system
objects (such as the stored procedure context object). In most programming
contexts, these forms of KILL should be avoided.
Using KILL to delete variables frees up local variable storage space. To
determine or set the maximum local variable storage space (in kilobytes), use
the $ZSTORAGE special variable. To determine the currently available local
variable storage space (in bytes), use the $STORAGE special variable.
Arguments
pc
An optional postconditional expression. Caché executes the KILL command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
variable
If not enclosed in parentheses: the variable(s) to be deleted by the KILL
command. variable can be a single variable or a comma-separated list of
variables.
If enclosed in parentheses: the local variable(s) to be kept by the KILL
command; the KILL command deletes all other local variables. variable can be a
single variable or a comma-separated list of variables.
Examples
In the following example, an inclusive KILL deletes local variables a, b, and c
, and the deletes the process-private global ^||ppglob and all of its
subscripts. No other variables are affected.

   SET ^||ppglob(1)="fruit"
   SET ^||ppglob(1,1)="apples"
   SET ^||ppglob(1,2)="oranges"
   SET a=1,b=2,c=3,d=4,e=5
   KILL a,b,c,^||ppglob
   WRITE "d=",d,!,"e=",e
In the following example, an exclusive KILL deletes all local variables except
for variables d and e.

   SET a=1,b=2,c=3,d=4,e=5
   KILL (d,e)
   WRITE "d=",d,!,"e=",e

Note that because an exclusive KILL deletes object variables, the above program
works from a terminal session, but does not work within an object method.
The following example, an inclusive KILL deletes two process-private globals
and an exclusive KILL deletes all local variables except for variables d and e.

   SET ^||a="one",^||b="two"
   SET a=1,b=2,c=3,d=4,e=5
   KILL ^||a,^||b,(d,e)
   WRITE "d=",d,!,"e=",e

Notes
KILL and Objects
Object variables (OREFs) automatically maintain a reference count  the number
of items currently referring to an object. Whenever you SET a variable or
object property to refer to an object, Caché increments the object’s reference
count. When you KILL a variable, Caché decrements the corresponding object
reference count. When this reference count goes to 0, the object is
automatically destroyed; that is, Caché removes it from memory. The object
reference count is also decremented when a variable is SET to a new value, or
when the variable goes out of scope.
In the case of a persistent object, call the %Save() method before removing the
object from memory if you wish to preserve changes to the object. The %Delete()
method deletes the stored version of a Caché object; it does not remove the
in-memory version of that object.
Prior to Caché version 5.0, the %Close() method could be used to remove objects
from memory. With Caché version 5.0 and subsequent, the %Close() method
performs no operation and always completes successfully. Do not use %Close()
when writing new code.
Inclusive KILL
An inclusive KILL deletes only those variables explicitly named. The list can
include local variables, process-private globals, and globals either
subscripted or unsubscripted. The inclusive KILL is the only way to delete
global variables.
Exclusive KILL
An exclusive KILL deletes all local variables except those that you explicitly
name. Listed names are separated by commas. The enclosing parentheses are
required.
The exception list can contain only local unsubscripted variable names. For
example, if you have a local variable array named fruitbasket, which has
several subscript nodes, you can preserve the entire local variable array by
specifying KILL (fruitbasket); you cannot use exclusive KILL to selectively
preserve individual subscript nodes. An exclusive kill list cannot specify a
process-private global, a global, or a special variable; attempting to do so
results in a <SYNTAX> error. Local variables not named in the exception list
are deleted; subsequent references to such variables generate an <UNDEFINED>
error. The exclusive KILL has no effect on process-private globals, globals,
and special variables. However, it does delete local variables created by
system objects.
Using KILL with Arrays
You can use an inclusive KILL to delete an entire array or a selected node
within an array. The specified array can be a local variable, a process-private
global, or a global variable.

  • To delete a local variable array, use any form of KILL.
  • To delete a selected node within a local variable array, you must use an
    inclusive KILL.
  • To delete a global variable array, you must use an inclusive KILL.
  • To delete a selected node within a global variable array, you must use an
    inclusive KILL.

For further details on global variables with subscripted nodes, see Global
Structure in Using Caché Globals.
To delete an array, simply supply its name to an inclusive KILL. For example,
the following command deletes global array ^fruitbasket and all of its
subordinate nodes.

   SET ^fruitbasket(1)="fruit"
   SET ^fruitbasket(1,1)="apples"
   SET ^fruitbasket(1,2)="oranges"
   WRITE !,^fruitbasket(1)," contains ",^fruitbasket(1,1),
         " and ",^fruitbasket(1,2)
   KILL ^fruitbasket
   WRITE !,"Try to display array values"
   WRITE !,^fruitbasket(1),!,^fruitbasket(1,1),
         !,^fruitbasket(1,2)
   QUIT
To delete an array node, supply the appropriate subscript. For example, the
following KILL command deletes the node at subscript 1,2.

   SET ^fruitbasket(1)="fruit"
   SET ^fruitbasket(1,1)="apples"
   SET ^fruitbasket(1,2)="oranges"
   SET ^fruitbasket(1,2,1)="navel"
   SET ^fruitbasket(1,2,2)="mandarin"
   WRITE ^fruitbasket(1)," contains ",^fruitbasket(1,1),
         " and ",^fruitbasket(1,2),!
   WRITE ^fruitbasket(1,2)," contains ",^fruitbasket(1,2,1),
         " and ",^fruitbasket(1,2,2),!
   KILL ^fruitbasket(1,2)
   WRITE "1st level node: ",^fruitbasket(1),!
   WRITE "2nd level node: ",^fruitbasket(1,1),!
   WRITE "Deleted 2nd level node: ",^fruitbasket(1,2),!
   WRITE "3rd level node under deleted 2nd: ",^fruitbasket(1,2,1),!
   QUIT
When you delete an array node, you automatically delete all nodes subordinate
to that node and any immediately preceding node that contains only a pointer to
the deleted node. If a deleted node is the only node in its array, the array
itself is deleted along with the node.
To delete multiple local variable arrays, you can use either the inclusive form
or exclusive form of KILL, as described above. For example, the following
command removes all local arrays except array1 and array2.

   KILL (array1,array2)

To delete multiple array nodes, you can use only the inclusive form of KILL.
For example, the following command removes the three specified nodes, deleting
one node from each array.

   KILL array1(2,4),array2(3,2),array3(1,7)

The nodes can be in the same or different arrays.
You may delete a specified local or global array node by using the ZKILL
command. Unlike KILL, ZKILL does not delete all nodes subordinate to the
specified node.
Effects of KILL with Parameter Passing
With parameter passing, values are passed to a user-defined function or to a
subroutine called with the DO command. The values to be passed to the
user-defined function or subroutine are supplied in a comma separated list
called the actual parameter list. Each value supplied is mapped, by position,
into a corresponding variable in the formal parameter list defined for the
user-defined function or subroutine.
Depending on how the actual parameter list is specified, parameter passing can
occur in either of two ways: by value or by reference. For more information on
these two types of parameter passing, see DO with Parameter Passing.
Killing a variable in the formal parameter list has different results depending
on whether passing by value or passing by reference is in effect.
If you are passing a variable by value:

  • Killing a variable in the formal list has no effect outside the context of
    the invoked function or subroutine. This is because Caché automatically
    saves the current value of the corresponding actual variable when the
    function or subroutine is invoked. It then automatically restores the saved
    value on exit from the function or subroutine.

In the following passing by value example, the KILL in Subrt1 deletes the
formal variable x but does not affect the actual variable a:

Test
    SET a=17
    WRITE !,"Before Subrt1 a: ",$DATA(a)
    DO Subrt1(a)
    WRITE !,"After Subrt1 a: ",$DATA(a)
    QUIT
Subrt1(x)
    WRITE !,"pre-kill x: ",$DATA(x)
    KILL x
    WRITE !,"post-kill x: ",$DATA(x)
    QUIT
If you are passing a variable by reference:

  • Performing KILL and including the variable in the formal list also kills
    the corresponding actual variable. When the function or subroutine
    terminates, the actual variable will no longer exist.
  • Performing a KILL and excluding the variable in the formal list causes both
    the formal variable and the actual variable passed by reference to be
    preserved.

In the following passing by reference example, the KILL in Subrt1 deletes both
the formal variable x and the actual variable a.

Test
    SET a=17
    WRITE !,"Before Subrt1 a: ",$DATA(a)
    DO Subrt1(.a)
    WRITE !,"After Subrt1 a: ",$DATA(a)
    QUIT
Subrt1(x)
    WRITE !,"pre-kill x: ",$DATA(x)
    KILL x
    WRITE !,"post-kill x: ",$DATA(x)
    QUIT
As a general rule, you should not KILL variables specified in a formal
parameter list. When Caché encounters a function or subroutine that uses
parameter passing (whether by value or by reference), it implicitly executes a 
NEW command for each variable in the formal list. When it exits from the
function or subroutine, it implicitly executes a KILL command for each variable
in the formal list. In the case of a formal variable that uses passing by
reference, it updates the corresponding actual variable (to reflect changes
made to the formal variable) before executing the KILL.
Transaction Processing
A KILL of a global variable is journaled as part of the current transaction;
this global variable deletion is rolled back during transaction rollback. A 
KILL of a local variable or a process-private global variable is not journaled,
and thus this variable deletion is unaffected by a transaction rollback.
See Also

  • ZKILL command
  • $ZUTIL(68,28) Control Root (Unsubscripted) Node Kills function
  • $STORAGE special variable


 #}}}
*LOCK*  #{{{

Enables processes to request control and release control of data resources.
Synopsis

LOCK:pc
L:pc

LOCK:pc oper(lockname#locktype,...):timeout,...
L:pc oper(lockname#locktype,...):timeout,...

Arguments

pc        Optional  A postconditional expression.

oper      Optional  The lock operation indicator (a + or  sign) to apply or
          remove a lock.

lockname  The resource(s) to be locked or unlocked. Must be a valid identifier,
          following the same naming conventions as local variables or globals.

locktype  Optional  A letter code specifying the type of lock to apply or
          remove.

          Optional  The time to wait before the transaction times out.
timeout   Specified as an integer number of seconds. Fractional seconds are
          truncated to the integer portion.

Description
There are two basic forms of the LOCK command:

  • Without an argument
  • With an argument

LOCK Without an Argument
The argumentless LOCK removes all locks currently held by the process. This
includes both simple and incremental locks. It also includes all accumulated
incremental locks. For example, if there are three incremental locks on a given
lock name, Caché removes all three locks and resets the lock name's entry in
the lock table to zero. Argumentless LOCK removes both shared and exclusive
locks.
Argumentless LOCK is used to explicitly release all existing locks. Completion
of a process also releases all locks held by that process. Completion of a
transaction releases all locks held within that transaction.
LOCK With an Argument
LOCK with an argument specifies one or more lock names on which to perform
locking and unlocking operations. The effect of the LOCK depends on the
argument you use.

  • LOCK lockname sets a simple lock on the specified lock name and unlocks all
    previous locks.
  • LOCK +lockname sets an incremental lock on the specified lock name.
  • LOCK -lockname performs an unlock operation. Unlocking decrements a lock
    count for the specified lock name; when this lock count decrements to zero,
    the lock is unlocked.

You can specify multiple locks with a single LOCK command in either of two
ways:

  • By enclosing a comma-separated list of lock names in parentheses, you can
    perform these locking operations on multiple locks as a single operation.
    For example:
   
      LOCK +(var1,var2):10
    All lock operations in a parentheses-enclosed list are governed by a single
    timeout argument: either all of the locks are applied or none of them are
    applied.
  • By specifying multiple lock arguments without parentheses as a
    comma-separated list, you can specify multiple independent lock operations,
    each of which can have its own timeout. (This is functionally identical to
    specifying a separate LOCK command for each lock.) For example, a single 
    LOCK command could perform a simple lock and an incremental lock, each with
    its own timeout:
   
      LOCK var1:10,+var2:15
    However, if you use multiple lock arguments, be aware that the simple lock
    operation unlocks all prior locks, including locks set by an earlier part
    of the same LOCK command.

Viewing the Current Locks
To view a list of the current locks for your process, go to the Caché System
Management Portal and select Locks ([Home] > [Locks]). The Locks window
displays a list of processes with the current locks for each. Separate lock
counts are maintained for Exclusive locks and Shared locks. You may need to use
the Refresh option to view the most current list of locks.
You can delete locks by clicking  Remove ,  Remove All Locks for Process , or  
Remove all Locks for Server (at top of window). This gives you the option of
deleting that lock, deleting all locks for the process, or deleting all locks
for the server.
Arguments
pc
An optional postconditional expression that can make the command conditional.
Caché executes the LOCK command if the postconditional expression is true
(evaluates to a nonzero numeric value). Caché does not execute the command if
the postconditional expression is false (evaluates to zero). For further
details, refer to Command Postconditional Expressions in 
Using Caché ObjectScript.
oper
The lock operation indicator is used to apply or remove a lock. In a
comma-separated list of lock names, each lock name must have its own lock
operation indicator. The lock operation indicator can be one of the following
values:

No character    Apply a simple lock to a lock name and unlock all prior locks.

Plus sign (+)   Apply an incremental lock to a lock name.

Minus sign (-)  Remove a lock from a lock name.

If the lock name has a lock count of 1, remove the lock from the lock table. If
the lock name has a lock count of more than 1, remove one of its incremental
locks (decrement the lock count). By default, this removes exclusive locks. To
remove a shared lock, you must specify the lock type specifying a shared lock.
If your LOCK command contains multiple comma-separated lock argument
syntactical units, each lock argument can have its own lock operation
indicator. Caché parses this as multiple LOCK commands; therefore a simple lock
will delete any locks created by a lock argument specified earlier in the
command.
lockname
The name of a single data resource, or a comma-separated list of data
resources, to be locked or unlocked. A lockname is a name representing a data
resource; it is not the variable itself. That is, your program can use a lock
named "a" and a variable named "a" without conflict. Lock names are case
sensitive. In Caché, the following are all valid and unique lock names: a, A, ^
a, ^A, ab. Lock names follow the same naming conventions as local variables and
global variables, as described in the Variables chapter of 
Using Caché ObjectScript.
Note:
Process-private global names should not be used as lock names.
Lock names can be local or global. A lock name such as A is a local lock name.
It applies only to that machine, but does apply across namespaces. A conflict
occurs when two namespaces attempt to lock the same lock name. A lock name that
begins with a caret (^) character is a global lock name; the mapping for this
lock follows the same mapping as the corresponding global, and thus can apply
across systems. (See Global Structure in Using Caché Globals.)
A lock name can represent a local or global variable, subscripted or
unsubscripted. It can be an implicit global reference, or an extended reference
to a global on another computer. (See Global Structure in Using Caché Globals.)
The reference for a lock name does not need to exist. For example, your
applications may lock the lock name "ACCT" to mean, by convention, that other
routines may not access globals in the database in the namespace "ACCTING".
locktype
The type of lock to apply or remove. You can specify a different lock type for
each lock name. locktype is an optional argument; if omitted, the lock name
defaults to an exclusive lock. The syntax for lock type is a mandatory pound
sign (#), followed by one or more lock types enclosed in quotation marks. Lock
type codes can be specified in any order and are not case sensitive. The
following are the lock type codes:

  • S: Shared lock
    Allows multiple processes to simultaneously hold nonconflicting locks on
    the same resource. For example, two (or more) processes may simultaneously
    hold shared locks on the same resource, but an exclusive lock limits the
    resource to one process. An existing shared lock prevents all other
    processes from setting an exclusive lock, and an existing exclusive lock
    prevents all other processes from setting a shared lock on that resource.
    However, a process can first set a shared lock on a resource and then the
    same process can set an exclusive lock on the resource, upgrading the lock
    from shared to exclusive. Shared and Exclusive lock counts are independent.
    Therefore, to release such a resource it is necessary to release both the
    exclusive lock and the shared lock. All locking and unlocking operations
    not specified as shared, default to exclusive.
  • I: Immediate unlock
    Allows you to release an incremental lock within a transaction. An
    immediate unlock can only be used on an incremental lock applied within the
    current transaction. An immediate unlock can be specified for a shared lock
    (#"SI") or an exclusive lock (#"I"). Unlocks not specified as Immediate
    default to unlock at the conclusion of the transaction.

timeout
The number of seconds to wait for a lock request to succeed before the
transaction times out. If the LOCK command performs multiple locks, all locks
must succeed within the timeout period. If the timeout period expires before
all locks are successful, none of the locks specified in the LOCK command are
held, and control returns to the process. It is an optional argument. If
omitted, the LOCK command waits indefinitely for a resource to be lockable; if
the lock cannot be set, the process will hang. The syntax for timeout is a
mandatory colon (:), followed by an integer value or an expression that
evaluates to an integer value. A value of zero permits one locking attempt
before timing out. A negative number is equivalent to zero. If you use timeout
and the lock is successful, Caché sets the $TEST special variable to True (1).
If the lock cannot be set within the timeout period, Caché sets $TEST to False
(0). (Note that $TEST is set by other Caché ObjectScript commands as well.) If
the LOCK command contains multiple comma-separated lock argument syntactical
units, each lock argument can have its own timeout. Caché parses this as
multiple LOCK commands, so the timeout of one lock argument does not affect the
other lock arguments.
Examples and Notes
Simple Locking
Simple locking places a lock on a single lock name or a group of lock names and
simultaneously removes any locks (whether simple or incremental, exclusive or
shared) previously set on any lock names by the current process. Issuing a
simple lock does the following:

  • Releases all locks previously held by the process. This is the same as an
    argumentless lock.
  • Locks the specified resources.
  • Sets the lock table count for those lock names to 1. By default it sets the
    Exclusive lock table count; if lock type is #"S", it instead sets the
    Shared lock table count to 1 for that lock name.

The following example sets a simple lock on lock name ^a.

  LOCK ^a

This command requests an exclusive lock: no other process can simultaneously
hold a lock on this resource. If another process already holds a lock on this
resource (exclusive or shared), this example must wait for that lock to be
released. It can wait indefinitely, hanging the process. To avoid this,
specifying a timeout value is recommended.
If a simple lock is issued during a transaction, the release of previously held
resources is deferred until the completion of the transaction. A simple lock
acquired during a transaction cannot be released during that transaction.
(Incremental locks can be released during a transaction using the Immediate
Unlock lock type.) The TCOMMIT command completes the transaction and releases
all locks held during the transaction.
The following example sets simple locks on lock names ^b, ^c, and ^d as a
group.

 LOCK (^b,^c,^d)

Note that like all simple locks, this LOCK command first releases all locks
previously held by the process. Thus the lock ^a held by the previous command
would be released by issuing this command.
The grouping parentheses are required when issuing a simple lock with multiple
lock names. These parentheses cause LOCK to lock all of the specified
resources. If a timeout is specified, either all of the specified resources are
locked or the LOCK command times out and none of them are locked.
If the parentheses were omitted, the command LOCK ^b,^c,^d would be parsed as
three simple lock commands, with the result of first releasing previously held
locks and locking ^b, then immediately releasing ^b in order perform a simple
lock on ^c, then immediately releasing ^c in order perform a simple lock on ^d.
As a result, only ^d would be locked.
Incremental Locking
Incremental locking permits you to set multiple locks on the same resource.
Your process can then increment and decrement this lock count. As of Caché 4.1,
the lock table maintains independent lock counts for exclusive locks and shared
locks.
Issuing an incremental lock does the following:

  • Incremental locking adds new locks without removing existing locks. It
    leaves unchanged the processes' existing locks, unless those lock names are
    specified in the incremental LOCK command. This gives you more explicit
    control over locking than available with simple locking, permitting you to
    add locks without releasing existing locks.
  • If a specified lock name was previously unlocked, it is locked and assigned
    a lock count of 1. This is identical to a simple lock.
  • If a specified lock name was previously locked (by either a simple lock or
    an incremental lock), the lock continues in effect and the lock count is
    incremented by 1.

Lock counts are assigned in the locking table as either Exclusive or Shared,
depending on the lock type used.
The following example sets an incremental lock on lock names ^x and ^y.

   LOCK +(^x,^y)

The enclosing parentheses are required when specifying multiple lock names.
Unlocking
The following example removes an exclusive lock from lock name ^a.

   LOCK -^a

If the lock count for ^a is 1, the lock is unlocked (removed from the lock
table.) This can be either a simple lock, or an incremental lock with a lock
count of 1. If the lock count for ^a is greater than 1, the lock count is
decremented.
Note that only the Exclusive lock count and lock are affected, not the Shared
lock count and lock. The same lock name can have both an Exclusive and a Shared
lock. The following example removes a shared lock from lock name ^a:

   LOCK -^a#"S"

The following example performs unlocking on lock names ^a, ^b, ^c, ^d, and ^e.

   LOCK ^a
   LOCK +(^b)
   LOCK +(^b,^e,^e#"S")
   LOCK +(^c#"S",^d#"S")
   LOCK -(^a,^b,^c#"S",^d,^e)

The unlock command in this example does the following:

  • ^a is unlocked and removed from the lock table. ^a had an exclusive lock
    count of 1.
  • ^b remains in the lock table, but its exclusive lock count is decremented
    from 2 to 1.
  • ^c is unlocked and removed from the lock table. ^c had a shared lock count
    of 1.
  • ^d is unaffected. The unlock attempted to unlock an exclusive lock, but ^d
    did not have an exclusive lock; it had (and continues to have) a shared
    lock count of 1.
  • ^e has both an Exclusive and a Shared lock. The unlock removed the
    Exclusive lock, but left the shared lock with a lock count of 1.

If a specified lock name does not have any locks on it, no operation is
performed.
Locking Protocol
By itself a lock does not prevent another process from modifying the associated
data because Caché does not enforce unilateral locking. Locking works only by
convention: it requires that mutually competing processes all implement locking
on the same variables.
All processes in competition for write access to a given variable must lock
that variable before updating it. A lock remains in effect until it is unlocked
by the process that set it. Thus, each process must unlock the variables when
it finishes with them. Without this cooperation, the concept of locking has no
meaning.
While in effect on a given variable, a lock causes a wait condition for any
other process that attempts to lock that variable. If a process simply writes
to a locked variable without first asserting its own lock, the write attempt
will succeed.
Caché maintains a system-wide lock table that records all locks that are in
effect and the processes that have set them. Use the System Management Portal
or the LOCKTAB utility to display the existing locks in the Lock Table or to
remove selected locks.
Locks on Local Variables
The behavior of LOCK on local (non-careted) variables is the same on Caché,
Open M [DTM], and DSM for OpenVMS. Refer to $ZUTIL(69,8) Set ZA and ZD Modes
for information on compatibility with older DSM for OpenVMS locking commands.
In Open M [DTM] and DSM for OpenVMS, local locks are always taken out in the
manager's dataset regardless of the first character. If an application ported
to Caché uses local locks that do not begin with a % character, the application
may experience deadlock conditions if it uses the same, local, non-% lock names
in different datasets. The locks now collide because they resolve to the same
item. If this is part of a hierarchical locking system, a deadly embrace may
occur that can hang an application.
The current behavior is:

  • Local (non-careted) locks acquired in the context of a specific namespace,
    either because the default namespace is an explicit namespace or through an
    explicit reference to a namespace, are taken out in the manager's dataset
    on the local machine. This occurs regardless of whether the default mapping
    for globals is a local or a remote dataset.
  • Local (non-careted) locks acquired in the context of an implied namespace
    or through an explicit reference to an implied namespace on the local
    machine, are taken out using the manager's dataset of the local machine. An
    implied namespace is a directory path or OpenVMS file specification
    preceded by two caret characters: "^^dir".

Referencing explicit and implied namespaces is further described in Global
Structure in Using Caché Globals.
Locks on Global Variables
Locking is typically used with global variables to synchronize the activities
of multiple processes that may access these variables simultaneously. Global
variables differ from local variables in that they reside on disk and are
available to all processes. The potential exists, then, for two processes to
write to the same global at the same time. In fact, Caché processes one update
before the other, so that one update overwrites and, in effect, discards the
other.
Global lock names begin with a caret (^) character.
To illustrate locking with global variables, consider the case in which two
data entry clerks are concurrently running the same student admissions
application to add records for newly enrolled students. The records are stored
in a global array named ^student. To ensure a unique record for each student,
the application increments the simple global variable ^index for each student
added. The application includes the LOCK command to ensure that each student
record is added at a unique location in the array, and that one student record
does not overwrite another.
The relevant code in the application is shown below. In this case, the LOCK
controls not the global array ^student but the simple global variable ^index. ^
index is a scratch global that is shared by the two processes. Before a process
can write a record to the array, it must lock ^index and update its current
value (SET ^index=^index+1). If the other process is already in this section of
the code, ^index will be locked and the process will have to wait until the
other process releases the lock (with the argumentless LOCK command).

 READ !,"Last name: ",!,lname QUIT:lname=""  SET lname=lname_","
 READ !,"First name: ",!,fname QUIT:fname=""  SET fname=fname_","
 READ !,"Middle initial: ",!,minit QUIT:minit=""  SET minit=minit_":"
 READ !,"Student ID Number: ",!,sid QUIT:sid=""
 SET rec = lname_fname_minit_sid
 LOCK ^index
 SET ^index = ^index + 1
 SET ^student(^index)=rec
 LOCK

Locking an Array Node
When you lock an array, you can lock either:

  • The entire array
  • One or more specific nodes in the array

Locking an array node locks the node itself and, implicitly, all nodes that are
subordinate to that node. It also locks all nodes that are direct parents to
the locked node. Other nodes on the same level as the locked node remain
unlocked, even though they have the same parents as the locked node.
The following example recasts the previous example to use locking on the node
to be added to the ^student array. Only the affected portion of the code is
shown. In this case, the ^index variable is updated after the new student
record is added. The next process to add a record will use the updated index
value to write to the correct array node.

 LOCK ^student(^index)
 SET ^student(^index) = rec
 SET ^index = ^index + 1
 LOCK

Note that the lock location of an array node is where the top level global is
mapped. Caché ignores subscripts when determining lock location. Therefore, ^
student(name) is mapped to the namespace of ^student, regardless of where the
data for ^student(name) is stored.
Queuing of Array Node Locks
The Caché queuing algorithm for array locks is to queue locks for the same
resource in the order received, even when there is no direct resource
contention. As this may differ from expectations, or from implementations of
lock queuing on other databases, some clarification is provided here.
Consider the case where three locks on the same global array are requested by
three different jobs:

Job #1: LOCK ^X(1)
Job #2: LOCK ^X
Job #3: LOCK ^X(2)

In this case, Job #1 gets a lock on ^X(1) and its direct parent ^X. Therefore,
Job #2 must wait for Job #1 to release ^X. But what about Job #3? The lock
granted to Job #1 blocks Job #2, but does not block the lock requested by Job #
3. But in Caché, Job #3 must wait for Job #2.
The Caché lock queuing algorithm is fairest for Job #2. Other database
implementations that allowed Job #3 to jump the queue can speed Job #3, but
could (especially if there are many jobs such as Job #3) result in an
unacceptable delay for Job #2.
Locks in a Network
In a networked system, one or more servers may be responsible for resolving
locks on global variables.
You can use the LOCK command with any number of servers, up to 255. Remote
locks held by a client job on a remote server system are released when you call
the RESJOB utility to remove the client job.
Avoiding Deadlock
Incremental locking is potentially dangerous because it can lead to a situation
known as "deadlock". This situation occurs when two processes each assert an
incremental lock on a variable already locked by the other process. Because the
attempted locks are incremental, the existing locks are not released. As a
result, each process hangs while waiting for the other process to release the
existing lock.
To prevent deadlocks, you should use simple locking or always include the
timeout option when using incremental locks. Another way to avoid deadlocks is
to follow a strict protocol for the order in which you issue incremental LOCK
commands. Deadlocks cannot occur as long as all processes follow the same
order. A simple protocol is to add locks in collating sequence order.
If a deadlock occurs, you can resolve it by using the System Management Portal
or the LOCKTAB utility to remove one of the locks in question. From the System
Management Portal, open the Locks window, then select the Remove option for the
deadlocked process.
Global Unlocking
When a process terminates, Caché performs an implicit argumentless LOCK to
clear all locks that were set by the process.
See Also

  • $TEST special variable
  • $ZUTIL(69,8) Set ZA and ZD Modes function
  • Using ObjectScript for Transaction Processing in Using Caché ObjectScript
  • The Monitoring Locks section of the Managing Caché chapter in 
    Caché System Administration Guide


 #}}}
*MERGE*  #{{{

Merges global nodes or subtrees from source into destination.
Synopsis

MERGE:pc mergeargument,...
M:pc mergeargument,...

where mergeargument is:

destination=source

Arguments

pc           Optional  A postconditional expression.

destination  Local variables, process-private globals, or globals to be merged.
and source   If specified as a class property, the source variable must be a
             multidimensional (subscripted) variable.

Description
MERGE destination=source copies source into destination and all descendants of 
source into descendants of destination. It does not modify source, or kill any
nodes in destination.
MERGE simplifies the copying of a subtree (multiple subscripts) of a variable
to another variable. Either variable can be a subscripted local variable,
process-private global, or global. A subtree is all variables that are
descendants of a specified variable. MERGE offers a one-command alternative to
the current technique for doing subtree copy: a series of SET commands with 
$ORDER references.
MERGE issues a <COMMAND> error if the source and destination have a
parent-child relationship.
The MERGE command can take longer than most other Caché ObjectScript commands
to execute. As a result, it is more prone to interruption. The effect of
interruption is implementation-specific. Under Caché, an interruption may cause
an unpredictable subset of the source to have been copied to the destination
subtree.
Arguments
pc
An optional postconditional expression. Caché executes the MERGE command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
destination and source
Variables to be merged. Either variable can be a local variable, a
process-private global, or a global. If destination is undefined, MERGE defines
it and sets it to source. If source is undefined, MERGE completes successfully,
but does not change destination.
You can specify multiple, comma-separated destination=source pairs. They are
evaluated in left-to-right order.
Examples
The following example copies a subtree from one global variable (^a) to another
global variable (^b). In this case, the merge is being used to create a smaller
global ^b, which contains only the ^a(1,1) subtree of the information in ^a.

   SET ^a="cartoons"
   SET ^a(1)="The Flintstones",^a(2)="The Simpsons"
   SET ^a(1,1)="characters",^a(1,2)="place names"
   SET ^a(1,1,1)="Flintstone family"
   SET ^a(1,1,1,1)="Fred"
   SET ^a(1,1,1,2)="Wilma"
   SET ^a(1,1,2)="Rubble family"
   SET ^a(1,1,2,1)="Barney"
   SET ^a(1,1,2,2)="Betty"
   MERGE ^b=^a(1,1)
   WRITE ^b,!,^b(2),!,^b(2,1)," and ",^b(2,2)
The following example shows how a destination global variable looks after it
has been merged with a subtree of a source global variable.
Suppose you execute the following:

  KILL ^X,^Y
  SET ^X(2,2)="first"
  SET ^X(2,2,4)="second"
  SET ^Y(3,6,7)="third"
  SET ^Y(3,6,8)="fourth"
  SET ^Y(3,6,7,8,4)="fifth"
  SET ^Y(3,6,7,8,9)="sixth"
  WRITE ^X(2,2),!,^X(2,2,4),!
  WRITE ^Y(3,6,7),!,^Y(3,6,8),!
  WRITE ^Y(3,6,7,8,4),!,^Y(3,6,7,8,9)
The following figure shows the resulting logical structure of ^X and ^Y.
Initial Structure of ^X and ^Y
[rcos_cmerg]
Consider the following MERGE command:

  MERGE ^X(2,3)=^Y(3,6,7,8)

When you issue the previous statement, Caché copies part of ^Y into ^X(2,3).
The global ^X now has the structure illustrated in the figure below.
Result on ^X and ^Y of MERGE Command
[rcos_cmerg]
Notes
Naked Indicator
When both destination and source are local variables, the naked indicator is
not changed. If source is a global variable and destination is a local
variable, then the naked indicator references source.
When both source and destination are global variables, the naked indicator is
unchanged if source is undefined ($DATA(source)=0). In all other cases
(including $DATA(source)=10), the naked indicator takes the same value that it
would have if the SET command replaced the MERGE command and source had a
value. For more details on the naked indicator, see Naked Global Reference in 
Using Caché Globals.
Merge to Self
When the destination and source are the same variable, no merge occurs. Nothing
is recorded in the journal file. However, the naked indicator may be changed,
based on the rules described in the previous section.
Watchpoints
The MERGE command supports watchpoints. If a watchpoint is in effect, Caché
triggers that watchpoint whenever that MERGE alters the value of a watched
variable. To set watchpoints, use the ZBREAK command.
See Also

  • ZBREAK command
  • Debugging chapter in Using Caché ObjectScript
  • Global Structure chapter in Using Caché Globals


 #}}}
*MVCALL*  #{{{

Calls a MultiValue subroutine.
Synopsis

MVCALL:pc subr(args) ,subr2(args)...

Arguments

pc    Optional  A postconditional expression. For further details, refer to
      Command Postconditional Expressions in Using Caché ObjectScript.

      The name of a MultiValue subroutine, or an indirect reference to this
subr  name, using the @ indirection operator. You can specify a single
      subroutine or a series of subroutines with their arguments, separated by
      commas (,).

      Optional  An argument or comma-separated list of arguments to be passed
args  to the MultiValue subroutine. To pass an argument by reference, use the
      period (.) prefix. The args parentheses are only required if an argument
      is specified.

Description
The MVCALL command invokes the Caché MVBasic CALL command to call one or more
MultiValue subroutines, then returns to the Caché ObjectScript environment. For
further details refer to the Caché MultiValue Basic Reference.
Because MVCALL follows Caché ObjectScript precedence rules, you may need to
enclose indirect expressions in parentheses to compel the desired precedence of
operators.
See Also

  • CALL command in Caché MultiValue Basic Reference


 #}}}
*MVCRT*  #{{{

Performs MultiValue printing to terminal.
Synopsis

MVCRT:pc printlist
MVC:pc printlist

Arguments

pc         Optional  A postconditional expression. For further details, refer
           to Command Postconditional Expressions in Using Caché ObjectScript.

           Optional  Any MVBasic expression that resolves to a quoted string or
printlist  a numeric. You can specify a single expression or a series of
           expressions. If printlist is omitted, a blank line is returned.

Description
The MVCRT command invokes the Caché MVBasic CRT command, performs the specified
operation, and returns to the Caché ObjectScript environment. Specify parameter
values in MVBasic form.
Within printlist, you can specify tab and line return formatting using features
of ObjectScript WRITE command syntax, rather than MVBasic CRT command syntax.
Only a limited subset of WRITE formatting syntax is supported: comma
(concatenate), question mark (tab), and exclamation mark (line return).
Multiple exclamation marks and numeric tabs are not supported. The following
table shows the format equivalences:

MVCRT (ObjectScript)  CRT (MVBasic)

MVCRT a               CRT a:

MVCRT a,!             CRT a

MVCRT a,b,!           CRT a:b

MVCRT a,!,b,!         CRT a CRT b

MVCRT a,?,b,!         CRT a,b

For further details refer to the Caché MultiValue Basic Reference.
See Also

  • MVPRINT command
  • WRITE command
  • CRT command in Caché MultiValue Basic Reference


 #}}}
*MVDIM*  #{{{

Dimensions an array of variables for MultiValue use.
Synopsis

MVDIM:pc array(rows,columns)

Arguments

pc       Optional  A postconditional expression. For further details, refer to
         Command Postconditional Expressions in Using Caché ObjectScript.

array    Name of an array. Follows standard MVBasic variable naming
         conventions.

         An integer specifying the number of array elements to dimension for a
rows     one-dimensional array, or the number of rows to dimension for a
         two-dimensional array.

         Optional  For two-dimensional (matrix) arrays, an integer specifying
columns  the number of columns per row. Can only be used in conjunction with
         the optional rows argument.

Description
The MVDIM command explicitly dimensions a one-dimensional or two-dimensional
MultiValue static array. Dimensioning of arrays is required for MultiValue
applications.
Note:
Explicit dimensioning of arrays is not required (or supported) for Caché
ObjectScript. Arrays in Caché ObjectScript are dynamic and multidimensional.
For a description of arrays in Caché ObjectScript, refer to 
 Multidimensional Arrays in Using Caché ObjectScript.
Most MultiValue systems require you to explicitly dimension the rows and 
columns of a static array. These values specify the maximum number of elements
that can be defined for that array. An explicitly dimensioned array is limited
to two subscripts. It can be either one-dimensional, representing a vector
array, or two-dimensional, representing the rows and columns of a matrix array.
A one-dimensional array can be dimensioned either as a vector array: 
MVDIM arrayname(n) or a matrix array with a column dimension of one: 
MVDIM arrayname(n,1).
The subscripts of a dimensioned array can be specified using named variables,
as well as numeric indices. Variables whose names begin with a % are known as
public arrays and their values are preserved across SUBROUTINE calls in a
similar manner to COMMON arrays. Variables whose names begins with ^ are known
as globals and their values are stored on disk automatically. Variables with
normal naming conventions are known as local arrays and their value is lost
when the program terminates, as with any other variable.
All uninitialized variables are treated as zero-length strings ("").
Note:
Caché MVBasic also allows you to dimension arrays of an arbitrary number of
dimensions. This allows MVBasic to support the multidimensional arrays used in
Caché. You specify a multidimensional array using a DIM statement with empty
parentheses: DIM arrayname(). This declares array as a dimensioned array, but
the number of dimensions and number of elements in each dimension may be
expanded dynamically at runtime. Because Caché ObjectScript normally creates
arrays of this type, the MVDIM command does not provide an option for this type
of implicit dimensioning.
Refer to the Caché MultiValue Basic Reference for further details.
Examples
The following examples illustrate the use of the MVDIM statement:

 ; Dimensions a one-dimensional array with 10 elements.
 MVDIM MyVector(10)

 /* Dimensions a two-dimensional matrix array
    with 10 rows and 10 columns. */
 MVDIM MyMatrix(10,5)

 /* Dimensions a two-dimensional array using local variables */
 SET myrows=4,mycols=5
 MVDIM MyMatrix(myrows,mycols)

See Also

  • SET command
  • DIM statement in Caché MultiValue Basic Reference
  •  Multidimensional Arrays in Using Caché ObjectScript


 #}}}
*MV*  #{{{

Invokes the MultiValue Shell.
Synopsis

MV:pc commands

Arguments

pc        Optional  A postconditional expression.

          Optional  A MultiValue Shell command, specified as a quoted string,
commands  or a comma-separated list of MultiValue Shell commands, each command
          specified as a quoted string.

Description
MV command has two forms: argumentless MV and MV with a commands argument.
Argumentless MV
The MV command invokes the Caché MultiValue Shell. Caché displays the
MultiValue Shell prompt. An argumentless MV command can only be issued from
Caché Terminal.
At the MultiValue Shell prompt you can issue MultiValue Shell commands, as
described in the Caché MultiValue Commands Reference. You can also issue Caché
MVBasic commands at this prompt by prefacing each MVBasic command with a
semicolon (;). Refer to the Caché MultiValue Basic Reference for further
details. You can exit the MultiValue Shell by issuing a QUIT command at the
MultiValue prompt.
MV commands
The MV command with the commands option also invokes the Caché MultiValue
Shell. It issues the specified MultiValue commands and then exits the
MultiValue Shell. It does not display the MultiValue Shell prompt.
You can specify one or more MultiValue Shell commands, as described in the
Caché MultiValue Commands Reference. Each command is specified as an expression
that evaluates to a quoted string. You can specify multiple MultiValue commands
as a comma-separated list.
You can also issue Caché MVBasic commands by prefacing each MVBasic command
with a semicolon (;). Refer to the Caché MultiValue Basic Reference for further
details.
Because MV commands automatically exits the MultiValue command environment,
specifying a MultiValue QUIT command has no effect.
Arguments
pc
An optional postconditional expression. Either form of MV can take a
postconditional. Caché executes the MV command if the postconditional
expression is true (evaluates to a nonzero numeric value). Caché does not
execute the command if the postconditional expression is false (evaluates to
zero). For further details, refer to Command Postconditional Expressions in 
Using Caché ObjectScript.
commands
One or more Caché MultiValue commands. Each command must be specified as a
quoted string. Multiple commands are separated by commas.
Examples
The following example issues several MultiValue commands and a MVBasic command.
It uses MVBasic to set a MultiValue lock, lists all of the processes locks,
clears all process-defined locks, and again lists all of the locks.

   SET lst="LIST.LOCKS"
   SET clr="CLEAR.LOCKS"
   SET lck=";LOCK 7"
   MV lck,lst,clr,lst


 #}}}
*MVPRINT*  #{{{

Performs MultiValue printing to terminal or printer.
Synopsis

MVPRINT:pc printlist
MVP:pc printlist

Arguments

pc         Optional  A postconditional expression. For further details, refer
           to Command Postconditional Expressions in Using Caché ObjectScript.

           Optional  Any MVBasic expression that resolves to a quoted string or
printlist  a numeric. You can specify a single expression or a series of
           expressions. If printlist is omitted, a blank line is returned.

Description
The MVPRINT command invokes the Caché MVBasic PRINT command, performs the
specified operation, and returns to the Caché ObjectScript environment. Specify
parameter values in MVBasic form.
Within printlist, you can specify tab and line return formatting using features
of ObjectScript WRITE command syntax, rather than MVBasic PRINT command syntax.
Only a limited subset of WRITE formatting syntax is supported: comma
(concatenate), question mark (tab), and exclamation mark (line return).
Multiple exclamation marks and numeric tabs are not supported. The following
table shows the format equivalences:

MVPRINT (ObjectScript)  PRINT (MVBasic)

MVPRINT a               PRINT a:

MVPRINT a,!             PRINT a

MVPRINT a,b,!           PRINT a:b

MVPRINT a,!,b,!         PRINT a PRINT b

MVPRINT a,?,b,!         PRINT a,b

For further details refer to the Caché MultiValue Basic Reference.
See Also

  • MVCRT command
  • WRITE command
  • PRINT command in Caché MultiValue Basic Reference


 #}}}
*NEW*  #{{{

Creates empty local variable environment.
Synopsis

NEW:pc newargument,...
N:pc newargument,...

where newargument can be:

variable,...
or
(variable,...)

Arguments

pc        Optional  A postconditional expression.

          Optional  Name of variable(s) to be added to the existing local
variable  variable environment. The effect of a NEW on existing local variables
          depends on whether variable is enclosed in parentheses (exclusive NEW
          ) or is not enclosed in parentheses (inclusive NEW).

Description
The NEW command has two forms:

  • Without an argument
  • With an argument

NEW without an argument creates an empty local variable environment for a
called subroutine or user-defined function. Existing local variable values are
not available in this new local environment. They can be restored by returning
to the previous local environment.
The action NEW with an argument performs depends on the argument form you use.

  • NEW variable (inclusive NEW) retains the existing local variable
    environment and adds the specified variable(s) to it. If any of the
    specified local variables has the same name as an existing local variable,
    the old value for that named variable is no longer accessible in the
    current environment.
  • NEW (variable) (exclusive NEW) replaces all existing variables in the local
    variable environment except the specified variable(s).

NEW Restrictions
The NEW command cannot be used on the following:

  • Globals
  • Process-Private Globals
  • Local variable subscripts
  • Private variables
  • Special variables, with the exception of $ETRAP

Attempting to use NEW in any of these contexts results in a <SYNTAX> error.
Arguments
pc
An optional postconditional expression. Caché executes the NEW command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
variable
Name of a single variable or a comma-separated list of variable names. You can
specify only unsubscripted variable names, although you can NEW an entire array
(that is, an array name without subscripts). You can specify undefined variable
names or you can reuse the names of existing local variables. For an inclusive 
NEW, when you specify an existing local variable, Caché reinitializes that
variable in the local environment, but saves its current value on the program
stack and restores it after the subroutine or function terminates.
When a variable name or comma-separated list of variable names is enclosed in
parentheses (exclusive NEW), Caché performs the opposite operation. That is,
all local variables are reinitialized except the specified variable names,
which retain their previous values. Caché saves the current values of all
variables on the program stack and restores them after the subroutine or
function terminates.
Examples
The following example illustrates an inclusive NEW, which keeps the existing
local variables a, b, and c, and adds variables d and e, in this case,
overlaying the prior value of d.

Main
  SET a=7,b=8,c=9,d=10
  WRITE !,"Before NEW:",!,"a=",a,!,"b=",b,!,"c=",c,!,"d=",d
  DO Sub1
  WRITE !,"Returned to prior context:"
  WRITE !,"a=",a,!,"b=",b,!,"c=",c,!,"d=",d
  QUIT
Sub1
  NEW d,e
  SET d="big number"
  WRITE !,"After NEW:",!,"a=",a,!,"b=",b,!,"c=",c,!,"d=",d
  QUIT
The following example illustrates an exclusive NEW, which removes all existing
local variables except the specified variables a and c.

  SET a=7,b=8,c=9,d=10
  NEW (a,c)
  WRITE
Notes
Where to Use NEW
NEW allows you to insulate the current process’s local variable environment
from changes made by a subroutine, user-defined function, or XECUTE string. NEW
is most frequently used within a subroutine called by the DO command.
The basic purpose of the NEW command is to redefine the local variable
environment within a called subroutine or user-defined function. A subroutine
or user-defined function called without parameter passing inherits its local
variable environment from the calling routine. To redefine this environment for
a subroutine or function, you can use NEW for all local variables (argumentless
NEW), for named local variables (inclusive NEW) or for all local variables
except the named variables (exclusive NEW).
Special considerations apply in the case of a subroutine called by the DO
command with parameter passing. These considerations are described under
"Subroutines with Parameter Passing".
NEW and KILL
Variables created by NEW do not require explicit and corresponding KILL
commands. When a called subroutine or a user-defined function terminates, Caché
executes an implicit KILL for each variable initialized by a NEW command within
that subroutine or function.
Inclusive NEW
An inclusive NEW  NEW variable  retains the existing local variable environment
and adds the specified variables to it. If an existing variable is named, the
"new" variable replaces the existing variable, which is saved on the stack and
then restored when the subroutine or function terminates.
In the following example, assume that the local variable environment of the
calling routine (Main) consists of variables a, b, and c. When the DO calls
Subr1, the NEW command redefines Subr1’s local variable environment to new
variable c and add variable d. After the NEW, the subroutine’s environment
consists of the existing variables a and b plus the new variables c and d. The
variables a and b are inherited and retain their existing values. The new
variables c and d are created undefined. Since c is the name of an existing
local variable, Caché saves the existing value on the stack and restores it
when Subr1 QUITs. Note that the first SET command in Subr1 references a and b
to assign a value to d. Note that variable c in this context is undefined.

Main
    SET a=2,b=4,c=6
    WRITE !,"c in Main before DO: ",c
    DO Subr1(a,b,c)
    WRITE !,"c in Main after DO: ",c
    QUIT
Subr1(a,b,c)
    NEW c,d
    IF $DATA(c) {WRITE !,"c=",c}
     ELSE {WRITE !,"c in Subr1 is undefined"}
    SET d=a*b
    SET c=d*2
    WRITE !,"c in Subr1: ",c
    QUIT
When executed, this code produces the following results:

c before DO: 6
c in Subr1 is undefined
c in Subr1: 16
c after DO: 6

The results are the same whether passing parameters by value, as in the
previous example, or passing parameters by reference:

Main
    SET a=2,b=4,c=6
    WRITE !,"c in Main before DO: ",c
    DO Subr1(.a,.b,.c)
    WRITE !,"c in Main after DO: ",c
    QUIT
Subr1(a,b,c)
    NEW c,d
    IF $DATA(c) {WRITE !,"c=",c}
     ELSE {WRITE !,"c in Subr1 is undefined"}
    SET d=a*b
    SET c=d*2
    WRITE !,"c in Subr1: ",c
    QUIT
Note that variable c is passed to Subr1 and then immediately redefined using 
NEW. In this case, passing variable c was unnecessary; the program results are
identical whether or not c is passed. If you NEW any of the variables named in
the subroutine’s formal parameter list, you render them undefined and make
their passed values inaccessible.
Exclusive NEW
An exclusive NEW  NEW (var1,var2)  replaces the entire existing local variable
environment except the specified variables. If an existing variable is named,
it is retained and can be referenced in the new environment. However, any
changes made to such a variable are reflected in the existing variable when the
function or subroutine terminates.
Exclusive NEW (NEW (x,y,z)) temporarily removes local variables from the
current scope. This can affect local variables created by Caché objects. For
example, Caché maintains %objcn which is the cursor pointer for Caché object
queries. Removing this from the current scope can result in collisions with
other internal structures. Therefore, do not use exclusive NEW in any context
where it might affect system structures.
Attempting to issue more than 31 levels of exclusive NEW or argumentless NEW
results in a <MAXSCOPE> error.
When using exclusive NEW in a FOR code block, you must specify the FOR count
variable as an excluded variable. For further details, refer to the FOR
command.
In the following example, assume that the local variable environment of the
calling routine (Start) consists of variables a, b, and c. When the DO calls
Subr1, the NEW command redefines Subr1’s local variable environment to exclude
all variables except c and d.
After the NEW, the subroutine’s environment consists only of the new variables 
c and d. The new variable c is retained from the calling routine’s environment
and keeps its existing value. The new variable d is created undefined.
The first SET command in Subr1 references c to assign a value to d. The second 
SET command assigns a new value (24) to c. When the subroutine QUITs, c will
have this updated value (and not the original value of 6) in the calling
routine’s environment.

Start    SET a=2,b=4,c=6
    DO Subr1
    WRITE !,"c in Start: ",c
    QUIT
Subr1    NEW (c,d)
    SET d=c+c
    SET c=d*2
    WRITE !,"c in Subr1: ",c
    QUIT
When executed, this code produces the following results:
c in Subr1: 24
c in Start: 24
Argumentless NEW
The argumentless NEW provides an empty local variable environment for a called
subroutine or user-defined function. The existing local variable environment
(in the calling routine) is saved and then restored when the subroutine or
function terminates. Any variables created after the NEW are deleted when the
subroutine or function terminates.
If a command follows the NEW on the same line, be sure to separate the NEW
command from the command following it by (at least) two spaces.
Argumentless NEW should not be used within the body of a FOR loop or in a
context in which it can affect Caché objects.
Attempting to issue more than 31 levels of exclusive NEW or argumentless NEW
results in a <MAXSCOPE> error.
$ETRAP and Special Variables
You cannot use NEW on special variables; attempting to do so results in a
<SYNTAX> error. The one exception is $ETRAP. When you issue the command 
NEW $ETRAP, Caché creates a new context for error trapping. You can then set 
$ETRAP in this new context with the desired error trapping command(s). The 
$ETRAP value in the previous context is preserved. If you set $ETRAP without
first issuing the NEW $ETRAP command, Caché sets $ETRAP to this value in all
contexts. It is therefore recommended that you always NEW the $ETRAP special
variable before setting it.
Subroutines with Parameter Passing
If you call a subroutine with parameter passing, Caché issues an implicit NEW
command for each of the variables named in the subroutine’s formal parameter
list. It then assigns the values passed in the DO command’s actual parameter
list (by value or by reference) to these variables.
If the DO command uses parameter passing by value and if the formal list names
any existing local variables, Caché places the existing variables and their
values on the stack. When the subroutine terminates (with either an explicit or
an implicit QUIT), Caché issues an implicit KILL command for each of the formal
list variables to restore them from the stack.
See Also

  • DO command
  • QUIT command
  • SET command
  • $ETRAP special variable


 #}}}
*OPEN*  #{{{

Acquires ownership of a specified device or file for input/output operations.
Synopsis

OPEN:pc device:(parameters):timeout:"mnespace",...
O:pc device:(parameters):timeout:"mnespace",...

Arguments

pc          Optional  A postconditional expression.

            The device to be opened, specified by a device ID or a device
            alias. A device ID can be an integer (a device number), a device
device      name, or the pathname of a sequential file. If a string, it must be
            enclosed with quotation marks. The maximum length of device is 256
            characters for Windows and UNIX, 245 characters for OpenVMS.

            Optional  The list of parameters used to set device
            characteristics. The parameter list is enclosed in parentheses, and
            the parameters in the list are separated by colons. Parameters can
parameters  either be positional (specified in a fixed order in the parameter
            list) or keyword (specified in any order). A mix of positional and
            keyword parameters is permitted. The individual parameters and
            their positions and keywords are highly device-dependent.

            Optional  The number of seconds to wait for the request to succeed,
timeout     specified as an integer. Fractional seconds are truncated to the
            integer portion.

mnespace    Optional  The name of the mnemonic space that contains the control
            mnemonics to use with this device, specified as a quoted string.

Description
Use the OPEN command to acquire ownership of a specified device (or devices)
for input/output operations. An OPEN retains ownership of the device until
ownership is released with the CLOSE command.
An OPEN command can be used to open multiple devices by using a comma to
separated the specifications for each device. Within the specification of a
device, its arguments are separated by using colons (:). If an argument is
omitted, the positional colon must be specified; however, trailing colons are
not required.
The OPEN command can be used to open devices such as terminal devices, magnetic
tape devices, spool devices, TCP bindings, interprocess pipes, named pipes, and
interjob communications.
The OPEN command can also be used to open a sequential file. The device
argument specifies the file pathname as a quoted string. The parameters
argument specifies the parameters governing the sequential file. These
parameters can include the option of creating a new file if the specified file
does not exist. Specifying the timeout argument, though optional, is strongly
encouraged when opening a sequential file. Sequential file open option defaults
are set for the current process using the $ZUTIL(68,2) and $ZUTIL(68,3)
functions, and system-wide by using the $ZUTIL(69,2) and $ZUTIL(69,3)
functions. For much more details on opening sequential files, see Sequential
File I/O in the Caché I/O Device Guide.
The OPEN command is not used to access a Caché database file.
On Windows, Caché ObjectScript allocates each process an open file quota
between database files and files opened with OPEN. When OPEN causes too many
files to be allocated to OPEN commands, you receive a <TOOMANYFILES> error.
Caché does not limit the number of open files; the maximum number of open files
for each process is a platform-specific setting. Consult the operating system
documentation for your system.
Arguments
pc
An optional postconditional expression. Caché executes the OPEN command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the OPEN command if the postconditional expression is
false (evaluates to zero). Only one postconditional is permitted, even if the 
OPEN command opens multiple devices or files. For further details, refer to
Command Postconditional Expressions in Using Caché ObjectScript.
device
The device to be opened. You can specify the device using any of the following:

  • Physical device number, specified as a positive integer. For example, 2 is
    always the spooler device. This is the only way to specify a magnetic tape
    device (numbers 47 through 62). This number is internal to Caché and is
    unrelated to device numbers assigned by the platform operating system.
  • Device ID, specified as a quoted string. For example, "|TRM|:|4294318809".
    This value for the current device is found in the $IO special variable.
  • Device alias, specified as a positive integer. A device alias refers to a
    physical device number.
  • File pathname, specified as a quoted string. This is used for opening
    sequential files. A pathname can be canonical (c:\myfiles\testfile) or
    relative to the current directory (\myfiles\testfile).

The maximum length of device is 256 characters for Windows and UNIX, 245
characters for OpenVMS. See "Specifying the Device" for more information.
parameters
The list of parameters used to set operating characteristics of the device to
be opened. The enclosing parentheses are required if there is more than one
parameter. (It’s good programming practice to always use parentheses when you
specify a parameter.) Note the required colon before the left parenthesis.
Within the parentheses, colons are used to separate multiple parameters.
The parameters for a device can be specified using either positional parameters
or keyword parameters. You can also mix positional parameters and keyword
parameters within the same parameter list.
In most cases, specifying contradictory, duplicate, or invalid parameter values
does not result in an error. Wherever possible, Caché ignores inappropriate
parameter values and takes appropriate defaults.
If you do not specify a list of parameters, Caché uses the device’s default
parameters. The default parameters for a device are configurable. Go to the
System Management Portal, select [Home] > [Configuration] > [Device Settings] >
[Devices] to display the current list of devices. For the desired device, click
 edit to display its Open Parameters: option. Specify this value in the same
way you specify the OPEN command parameters, including the enclosing
parentheses. For example, ("AVL":0:2048).
The available parameters are specific to the type of device that is being
opened. For more information on device parameters, see I/O Devices and Commands
in Caché I/O Device Guide.
Positional Parameters
Positional parameters must be specified in a fixed sequence in the parameter
list. You can omit a positional parameter (and receive the default value), but
you must retain the colon to indicate the position of the omitted positional
parameter. Trailing colons are not required; excess colons are ignored. The
individual parameters and their positions are highly device-dependent. There
are two types of positional parameters: values and letter code strings.
A value can be an integer (for example, record size), a string (for example,
host name), or a variable or expression that evaluates to a value.
A letter code string uses individual letters to specify device characteristics
for the open operation. For most devices, this letter code string is one of the
positional parameters. You can specify any number of letters in the string, and
specify the letters in any order. Letter codes are not case sensitive. A letter
code string is enclosed in quotation marks; no spaces or other punctuation is
allowed within a letter code string (exception: K and Y may be followed by a
name delimited by backslashes: thus: K\name\). For example, when opening a
sequential file, you might specify a letter code string of  ANDFW (append to
existing file, create new file, delete file, fix-length records, write access.)
The position of the letter code string parameter, and the meanings of
individual letters is highly device-dependent.
Keyword Parameters
Keyword parameters can be specified in any sequence in the parameter list. A
parameter list can consist entirely of keyword parameters, or it can contain a
mix of positional and keyword parameters. (Commonly, the positional parameters
are specified first (in their correct positions) followed by the keyword
parameters.) You must separate all parameters (positional or keyword) with a
colon (:). A parameter list of keyword parameters has the following general
syntax:

OPEN device:(/KEYWORD1=value1:/KEYWORD2=value2:.../KEYWORDn=valuen):timeout

The individual parameters and their positions are highly device-dependent. As a
general rule, you can specify the same parameters and values using either a
positional parameter or a keyword parameter. You can specify a letter code
string as a keyword parameter by using the /PARAMS keyword.
timeout
The number of seconds to wait for the OPEN request to succeed. The preceding
colon is required. timeout must be specified as an integer value or expression.
If timeout is set to zero (0), OPEN makes a single attempt to open the file. If
the attempt fails, the OPEN immediately fails. If the attempt succeeds it
successfully opens the file. If timeout is not set, Caché will continue trying
to open the device until the OPEN is successful or the process is terminated
manually. If you use thetimeout option and the device is successfully opened,
Caché sets the $TEST special variable to TRUE (nonzero). If the device cannot
be opened within the timeout period, Caché sets $TEST to FALSE (0).
mnespace
The name of the mnemonic space that contains the device control mnemonics used
by this device. By default, Caché provides two mnemonic spaces: ^%XMAG for
magnetic tape devices, and ^%X364 (ANSI X3.64 compatible) for all other devices
and sequential files. Default mnemonic spaces are assigned by device type.
Go to the System Management Portal, select [Home] > [Configuration] > [Device
Settings] > [IO Settings]. View and edit the File, MagTape, Other, or Terminal
mnemonic space setting.
A mnemonic space is a routine that contains entry points for the device control
mnemonics used by READ and WRITE commands. The READ and WRITE commands invoke
these device control mnemonics using the /mnemonic(params) syntax. These device
control mnemonics perform operations such a moving the cursor to a specified
screen location or rewinding a magnetic tape.
Use the mnespace argument to override the default mnemonic space assignment.
Specify a Caché ObjectScript routine that contains the control mnemonics entry
points used with this device. The enclosing double quotes are required. Specify
this option only if you plan to use device control mnemonics with the READ or 
WRITE command. If the mnemonic space does not exist, a <NOROUTINE> error is
returned. For further details on mnemonic spaces, see I/O Devices and Commands
in the Caché I/O Device Guide.
Examples
In the following example, the OPEN command attempts to acquire ownership of
device 2 (the spooler). The first positional parameter (3) specifies the file
number within the ^SPOOL global and the second positional parameter (12)
specifies the line number within the file. If you later use the USE command to
make this the current device (that is, USE 2), Caché ObjectScript sends
subsequent output to the spooler.

   OPEN 2:(3:12)

In the following example, the OPEN command attempts to acquire ownership of the
sequential file CUSTOMER within the timeout period of 10 seconds.

   OPEN "\myfiles\customer"::10

Note that because no parameters are specified, the parentheses are omitted, but
the colon must be present.
The following example opens a sequential file named Seqtest; the letter code
positional parameter is  NRW . The  N letter code specifies that if the file
does not exist, create a new sequential file with this name. The  R and  W 
letter codes specify that the file is being opened for reading and writing. The
timeout is 5 seconds.

  ZNSPACE "%SYS"
  SET dir=$ZUTIL(168)  ; determine CachÃ© directory
  SET seqfilename=dir_"Samples\Seqtest"
  OPEN seqfilename:("NRW"):5
    WRITE !,"Opened a sequential file named Seqtest"
    USE seqfilename
    WRITE "a line of data for the sequential file"
  CLOSE seqfilename:"D"
  WRITE !,"Closed and deleted Seqtest"
  QUIT
This example requires that UnknownUser have assigned the %DB_CACHESYS role.
Notes
Device Ownership and the Current Device
OPEN establishes ownership of the specified device. The process retains
ownership of the device until the process either terminates or releases the
device with a subsequent CLOSE command. While a device is owned by a process,
no other process can acquire or use the device.
A process can own multiple devices at the same time. However, only one device
can be the current device. You establish an owned device as the current device
with the USE command. The ID of the current device is found in the $IO special
variable.
A process always owns at least one device (designated as device 0), which is
its principal device. This device is assigned to the process when it is started
and is typically the terminal used to sign onto Caché. The ID of the principal
device is found in the $PRINCIPAL special variable.
When a process terminates, Caché issues an implicit CLOSE for each of the
devices owned by the process and returns them to the pool of available devices.
Changing Parameters for an Owned Device
To change the parameters for a device that is already owned by the process, you
can:

  • Close and then reopen the device with new parameter values.
  • If the device is a terminal, TCP, or magnetic tape device, you can issue an
    OPEN with new parameter values on an already open device.

If you specify the device on another OPEN command, any device parameters set by
the initial OPEN command remain in effect unless explicitly changed. Depending
on the type of device, subsequent I/O may be different than if you had closed
and then reopened the device.
For some devices, you can omit the parameters option and later set the desired
characteristics with the parameters option on the USE command.
Specifying the Device
When you open a device, you can identify the device by supplying a device
number or an alias assigned to the device.
Using Physical Device Numbers
Caché allows you to identify certain devices by supplying their system-assigned
physical device numbers. All implementations of Caché recognize the following
physical device numbers:

  • 0 = The process’s principal device (usually the device at which you sign
    on).
  • 2 = The spooler (to store output for later printing).
  • 63 = The view buffer.

Open 63 accepts a namespace as follows:

   OPEN 63:namespace

See About I/O Devices in Caché I/O Device Guide for more information about
device numbers.
Using a Device Alias
An alias is an alternate numeric device ID. It must be a valid device number,
it must be unique and cannot conflict with an assigned device number.
You can establish a numeric alias for a device. Go to the System Management
Portal, select [Home] > [Configuration] > [Device Settings] > [Devices] to
display the current list of devices and their aliases. For the desired device,
click  edit to edit its Alias: option.
After you have assigned an alias to a device, you can use the OPEN command or
the %IS utility to open the device using this alias.
Exceeding the Open File Quota
Caché allocates each process' open file quota between database files and files
opened with OPEN. When OPEN causes too many files to be allocated to OPEN
commands, you receive a <TOOMANYFILES> error.
Default Record Length
If the record size for sequential files is not specified in the OPEN command,
Caché assumes a default record length of 32,767 characters regardless of
whether long strings are enabled or not.
See Also

  • CLOSE command
  • USE command
  • $TEST special variable
  • $IO special variable
  • $ZUTIL(55) Language Mode Switch function
  • $ZUTIL(96,14) Current Device Type function
  • I/O Devices and Commands in Caché I/O Device Guide
  • Terminal I/O in Caché I/O Device Guide
  • TCP Client/Server Communication in Caché I/O Device Guide
  • Magnetic Tape I/O in Caché I/O Device Guide
  • Sequential File I/O in Caché I/O Device Guide
  • The Spool Device in Caché I/O Device Guide
  • ^%IS global and %IS utility in Caché I/O Device Guide


 #}}}
*PRINT*  #{{{

Displays lines of code from the current routine on the current device.
Synopsis

PRINT:pc printargument
P:pc printargument

where printargument can be:

 lineref1:lineref2

Arguments

pc        Optional  A postconditional expression.

lineref1  Optional  A line to be printed, or the first line of a range of lines
          to be printed.

lineref2  Optional  The last line of a range of lines to be printed.

Description
The PRINT command has two forms:

  • Without an argument
  • With an argument

PRINT without an argument prints all the lines of code in the currently loaded
routine.
PRINT with an argument prints the lines from the currently loaded routine that
you specify in the argument. PRINT lineref1 prints a single specified line of
code (lineref1). PRINT lineref1:lineref2 prints the range of lines that starts
with lineref1 and ends with lineref2.
Arguments
pc
An optional postconditional expression. Caché executes the PRINT command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
lineref1
A line to be printed. It can be specified in either of the following forms:

+offset  offset is a positive integer specifying the line number within the
         current routine.

label    label is a label within the routine and offset is the line number
[+       within the label. If you omit offset, Caché prints the first code line
offset]  and the label. With this form, offset actually evaluates to offset+1.
         For example, label+1 prints the second line within the label.

lineref2
The last line in a range of lines to be printed. Specified the same as lineref1
. The preceding colon is required.
Examples
This example prints the sixth line in the currently loaded routine.

   PRINT +6

This example prints the third through eighth lines.

   PRINT +3:+8

Notes
Printing to the Current Device
The output from PRINT is sent to the current device. You establish the current
device with the USE command. Caché maintains the current device ID in the $IO
special variable.
Printing a Range
To print a range, include the lineref2 option. lineref2 can be specified in the
same two forms as lineref1. Consider the following example:

   PRINT Getid:Getid+6

The previous example prints the first through seventh (offset+1) lines within
label Getid.
You can use different label names when specifying a range, but only if the
second label follows the first. For example, if label Checkid follows label
Getid, the following command prints only the first line of Checkid:

   PRINT Checkid:Getid+2

On the other hand, the following command prints all lines from the first line
in Getid to the third line in Checkid:
PRINT Getid:Checkid+3
ZPRINT Equivalent to PRINT
The ZPRINT command is the equivalent of the PRINT command.
See Also

  • ZLOAD command
  • ZPRINT command
  • ZREMOVE command
  • The Spool Device in Caché I/O Device Guide


 #}}}
*QUIT*  #{{{

Terminates execution.
Synopsis

QUIT:pc expression
Q:pc expression

Arguments

pc          Optional  A postconditional expression.

expression  Optional  A Caché ObjectScript expression.

Description
The QUIT command has two forms:

  • Without an argument
  • With an argument

A postconditional is not considered an argument. The $QUIT special variable
indicates whether or not an argumented QUIT command is required to exit from
the current context. Two error codes are provided for this purpose: M16  Quit
with an argument not allowed and M17  Quit with an argument required. For
further details, see $ECODE and the ANSI-Standard M Error Messages listing in
the Caché Error Reference.
QUIT Without an Argument
QUIT without an argument terminates the execution level of a process started
with a DO, XECUTE, or FOR command.
If the DO, XECUTE, or (unnested) FOR command was given in programmer mode, QUIT
returns control to programmer mode. If the terminated process contains any NEW
commands before QUIT, QUIT automatically KILLs the affected variables and
restores them to their original values.
QUIT With an Argument
QUIT expression terminates a user-defined function or an object method and
returns the value resulting from the specified expression. QUIT with an
argument cannot be used to exit a procedure from within a FOR or WHILE command
loop.
If an argumented QUIT is invoked inside a subroutine, one of the following
occurs:

  • If the subroutine was called with parameter passing, Caché ignores the QUIT
    argument and returns execution to the caller of the subroutine. It does not
    generate an M16 "Quit with an argument not allowed" error.
  • If the subroutine was called by a DO command and is in the scope of that DO
    argument, then the QUIT command evaluates its argument (and any side
    effects of that evaluation occur).

Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript. If the QUIT command takes no other
arguments, there must be two or more spaces between the postconditional and the
next command following it on the same line.
expression
Any valid Caché ObjectScript expression. It can be used only within a
user-defined function to return the evaluated result to the calling routine.
Examples
In this example, execution of the QUIT command is controlled by a
postconditional (:x<0); if the user-supplied number is negative, Caché does not
perform the procedure and QUIT returns control to the calling routine.

Main
  READ !,"Enter number:",x
  SET num=$$Cube(x)
  WRITE !,"Cube is: ",num
  QUIT
Cube(x)  QUIT:x<0 "a negative number."
  QUIT x*x*x

In this example, the argument of the QUIT command is an object method. Caché
terminates execution of the method and returns control to the calling routine.

   QUIT inv.TotalNum()

Notes
QUIT Restores Variables
If a terminated process contains any NEW commands before QUIT, QUIT
automatically KILLs the affected variables and restores them to their original
values.
QUIT and Loops
A QUIT can be used to break out of a FOR loop, a DO WHILE loop, or a WHILE
loop. If these loop structures are nested, the QUIT breaks out of the loop from
which it was called to the next enclosing loop.
A QUIT cannot be used to break out of a nested IF block. When an IF block is
nested within a loop structure (such as a FOR loop), a QUIT in the IF block
breaks out of the enclosing loop as well.
Implicit QUIT
In the following cases, a QUIT command is not required, because Caché
automatically issues an implicit QUIT to prevent execution "falling through" to
a separate unit of code.

  • Caché executes an implicit QUIT at the end of a routine.
  • Caché executes an implicit QUIT when it encounters a label with parameters.
    A label with parameters is defined as one with parentheses, even if the
    parentheses contain zero parameters. All procedures begin with a label with
    parameters (even if no parameters are defined). Many subroutines and
    functions also have a label with parameters.

You can, of course, code an explicit QUIT in any of these circumstances.
Behavior with DO
When encountered in a subroutine called by the DO command, QUIT terminates the
subroutine and returns control to the command following the DO command.
Behavior with XECUTE
When encountered in a line of code that is being executed, QUIT terminates
execution of the line and returns control to the command following the XECUTE
command. No argument is allowed.
Behavior with Loop Structures
When encountered in a loop structure, such as a FOR loop, QUIT terminates that
loop and returns control to the next command outside the range of the loop. In
the case of nested loops, QUIT affects only the loop in which it occurs and any
lower level loops that might be executed as a result of that loop. Higher level
loops are not terminated.
To control an indefinite FOR loop, you must include either a postconditioned 
QUIT or an IF command that invokes a QUIT. The QUIT within the IF terminates
the enclosing FOR loop. Without one of these QUITs, the loop will be an
infinite loop and will execute endlessly.
In the following example, the FOR loop continues to execute as long as the user
enters some value in response to the "Text =" prompt. Only when the user enters
a null string (that is, just presses Return or Enter) is QUIT executed and the
loop terminated.

Main
  FOR   {
    READ !,"Text =",var1
    QUIT:var1=""  DO Subr1
    }
Subr1
   WRITE "Thanks for the input", !
   QUIT

This command includes two spaces between the postconditional on the QUIT
command and the following DO command. This is because Caché treats
postconditionals as command modifiers, not as arguments.
Behavior with User-Defined Functions
When encountered in a user-defined function, QUIT terminates the function and
returns the value that results from the specified expression. The expression
argument is required.
In their use, user-defined functions are similar to DO commands with parameter
passing. They differ from such DO commands, however, in that they return the
value of an expression directly, rather than through a variable. To invoke a
user-defined function, use the form:
$$name(parameters)
where name is the name of the function. It can be specified as label, ^routine,
or label^routine.
parameters is a comma-separated list of parameters to be passed to the
function. The label associated with the function must also have a parameter
list. The parameter list on the invoked function is known as the 
actual parameter list. The parameter list on the function label is known as the
formal parameter list.
In the following example, the FOR loop uses a READ command to first acquire the
number to be squared and store it in the num variable. (Note the two spaces
after the argumentless FOR and the postconditional QUIT.) It then uses a WRITE
command to invoke the Square standard function, with num specified as the
function parameter.
The only code for the function is the QUIT command followed by an expression to
calculate the square. When it encounters the QUIT command, Caché evaluates the
expression, terminates the function, and returns the resulting value directly
to the WRITE command. The value of num is not changed.

Test  WRITE "Calculate the square of a number",!
  FOR   {
    READ !,"Number:",num QUIT:num=""
    WRITE !,$$Square(num),!
    QUIT
  }
Square(val)
  QUIT val*val

Clearing Levels from the Program Stack
Each invocation of QUIT removes a context frame from the call stack for your
process. The $STACK special variable contains the current number of context
frames on the call stack.
You can use QUIT from the programmer prompt to clear some or all levels from
the program stack. The following example clears the top two levels from the
stack:

   QUIT 2

The argumentless QUIT clears all the levels from the stack.
Using QUIT for Program Readability
Caché executes an implicit QUIT at the end of each routine, but you can include
it explicitly to improve program readability.
See Also

  • DO command
  • DO WHILE command
  • FOR command
  • NEW command
  • WHILE command
  • XECUTE command
  • ZQUIT command
  • $QUIT special variable
  • $STACK special variable


 #}}}
*READ*  #{{{

Accepts input and stores it in a variable.
Synopsis

READ:pc readargument,...
R:pc readargument,...

where readargument is

fchar
prompt
variable:timeout
*variable:timeout
variable#length:timeout

Arguments

pc        Optional  A postconditional expression.

fchar     Optional  One or more format control characters. Permitted characters
          are !, #, ?, and /.

prompt    Optional  A string literal that provides a prompt or message for user
          input. Enclose in quotation marks.

          The variable to receive the input data. Can be a local variable, a
variable  process-private global, or a global. May be unsubscripted or
          subscripted.

          Optional  The number of characters to accept, specified as an
length    integer, or an expression or variable that evaluates to an integer.
          The preceding # symbol is mandatory.

          Optional  The number of seconds to wait for the request to succeed,
timeout   specified as an integer. Fractional seconds are truncated to the
          integer portion. The preceding colon (:) is mandatory.

You can specify more that one fchar or prompt argument by separating the
arguments with commas.
Description
The READ command accepts input from the current device. The current device is
established using the OPEN and USE commands. The $IO special variable contains
the device ID of the current device. By default, the current device is the user
terminal.
The READ command suspends program execution until it either receives input from
the current device or times out. For this reason, the READ command should not
be used in programs executed as background (non-interactive) jobs if the
current device is the user terminal.
The variable argument receives the input characters. READ first defines 
variable, if it is undefined, or clears it if it has a previous value.
Therefore, if no data is input for variable (for example, if the READ times out
before any characters are entered) variable is defined and contains the null
string. This is also true if the only character entered is a terminator
character (for example, pressing the <Enter> key from the user terminal). For
the effects of an interrupt (for example, <Ctrl-C>) see below.
Note that for fixed-length and variable-length reads, variable does not store
the terminator character used to terminate the read operation. Single-character
reads handle variable differently; for single-character read use of variable,
see below.
If you specify the optional timeout value, a READ can time out before all
characters are input. If a READ times out, those characters input before the
timeout are stored in variable. Entering a terminator character is not
necessary in this case; the characters entered before the timeout are
transferred to variable, and the READ terminates, setting $TEST equal to 0.
There are three types of READ operations: variable-length read, fixed-length
read, and single-character read. All of these can be specified with or without
a timeout argument. A single READ command can include multiple READ operations
in any combination of these three types. Each read operation is executed
independently in left-to-right sequence. A READ command can also contain any
number of comma-separated prompt and fchar arguments.
The three types of READ operations are as follows:

  • A variable-length read has the following format:
    READ variable
    A variable-length read accepts any number of input characters and stores
    them in the specified variable. Input is concluded by a terminator
    character. For a terminal, this terminator is usually supplied by pressing
    the <Enter> key. The input characters, but not the terminator character,
    are stored in variable.
  • A fixed-length read has the following format:
    READ variable#length
    A fixed-length read accepts a maximum of length input characters and stores
    them in the specified variable. Input concludes automatically when the
    specified number of characters is input, or when a terminator character is
    encountered. For example, entering two characters in a four-character
    fix-length read, and then pressing the <Enter> key. The input characters,
    but not the terminator character (if any), are stored in variable.
  • A single-character read has the following format:
    READ *variable
    A single-character read accepts a single input character and stores its
    ASCII numeric value equivalent in the specified variable. It stores the
    character itself in the $ZB and $KEY special variables. Input concludes
    automatically when a single character is input. A terminator character is
    considered a single-character input, and is stored as such. If the optional
    timeout argument is specified, and a timeout occurs, the timeout sets 
    variable to  1.

Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
fchar
Any of the following format control codes. When used with user input from the
keyboard, these controls determine where a specified prompt or the user input
area will appear on the screen.
! starts a new line. You may specify multiple exclamation points
# starts a new page. On a terminal, it clears the current screen and starts at
the top of the new screen.
?n positions at the nth column location, where n is a positive integer.
/keyword(parameters) A device control mnemonic. Performs a device-specific
operation, such as positioning the cursor on a video terminal or rewinding a
magnetic tape. The slash character (/) is followed by a keyword, which is
optionally followed by one or more parameters enclosed in parentheses. Multiple
parameters are separated by commas. The keyword is an entry point label into
the current device’s mnemonic space routine.
You can establish the default mnemonic space for a device type in either of the
following ways:

  • Go to the System Management Portal, select [Home] > [Configuration] >
    [Device Settings] > [IO Settings]. View and edit the File, MagTape, Other,
    or Terminal mnemonic space setting.
  • Include the /mnemonic space parameter in the OPEN or USE command for the
    device.

You can specify multiple format controls. For example: #!!!?20 means to start
at the top of a new page (or screen), go down three lines, and then position to
column 20. You can intersperse format control characters with other
comma-separated READ arguments. For example:

  READ #!!,"Please enter",!,"your name: ",x,"THANK YOU"

Displays something like the following:

>

Please enter
your name: FRED
THANK YOU
>

prompt
A string literal that provides a prompt or message for user input with the
terminal keyboard. Generally, a prompt argument is followed by a variable, so
that the user input area follows the displayed literal. You can specify a
multi-line prompt or message by using a comma-separated series of prompt and 
fchar arguments.
variable
The local variable, process-private global, or global that is to receive the
input data. It can be either unsubscripted or subscripted. If a specified
variable does not already exist, Caché defines it at the beginning of the READ
operation. If a specified variable is defined and has a value, Caché clears
this value at the beginning of the READ operation.
When you input characters, they are stored in variable as they are input. If
the optional timeout argument is specified, and the read operation is
interrupted by a timeout, the characters typed up to that point are stored in 
variable. (However, note the behavior of variable upon a encountered a <Ctrl-C>
interrupt, as described below.)
Nonprinting characters (such as <Tab>) are stored in variable. A terminator
character can be used to conclude any type of read operation. For example, from
a terminal, you press the <Enter> key to conclude a read operation. This
terminator character is not stored in variable for a variable-length or
fixed-length read. The terminator character is stored in variable for a
single-character read.
length
A positive integer specifying the maximum number of characters to accept for a
fixed-length read. The READ completes either when the specified number of
characters is input, or when it encounters a terminator character. This
argument is optional, but if specified the preceding # symbol is required.
Specifying zero or a negative number results in a <SYNTAX> error. However,
leading zeros and the fractional portion of a number are ignored, and the
integer portion used. You can specify length as a variable or an expression
that resolve to an integer.
Note that READ a#1 and READ *a can both be used to input a single character.
However the value stored in variable is different: a#1 stores the input
character in variable a; *a stores the ASCII numeric value for the input
character in variable a; both store the input character in the $ZB special
variable. These two types of single-character input also differ in how they
handle terminator characters and how they handle a timeout.
timeout
The number of seconds to wait for the request to succeed. This argument is
optional, but if specified, the preceding colon is required. You must specify 
timeout as an integer or an expression that evaluates to an integer. The 
timeout argument sets the $TEST special variable as follows:

  • READ with timeout argument completes successfully (does not time out): 
    $TEST set to 1.
  • READ with timeout argument times out: $TEST set to 0.
  • READ with no timeout argument: $TEST remains set to its previous value.

If the timeout period expires before the READ completes and some characters
have been input (for a variable-length or fixed-length reads) the input
characters are stored in variable. If no characters have been input (for a
variable-length or fixed-length reads), Caché defines variable (if necessary)
and sets it to the null string. If no character has been input for a
single-character READ, Caché defines variable (if necessary) and sets it to  1.
Examples
The following example uses the variable-length form of READ to acquire any
number of characters from the user. The format control ! starts the prompt on a
new line.

   READ !,"Enter your last name: ",lname

The following example uses the single-character form of READ to acquire one
character from the user and store it as its ASCII numeric value.

   READ !,"Enter option number (1,2,3,4): ",*opt
   WRITE !,"ASCII value input=",opt
   WRITE !,"Character input=",$KEY

The following example uses the fixed-length form of READ to acquire exactly
three characters from the user.

   READ !,"Enter your 3-digit area code: ",area#3

The following example prompts for three parts of a name: a fixed-length given
name (gname) of up to 12 characters, a fixed-length (one-character) middle
initial (iname), and a family name (fname) of any length. The gname and iname
variables are coded to time out after 10 seconds:

   READ "Given name:",gname#12:10,!,
        "Middle initial:",iname#1:10,!,
        "Family name:",fname
   WRITE $TEST

A timeout of a read operation causes the READ command to proceed to the next
read operation. The first two read operations set $TEST whether or not they
time out. The third read operation does not set $TEST, so the value of $TEST in
this example reflects the result (success or timeout) of the second read
operation.
The following example uses indirection to dynamically change the prompt
associated with the READ command:

PromptChoice
   SET MESS(1)="""ENTER A NUMBER:"""
   SET MESS(2)="""ENTER A NAME:"""
   READ "Type 1 for numbers or 2 for names:",p,#!!!!
   SET a=1
DataInput
   READ !,@MESS(p),x(a)
   SET a=a+1
   GOTO DataInput

The following example sets the length of a fixed-length read based on the value
of the first number input:

STRT    READ "ENTER LARGEST NUMBER (and press return): ",val(1)
     IF val(1)>99 { SET ibuf=3 }
        ELSEIF val(1)>9 { SET ibuf=2 }
     ELSE { SET ibuf=1 }
        SET x=2
LOOP
        READ !,"ENTER NEXT NUMBER: ",val(x)#ibuf
        SET x=x+1
        GOTO LOOP

Notes
READ Uses the Current Device
READ inputs character-oriented data from the current I/O device. You must open
a device with the OPEN command, then establish it as the current device with
the USE command. Caché maintains the current device ID in the $IO special
variable.
While the most common use for READ is to acquire user input from the keyboard,
you can also use it to input characters from any byte-oriented device, such as
a magnetic tape, a sequential disk file, or a communications buffer.
Read Line Recall
Read line recall mode permits a READ command on a terminal device to receive as
its input a previously input line. This recalled input line can then be edited.
The user must interactively conclude the input of a recalled line in the same
way that user-specified input is concluded. Caché supports read line recall for
both variable-length terminal reads (READ variable) and fixed-length terminal
reads (READ variable#length). Caché does not support read line recall for
single-character terminal reads (READ *variable). For further details, refer to
$ZUTIL(68,11) Read Line Recall Mode Process Switch, $ZUTIL(69,11) Read Line
Recall Mode System Default, and the OPEN and USE protocols for terminals, as
described in the Terminal I/O chapter of the Caché I/O Device Guide.
READ Terminators
Caché terminates a read operation when the input string reaches the specified
length (for single-character READ and fixed-length READ). For a variable-length
READ, Caché terminates reading if the input string reaches the maximum string
length for the current process.
Caché also terminates reading when it encounters certain terminator characters.
The terminators are determined by the device type. For example, with terminals,
the default terminators are RETURN (also known as the <Enter> key) (ASCII 13),
LINE FEED (ASCII 10), and ESCAPE (ASCII 27).
You can modify the terminator default when you issue an OPEN or USE command for
a device. OPEN and USE allow you to specify a terminator parameter value. See
the Terminal I/O chapter of the Caché I/O Device Guide for OPEN and USE
protocols for terminals. See the I/O Devices and Commands chapter of the 
Caché I/O Device Guide for details about terminators based on device type.
Caché does not store the input terminator with the input value for
variable-length and fixed-length reads; it records it in the $KEY and $ZB
special variables. Caché does store the input terminator (if specified) as the
input value for a single-character read.
Timeout and the $ZA, $ZB, and $TEST Special Variables
Caché records the completion status of a READ in the $TEST, $ZA, and $ZB
special variables, as follows:

     Type of READ          Variable data      $TEST   $ZA value     $ZB value
                                              value

Variable, ended with    input characters (or  1       0           terminator
line return             null string if none)                      character

Variable, some input,   input characters      0       2           null string
then timeout

Variable, no input,     null string           0       2           null string
timeout

Fixed, all chars                                                  the last
entered                 input characters      1       0           character
                                                                  entered

Fixed, line return      input characters (or  1       0           terminator
                        null string if none)                      character

Fixed, timed out        input characters (or  0       2           null string
                        null string if none)

Single character, data  ASCII value of input  1       0           the input
input                   character                                 character

Single character,       ASCII value of                0 <Enter>,  terminator
terminator character    terminator character  1       256 <Esc>   character
input

Single character,        1                    0       2           null string
timed out

$ZB and $KEY
The $ZB and $KEY special variables return the exact same value for every type
of read, except one. When you perform a fixed-length read and input the
specified number of characters, the READ completes without a terminator. In
this case, $ZB contains the last character input (the terminating character),
and $KEY contains the null string (there being no terminator character).
Interrupts
If a read operation is interrupted, variable reverts to its previous state. For
example, if you input several characters for a read operation, and then issue a
<Ctrl-C> interrupt, variable reverts to its state before the read operation.
That is, if it was undefined, it remains undefined; if it had a previous value,
it contains the previous value. This behavior is completely different than a
read operation that times out. A read timeout retains the new state of variable
, including any characters input before the timeout occurred. If a READ command
contains multiple read operations, the interrupt affects only the read
operation in progress. To commit or revert multiple read operations as a unit,
use transaction processing.
Reading from Non-Keyboard Devices
As described earlier, READ can be used to acquire input from any
character-oriented device. This includes devices such as magnetic tapes and
sequential disk files, as well terminal keyboards. However, you must first
establish the device to read from as the current device with the OPEN and USE
commands.
With non-keyboard devices, you can use any of the three available forms
(variable-length, single-character, and fixed-length). The choice of which form
to use in any given case depends on the type of terminator available. With
fixed-length READ, Caché treats terminators encountered within the input string
the same as any other character.
For example, if you are reading from a device that presents data in a
line-oriented format with CARRIAGE RETURN/LINE FEED as the line terminator, you
can use the variable-length form. In this case, Caché reads each line into 
variable in its entirety, terminating input only when it reaches the Return
(ASCII code 13) at the end of the line. (Remember, from the user input examples
shown previously, that <Return> is the input terminator.)
On the other hand, if you are reading from a magnetic tape that presents
records as a series of fixed-length fields, you would use the fixed-length (
variable#length) form. For example, assume that you have a mag tape that uses a
record format consisting of four fields of up to 8, 12, 4, and 6 characters,
respectively. You might use code similar to the following to read in the data:

   READ field1#8,field2#12,field3#4,field4#6

In this case, the #n value sets the input terminator for each field.
Which terminator is used for a given device can be set by the device parameters
that you specify for that device on the OPEN or USE command.
When reading block-oriented data from magnetic tape, the $ZB special variable
contains the number of bytes remaining in the I/O buffer. Its function is
entirely different than its use when reading character-oriented data. $ZB does
not contain the read terminator character or the last input character during
block-oriented I/O. Refer to $ZB for further details.
Reading Nonprinting Characters
Nonprinting characters are characters outside the standard range of ASCII
printable characters. In other words, they are characters whose ASCII codes are
less than ASCII 32 or greater than ASCII 127. They are characters that have no
single key equivalents on a standard keyboard.
The characters whose codes are less than ASCII 32 are usually used for control
operations. They can be entered only in conjunction with the Ctrl key. For
example, ETX (ASCII 3) is entered as <Ctrl-C> and is used to assert a BREAK
when entered from the keyboard.
The characters whose codes are greater than ASCII 127 are usually used for
graphics operations. As a rule, they cannot be entered from the keyboard, but
they can be read from other types of devices. For example, ASCII 179 produces
the vertical line character.
You can use the READ command to input nonprinting characters as well as the
standard ASCII printable characters. However, you must include code to handle
the escape sequence used for each such character. An escape sequence is a
sequence of characters that starts with the Esc character (ASCII 27). For
example, you can code a READ so that the user is allowed to press a function
key as a valid input response. Pressing the function key produces an escape
sequence that can be different for different types of terminals.
Caché ObjectScript supports input of escape sequences by storing them in the 
$ZB and $KEY special variables, rather than in the specified variable. For
example, for a function key press, Caché stores the Esc code (ASCII 27) in $ZB
and $KEY. To handle an escape sequence, you must include code that tests the
current value in $ZB or $KEY after each READ because subsequent reads update
these special variables and overwrite any previous value. ($ZB and $KEY are
very similar, but not identical; see $KEY for details.) To display a
nonprinting character, such as an escape sequence, use the ZZDUMP command or
the $ASCII function.
Sequential File End-of-File
The behavior of READ when encountering an end-of-file for a sequential file
depends on the system-wide default. Go to the System Management Portal, select
[Home] > [Configuration] > [Compatibility Settings]. View and edit the current
setting of SetZEOF. This option controls the behavior when Caché encounters an
unexpected end-of-file when reading a sequential file. When set to  true ,
Caché sets the $ZEOF special variable to indicate that you have reached the end
of the file. When set to  false , Caché issues an <ENDOFFILE> error. The
default is  false .
Setting $ZUTIL(69,40) overrides this default system-wide; it does not change
the System Configuration setting. Setting $ZUTIL(68,40) overrides the
system-wide setting for the current process.
Default Record Length
If the number of characters to read is not specified, Caché assumes a default
length of 32,767 characters regardless of whether long strings are enabled or
not.
See Also

  • OPEN command
  • WRITE command
  • ZZDUMP command
  • USE command
  • $KEY special variable
  • $TEST special variable
  • $ZA special variable
  • $ZB special variable
  • $ZEOF special variable
  • Terminal I/O in Caché I/O Device Guide
  • Magnetic Tape I/O in Caché I/O Device Guide
  • Sequential File I/O in Caché I/O Device Guide


 #}}}
*SET*  #{{{

Assigns a value to a variable.
Synopsis

SET:pc setargument,...
S:pc setargument,...

where setargument can be:
   variable=value
   (variable-list)=value

Arguments

pc             Optional  A postconditional expression.

               The variable to set to the corresponding value. variable can be
               a local variable, a process-private global, a global, an object
variable       property, or special variable. (Not all special variables can be
               set by an application; see documentation of individual special
               variables.)

               A comma-separated list, enclosed in parentheses, that consists
variable-list  of one or more variable arguments. All of the variable arguments
               in variable-list are assigned the same value.

value          A literal value, or any valid Caché ObjectScript expression that
               evaluates to a value.

Description
The SET command assigns a value to a variable. It can set a single variable, or
set multiple variables using any combination of two syntactic forms. It can
assign values to variables by specifying a comma-separated list of 
variable=value pairs. For example:

SET a=1,b=2,c=3

It can assign the same value to multiple variables by specifying a
comma-separated list of variables enclosed in parentheses. For example:

SET (a,b,c)=1

You can combine these two syntactic forms in any combination. For example:

SET (a,b)=1,c=2,(d,e,f)=3

The maximum number of assignments you can perform with a single invocation of 
SET is 127.
If a specified variable does not exist, SET creates it and assigns the value.
If a specified variable exists, SET replaces the previous value with the
specified value.
A value can be a literal or an expression that evaluates to a value. To define
an  empty variable, you can set the variable to the empty string ("") value.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
variable
The variable to receive the value resulting from the evaluation of value. It
can be a local variable, a process-private global, a global variable, or a
special variable. A variable can be represented as an object property using 
obj.property or ..property syntax. A local variable, process-private global, or
global variable can be either subscripted or unsubscripted. A global variable
can be specified with extended global reference (see Global Structure in 
Using Caché Globals).
Local variables, process-private globals, and special variables are specific to
the current process; they are mapped to be accessible from all namespaces. A
global variable persists after the process that created it terminates. A global
is specific to the namespace in which it was created. By default, a SET assigns
a global in the current namespace. You can use SET to define a global (^
myglobal) in another namespace (samples) by using syntax such as the following:
SET ^[ samples ]myglobal="Ansel Adams .
A variable can be a piece or segment of a variable as specified in the argument
of a $PIECE or $EXTRACT function.
Note that you can assign values to only certain special variables. See the
reference pages for individual special variables for further details.
SET accepts a variable name of any length, but it truncates a long variable
name to 31 characters before assigning it a value. If a variable name is not
unique within the first 31 characters this name truncation can cause unintended
overwriting of variable values, as shown in the following example:

  SET abcdefghijklmnopqrstuvwxyz2abc="30 characters"
  SET abcdefghijklmnopqrstuvwxyz2abcd="31 characters"
  SET abcdefghijklmnopqrstuvwxyz2abcde="32 characters"
  SET abcdefghijklmnopqrstuvwxyz2abcdef="33 characters"
  WRITE !,abcdefghijklmnopqrstuvwxyz2abc     // returns "30 characters"
  WRITE !,abcdefghijklmnopqrstuvwxyz2abcd    // returns "33 characters"
  WRITE !,abcdefghijklmnopqrstuvwxyz2abcde   // returns "33 characters"
  WRITE !,abcdefghijklmnopqrstuvwxyz2abcdef  // returns "33 characters"
Refer to the  Variables chapter of Using Caché ObjectScript for further details
on variable types and naming conventions.
value
A literal value or any valid Caché ObjectScript expression. Usually a value is
a numeric or string expression.

  • A numeric value is converted to canonical form before assignment: leading
    and trailing zeros, a plus sign or a trailing decimal point are removed.
    Conversion from scientific notation and evaluation of arithmetic operations
    are performed.
  • A string value is enclosed in quotation marks. A string is assigned
    unchanged, except that doubled quotation marks within the string are
    converted to a single quotation mark. The null string ("") is a valid value
    .
  • A numeric value enclosed in quotation marks is not converted to canonical
    form and no arithmetic operations are performed before assignment.
  • If a relational or logical expression is used, Caché assigns the truth
    value (0 or 1) resulting from the expression.
  • Object properties and object methods that return a value are valid
    expressions. Use the .. syntax for assigning a property or method value to
    a variable.

Examples
The following example illustrates how you can specify multiple arguments for
the same SET command. Specifically, the command assigns values to three
variables. Note that arguments are evaluated in left-to-right order.

   SET var1=12,var2=var1*3,var3=var1+var2
   WRITE "var1=",var1,!,"var2=",var2,!,"var3=",var3
The following example shows the (variable-list)=value form of the SET command.
It shows how to assign the same value to multiple variables. Specifically, the
command assigns the value 0 to three variables.

   SET (sum,count,average)=0
   WRITE "sum=",sum,!,"count=",count,!,"average=",average
The following example shows setting a subscripted global variable in a
different namespace using extended global reference.

   ZNSPACE "user"
   SET ^["samples"]name(1)="fred"
   ZNSPACE "samples"
   WRITE ^name(1)
SET Command with Objects
The following example sets x to the value of an object property:

   SET x=person.LastName

where person is the object reference, and LastName is the object property name.
Note that dot syntax is used in object expressions; a dot is placed between the
object reference and the object property name or object method name.
To set a variable with an object property or object method value for the
current object, use the double-dot syntax:

   SET x=..LastName

If the specified object property does not exist, Caché issues a <PROPERTY DOES
NOT EXIST> error. If you use double-dot syntax and the current object has not
been defined, Caché issues a <NO CURRENT OBJECT> error.
For further details, refer to Object-Specific ObjectScript Features in 
Using Caché Objects.
When using SET with objects, do not perform multiple assignments. For example,
avoid statements such as:

 // Avoid this syntax:
   SET (a.Name,b.Name)=z

Instead, issue a separate SET command for each assignment, as shown in the
following example:

SET a.Name=z
SET b.Name=z

The following command sets x to the value returned by the object method
TotalLines():

   SET x=invoice.TotalLines()

A SET command for objects can take an expression with cascading dot syntax, as
shown in the following examples:

   SET x=patient.Doctor.Hospital.Name

In this example, the patient.Doctor object property references the Hospital
object, which contains the Name property. Thus, this command sets x to the name
of the hospital affiliated with the doctor of the specified patient. The same
cascading dot syntax can be used with object methods.
A SET command for objects can be used with system-level methods, such as the
following data type property method:

   SET x=patient.NameIsValid(name)

In this example, the NameIsValid() property method returns its result for the
current patient object. NameIsValid() is a boolean method generated for data
type validation of the Name property. Thus, this command sets x to 1 if the
specified name is a valid name, and sets x to 0 if the specified name is not a
valid name.
Notes
Each variable assignment can be a local variable, a process-private global, or
a global, the $PIECE function, the $EXTRACT function, and certain special
variables, including $DEVICE, $X, $Y, $KEY, $ECODE, and $ETRAP.
If the target variable does not already exist, SET creates it and then assigns
the value. If it does exist, SET replaces the existing value with the assigned
value.
SET and Subscripts
You can set individual subscripted values (array nodes) for a local variable,
process-private global, or a global. You can set subscripts in any order. If
the variable subscript level does not already exist, SET creates it and then
assigns the value. Each subscript level is treated as an independent variable;
only those subscript levels set are defined. For example:

   KILL myarray
   SET myarray(1,1,1)="Cambridge"
   WRITE !,myarray(1,1,1)
   SET myarray(1)="address"
   WRITE !,myarray(1)
In this example, the variables myarray(1,1,1) and myarray(1) are defined and
contain values. However, the variables myarray and myarray(1,1) are not
defined, and return an <UNDEFINED> error when invoked. For further information
on subscripted variables, refer to Global Structure in Using Caché Globals.
Order of Evaluation
Caché evaluates the arguments of the SET command in strict left-to-right order.
For each argument, it performs the evaluation in the following sequence:

 1. Evaluates occurrences of indirection or subscripts to the left of the equal
    sign in a left-to-right order to determine the variable name(s). For more
    information, refer to Indirection in Using Caché ObjectScript.
 2. Evaluates the expression to the right of the equal sign.
 3. Assigns the expression to the right of the equal sign to the variable name
    or references to the left of the equal sign.

Transaction Processing
A SET of a global variable is journaled as part of the current transaction;
this global variable assignment is rolled back during transaction rollback. A 
SET of a local variable or a process-private global variable is not journaled,
and thus this assignment is unaffected by a transaction rollback.
Defined and Undefined Variables
Most Caché commands and functions require that a variable be defined before it
is referenced. Attempting to reference an undefined variable generates an
<UNDEFINED> error. Attempting to reference an undefined object generates a
<PROPERTY DOES NOT EXIST> or <METHOD DOES NOT EXIST> error. Refer to $ZERROR
for further details on these error codes.
The READ command and the $INCREMENT function can reference an undefined
variable and assign a value to it. The $DATA function can take an undefined or
defined variable and return its status. The $GET function returns the value of
a defined variable; optionally, it can also assign a value to an undefined
variable.
SET with $PIECE and $EXTRACT
You can use the $PIECE and $EXTRACT functions with SET on either side of the
equals sign. For detailed descriptions, refer to $PIECE and $EXTRACT.
When used on the right side of the equals sign, $PIECE and $EXTRACT extract a
substring from a variable and assign its value to the specified variable(s) on
the left side of the equals sign. $PIECE extracts a substring using a specified
delimiter, and $EXTRACT extracts a substring using a character count.
For example, assume that variable x contains the string "HELLO WORLD". The
following commands extract the substring "HELLO" and assign it to variables y
and z, respectively:

   SET x="HELLO WORLD"
   SET y=$PIECE(x," ",1)
   SET z=$EXTRACT(x,1,5)
   WRITE "x=",x,!,"y=",y,!,"z=",z
When used on the left side of the equals sign, $PIECE and $EXTRACT insert the
value from the expression on the right side of the equals sign into the
specified portion of the target variable. Any existing value in the specified
portion of the target variable is replaced by the inserted value.
For example, assume that variable x contains the string "HELLO WORLD" and that
variable y contains the string "HI THERE". In the command:

   SET x="HELLO WORLD"
   SET y="HI THERE"
   SET $PIECE(x," ",2)=$EXTRACT(y,4,9)
   WRITE "x=",x
The $EXTRACT function extracts the string "THERE" from variable y and the 
$PIECE function inserts it into variable x at the second field position,
replacing the existing string "WORLD". Variable x now contains the string
"HELLO THERE".
If the target variable does not exist, Caché creates it and pads it with
delimiters (in the case of $PIECE) or with spaces (in the case of $EXTRACT) as
needed.
For example, assume that x contains the string "HELLO WORLD" and that y
contains the string "THERE". The following command inserts the value of y in
positions 7 through 11 of x:

   SET x="HELLO WORLD"
   SET y="THERE"
   SET $EXTRACT(x,7,11)=y
   WRITE "x=",x
Variable x now contains the string "HELLO THERE".
In the following example, assume that the global array ^client is structured so
that the root node contains the client’s name, with subordinate nodes
containing the street address and city. For example, ^client(2,1,1) would
contain the city address for the second client stored in the array.
Assume further that the city node (x,1,1) contains field values identifying the
city, state abbreviation, and ZIP code (postal code), with the comma as the
field separator. For example, a typical city node value might be
"Cambridge,MA,02142". The three SET commands in the following code each use the
$PIECE function to assign a specific portion of the array node value to the
appropriate local variable. Note that in each case $PIECE references the comma
(",") as the string separator.

ADDRESSPIECE
   SET ^client(2,1,1)="Cambridge,MA,02142"
   SET city=$PIECE(^client(2,1,1),",",1)
   SET state=$PIECE(^client(2,1,1),",",2)
   SET zip=$PIECE(^client(2,1,1),",",3)
   WRITE "City is ",city,!,
         "State or Province is ",state,!
        ,"Postal code is ",zip
   QUIT
The $EXTRACT function could be used to perform the same operation, but only if
the fields were fixed length and the lengths were known. For example, if the
city field was known to contain only up to 9 characters and the state and ZIP
fields were known to contain only 2 and 5 characters, respectively, the SET
commands could be coded with the $EXTRACT function as follows:

ADDRESSEXTRACT
   SET ^client(2,1,1)="Cambridge,MA,02142"
   SET city=$EXTRACT(^client(2,1,1),1,9)
   SET state=$EXTRACT(^client(2,1,1),11,12)
   SET zip=$EXTRACT(^client(2,1,1),14,18)
   WRITE "City is ",city,!,
         "State or Province is ",state,!,
         "Postal code is ",zip
   QUIT
Notice the gaps between 9 and 11 and 12 and 14 to accommodate the comma field
separators.
The following example replaces the first substring in A (originally set to 1)
with the string "abc".

StringPiece
   SET A="1^2^3^4^5^6^7^8^9"
   SET $PIECE(A,"^")="abc"
   WRITE !,"A=",A
   QUIT
A="abc^2^3^4^5^6^7^8^9"
The following example uses $EXTRACT to replace the first character in A (again,
a 1) with the string "abc".

StringExtract
   SET A="123456789"
   SET $EXTRACT(A)="abc"
   WRITE !,"A=",A
   QUIT
A="abc23456789"
The following example replaces the third through sixth pieces of A with the
string "abc" and replaces the first character in the variable B with the string
"abc".

StringInsert
   SET A="1^2^3^4^5^6^7^8^9"
   SET B="123"
   SET ($PIECE(A,"^",3,6),$EXTRACT(B))="abc"
   WRITE !,"A=",A,!,"B=",B
   QUIT
A="1^2^abc^7^8^9"
B="abc23"
The following example sets $X, $Y, $KEY, and the fourth piece of a previously
undefined local variable, A, to the value of 20. It also sets the local
variable K to the current value of $KEY. A includes the previous three pieces
and their caret delimiter (^).

SetVars
   SET ($X,$Y,$KEY,$PIECE(A,"^",4))=20,X=$X,Y=$Y,K=$KEY
   WRITE !,"A=",A,!,"K=",K,!,"X=",X,!,"Y=",Y
   QUIT
A="^^^20" K="20" X=20 Y=20
The following example sets $ECODE and $ETRAP to the null string. Then, the
example sets the local variables EC and ET to the values of $ECODE and $ETRAP.

SetEvars
   SET ($ECODE,$ETRAP)="",EC=$ECODE,ET=$ETRAP
   WRITE "EC=",EC,!,"ET=",ET
   QUIT
EC=""
ET=""
SET with $LIST and $LISTBUILD
Caché includes several functions that allow you to manipulate lists more
quickly and easily than you can with $PIECE or $EXTRACT. These functions are:

  • $LIST
  • $LISTBUILD

These functions do not use delimiters when they create or manipulate lists.
Instead, they encode the length (and type) of each element within the list
itself. They then use the encoded length specifications to extract specified
list elements during list manipulation. Because the $LIST functions do not use
delimiter characters, the lists created using these functions should not be
input to $PIECE or other character-delimiter functions.
When used on the right side of the equal sign, these functions return the
following:
$LIST
$LIST returns the specified element of the specified list.
$LISTBUILD
$LISTBUILD returns a list containing one element for each argument given.
When used on the left side of the equal sign, in a SET argument, these
functions perform the following tasks:
$LIST
Replaces the specified element with the value given on the right side of the
equal sign.
$LISTBUILD
Extracts several elements of a list in a single operation. The arguments of 
$LISTBUILD are variables, each of which receives an element of the list
corresponding to their position in the $LISTBUILD parameter list. Variable
names may be omitted for positions that are not of interest.
In the following example, $LISTBUILD (on the right side of the equal sign) is
first used to return a list. Then $LISTBUILD (on the left side of the equal
sign) is used to extract two items from that list and set the appropriate
variables.

SetListBuild
   SET J=$LISTBUILD("red","blue","green","white")
   SET $LISTBUILD(A,,B)=J
   WRITE "A=",A,!,"B=",B
In this example, A="red" and B="green".
See Also

  • $LIST function
  • $LISTBUILD function
  • $EXTRACT function
  • $PIECE function
  • $X special variable
  • $Y special variable


 #}}}
*TCOMMIT*  #{{{

Marks the successful completion of a transaction.
Synopsis

TCOMMIT:pc
TC:pc

Arguments

pc  Optional  A postconditional expression.

Description
TCOMMIT marks the successful end of a transaction initiated by the
corresponding TSTART.
TCOMMIT decrements the value of the $TLEVEL special variable. Caché terminates
the transaction only if $TLEVEL goes to 0. Usually this is when TCOMMIT has
been called as many times as TSTART. Changes made during nested transactions
are not committed until $TLEVEL=0.
Calling TCOMMIT when $TLEVEL is already 0 results in a <COMMAND> error. This
can occur if you issue a TCOMMIT when no transaction is in progress, when the
number of TCOMMIT commands is larger than the number of TSTART commands, or
following a TROLLBACK command.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
Examples
You use TCOMMIT with the TROLLBACK and TSTART commands. See TROLLBACK and
TSTART for examples of how to use these transaction processing commands
together.
Notes
Nested TSTART / TCOMMIT
Caché supports the nesting of the TSTART/TCOMMIT commands, so that modules can
issue their TSTART/TCOMMIT pairs correctly, independent of any other TSTART/
TCOMMIT issued in the modules that called them or in the modules they call. The
current nesting level of the transaction is tracked by the special variable 
$TLEVEL. The transaction is committed when the outermost matching TCOMMIT is
issued; that is, when $TLEVEL goes back to 0.
You can roll back individual nested transactions by calling TROLLBACK 1 or roll
back all current transactions by calling TROLLBACK. TROLLBACK rolls back the
whole transaction that is in effect  no matter how many levels of TSTART were
issued  and sets $TLEVEL to 0.
Network Transactions
To synchronize the completion of transactions over a network, use the ZSYNC
command.
Synchronous Commit
A TCOMMIT command requests a flush of the journal data involved in that
transaction to disk. Whether to wait for this disk write operation to complete
is a configurable option.
Go to the System Management Portal, select [Home] > [Configuration] >
[Compatibility Settings]. View and edit the current setting of SynchCommit.
When set to  true , TCOMMIT does not complete until the journal data write
operation completes. When set to  false , TCOMMIT does not wait for the write
operation to complete. The default is  false .
SQL and Transactions
Caché ObjectScript transaction processing, using TSTART and TCOMMIT, differs
from, and is incompatible with, SQL transaction processing using the SQL
statements START TRANSACTION and COMMIT. Caché ObjectScript transaction
processing provides limited support for nested transactions; SQL transaction
processing supports savepoints within transactions. An application should use
one type of transaction processing throughout, and not attempt to mix the two.
See Also

  • TROLLBACK command
  • TSTART command
  • $TLEVEL special variable
  • Using ObjectScript for Transaction Processing in Using Caché ObjectScript


 #}}}
*THROW*  #{{{

Explicitly throws an exception to the next exception handler.
Synopsis

THROW oref

Arguments

oref  Optional  An object reference that is thrown to an exception handler.

Description
The THROW command explicitly throws an exception. An exception can be a system
error, a status exception, or a user-defined exception. It throws this
exception as an object reference (oref) that inherits from the 
%Exception.AbstractException object. The THROW command throws this exception to
the next exception handler. This handler can be CATCH exception handler, a 
$ZTRAP error handler, or a $ETRAP error handler.
One common usage is to issue a THROW from within a block of code defined by a 
TRY command, transferring execution from the TRY block to the corresponding 
CATCH exception handler.
THROW can be specified with an oref argument or without an argument. In most
cases, you should use THROW with an oref argument.
System Errors
Caché issues a system error when a runtime error occurs, such a referencing an
undefined variable. A system error generates a %Exception.SystemException
object reference, sets the $ZERROR special variable, and transfers control to
the next error handler. This error handler can be a CATCH exception handler, or
a $ZTRAP or $ETRAP error handler. You can use THROW in this error handler to
throw this system error object to a further error handler. This is known as
re-signalling a system error.
THROW Without an Argument
Argumentless THROW re-signals the current system error, transferring control to
the next exception handler. The current system error is the error referenced by
the $ZERROR special variable. Thus, an argumentless THROW is equivalent to the
command ZTRAP $ZERROR.
Use of argumentless THROW is not recommended, because which system error is the
current system error may change. For instance, this would occur if the error
handler changes the $ZERROR value, or if the error handler itself generates a
system error. It is therefore preferable to explicitly specify the system error
to be thrown to the next exception handler. You do this by specifying the error
object that was originally caught as the oref argument.
Status Exceptions and User-Defined Exceptions
To trap a status exception or a user-defined exception, specify an object based
on the %Exception.AbstractException object as the oref argument. Define an
exception class, then create an instance of the class using %New() and supply
the exception information. These types of exceptions must be handled by a CATCH
exception handler. If no CATCH exists, Caché generates a <NOCATCH> error.
Arguments
oref
A reference to an exception object, which is an instance of any class that
inherits from %Exception.AbstractException. A exception object for a system
error is an instance of the class %Exception.SystemException. A status
exception object or user exception object is based on 
%Exception.AbstractException. The creation and population of a user exception
object is the responsibility of the programmer.
Examples
The following example shows the use of THROW with a system error. THROW is
commonly used in a CATCH exception handler to forward the system error to
another handler. This may occur when the system error received is an unexpected
type of system error. In this case, the CATCH will then THROW the system error
to another CATCH block. This is shown in the following example, which calls
Calculate to perform a division operation and return the answer. There are
three possible outcomes: If y = any non-zero number, the division operation
succeeds and no CATCH block code is executed. If y=0 (or any non-numeric
string), the division operation attempts to divide by zero, throwing a system
error to its CATCH block; this is caught by the calcerr exception handler,
which  corrects this error and returns a value of 0. If, however, y is not
defined (NEW y), calcerr catches an unexpected system error, and throws this
error to the myerr exception handler. To demonstrate these three possible
outcomes, this sample program uses $RANDOM to set the divisor (y):

Randomizer
  NEW y
  SET test=$RANDOM(3)
  IF test=0 { SET y=0 }
  ELSEIF test=1 { SET y=7 }
  /* Note: if test=2, y is undefined */
Main
  SET x=4
  TRY {
    SET result=$$Calculate(x,y)
    WRITE !,"Calculated value=",result
  }
  CATCH myerr {
    WRITE !,"this is the exception handler"
    WRITE !,"Error code=",myerr.Code
    WRITE !,"Error name=",myerr.Name
    WRITE !,"Error data=",myerr.Data
  }
  QUIT

Calculate(arg1,arg2) PUBLIC {
  TRY {
  SET answer=arg1/arg2
  }
  CATCH calcerr {
      IF calcerr.Name="<DIVIDE>" {
        WRITE !,"handling zero divide error"
        SET answer=0 }
      ELSE {
        THROW calcerr }
  }
  QUIT answer
}
Note that $ZCVT(myvar.Name,"O","HTML") is used here because this example is run
from within our documentation, which is displayed using a web browser. In most
other contexts, myvar.Name will return the desired value.
The following example shows a THROW with a user-defined argument:

  TRY {
    WRITE !,"Throw an exception!"
    THROW ##class(Sample.MyException).%New("Example Error",45,, "MyErrData")
    WRITE !,"this should not display"
  }
  CATCH myvar {
      WRITE !,"this is the exception handler"
      WRITE !,"Error code=",myvar.Code
      WRITE !,"Error name=",myvar.Name
      WRITE !,"Error data=",myvar.Data
  }
  WRITE !,!,"this is where the code falls through"
See Also

  • CATCH command
  • TRY command
  • ZTRAP command
  • $ETRAP special variable
  • $ZERROR special variable
  • $ZTRAP special variable
  • Error Processing in Using Caché ObjectScript


 #}}}
*TROLLBACK*  #{{{

Rolls back an unsuccessful transaction.
Synopsis

TROLLBACK:pc
TRO:pc

TROLLBACK:pc 1
TRO:pc 1

Arguments

pc  Optional  A postconditional expression.

1   Optional  Rolls back one level of nesting.

Description
TROLLBACK terminates the current transaction and restores all journaled
database values to the values they held at the start of the transaction. 
TROLLBACK has two forms:

  • TROLLBACK rolls back all transactions in progress (no matter how many
    levels of TSTART were issued) and resets $TLEVEL to 0.
  • TROLLBACK 1 rolls back the current level of nested transactions (the one
    initiated by the most recent TSTART) and decrements $TLEVEL by 1.

You can determine the level of nested transactions from the $TLEVEL special
variable. Calling TROLLBACK when $TLEVEL is 0 has no effect.
You can use the $ZUTIL(78,21) function to search the journal file for TSTART
commands, and thus identify open transactions. A TSTART increments $TLEVEL and
writes a journal file record: either a  BT (Begin Transaction) record if 
$TLEVEL was zero, or a  BTL (Begin Transaction with Level) record if $TLEVEL
was greater than 0.
Use the $ZUTIL(78,29) function to flush the journal buffer following a
successful rollback operation.
Transaction Rollback Logging
If an error occurs during a roll back operation, Caché issues a <ROLLFAIL>
error message, and logs an error message in the operator console log file.
By default, the operator console log file is cconsole.log in the Caché system
management directory (Mgr). This default is configurable. Go to the System
Management Portal, select [Home] > [Configuration] > [Advanced Memory
Settings]. View and edit the current setting of ConsoleFile. By default this
setting is blank, routing console messages to cconsole.log in the MGR
directory. If you change this setting, you must restart Caché for this change
to take effect.
SQL and Transactions
Caché ObjectScript transaction processing, using TSTART and TCOMMIT or 
TROLLBACK, differs from, and is incompatible with, SQL transaction processing
using the SQL statements START TRANSACTION, and COMMIT or ROLLBACK. An
application should use one type of transaction processing throughout, and not
attempt to mix the two.
Caché ObjectScript transaction processing provides limited support for nested
transactions. SQL transaction processing supplies support for savepoints within
transactions.
Purging Cached Queries
If during a transaction you call the $SYSTEM.SQL.Purge() method to purge cached
queries, the cached queries are permanently deleted. A subsequent TROLLBACK
will not restore purged cached queries.
Variables and $INCREMENT
TROLLBACK rolls back all journaled operations. However, not all changes made by
an application are journaled.

  • TROLLBACK rolls back changes to global variables.
  • TROLLBACK does not roll back $INCREMENT (or $ZINCREMENT) changes to global
    variables.
  • TROLLBACK does not roll back changes to local variables or process-private
    globals.

Globals and TROLLBACK 1
TROLLBACK 1 rolls back and restores all globals changed within its nested
transaction. However, if globals are changed that are mapped to a remote system
that does not support nested transactions, these changes are treated as
occurring at the outermost nested level. Such globals are only rolled back when
a rollback resets $TLEVEL to 0, either by calling TROLLBACK or by calling 
TROLLBACK 1 when $TLEVEL=1.
Locks and TROLLBACK 1
TROLLBACK 1 does not restore locks established during its nested transaction to
their prior state. All locks established during a transaction remain in the
lock table until the transaction is concluded by a TROLLBACK to level 0 or a 
TCOMMIT. At that point Caché releases all locks created during the nested
transaction, and restores all pre-existing locks to their state before TSTART.
A TCOMMIT of a nested transaction does not release the corresponding locks, so
a subsequent TROLLBACK can effect locks in a committed sub-transaction.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
Examples
The following example shows the effects of TROLLBACK on nested transactions.
Each TSTART increments $TLEVEL and sets a global. Issuing a TCOMMIT on the
inner nested transaction decrements $TLEVEL, but the commitment of changes made
in a nested transaction is deferred. In this case, the subsequent TROLLBACK on
the outer transaction rolls back all changes made, including those in the inner
 committed nested transaction.

  SET ^a(1)="[- - -]",^b(1)="[- - -]"
  WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
  TSTART
   LOCK +^a(1)
   SET ^a(1)="hello"
   WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
     TSTART
     LOCK +^b(1)
     SET ^b(1)="world"
     WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
     TCOMMIT
  WRITE !,"After TCOMMIT"
  WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
  TROLLBACK
  WRITE !,"After TROLLBACK"
  WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
  QUIT
The following example shows how TROLLBACK rolls back global variables, but not
local variables:

  SET x="default",^y="default"
  WRITE !,"level:",$TLEVEL
  WRITE !,"local:",x," global:",^y
  TSTART
  SET x="first",^y="first"
  WRITE !,"TSTART level:",$TLEVEL
  WRITE !,"local:",x," global:",^y
    TSTART
    SET x=x_" second",^y=^y_" second"
    WRITE !,"TSTART level:",$TLEVEL
    WRITE !,"local:",x," global:",^y
     TSTART
     SET x=x_" third",^y=^y_" third"
    WRITE !,"TSTART level:",$TLEVEL
    WRITE !,"local:",x," global:",^y
  TROLLBACK
  WRITE !!,"After Rollback:"
  WRITE !,"TROLLBACK level:",$TLEVEL
  WRITE !,"local:",x," global:",^y
The following example shows how $INCREMENT changes to a global are not rolled
back.

  SET ^x=-1,^y=0
  WRITE !,"level:",$TLEVEL
  WRITE !,"Increment:",$INCREMENT(^x)," Add:",^y
  TSTART
  SET ^y=^y+1
  WRITE !,"level:",$TLEVEL
  WRITE !,"Increment:",$INCREMENT(^x)," Add:",^y
    TSTART
    SET ^y=^y+1,^z=^z_" second"
    WRITE !,"level:",$TLEVEL
    WRITE !,"Increment:",$INCREMENT(^x)," Add:",^y
     TSTART
     SET ^y=^y+1,^z=^z_" third"
     WRITE !,"level:",$TLEVEL
     WRITE !,"Increment:",$INCREMENT(^x)," Add:",^y
  TROLLBACK
  WRITE !!,"After Rollback"
  WRITE !,"level:",$TLEVEL
  WRITE !,"Increment:",^x," Add:",^y
The following example transfers money from one account to another as a
transaction using primitive error checking:

Transfer(from,to,amount)
    // Transfer funds from one account to another
  IF ('$Data(^ACCOUNT(from,"Balance"))) {
      QUIT "FROM account does not exist."
  }
  TSTART
  SET ^ACCOUNT(from,"Balance")=^ACCOUNT(from,"Balance")-amount
  IF ('$Data(^ACCOUNT(from,"Balance"))) {
      TROLLBACK
      QUIT "TO account does not exist."
  }
  SET ^ACCOUNT(to,"Balance")=^ACCOUNT(to,"Balance")+amount
  TCOMMIT
  QUIT 1

See Also

  • TCOMMIT command
  • TSTART command
  • $TLEVEL special variable
  • Using ObjectScript for Transaction Processing in Using Caché ObjectScript


 #}}}
*TRY*  #{{{

Identifies a block of code to monitor for errors during execution.
Synopsis

TRY {
   . . .
}

Description
The TRY command takes no arguments. It is used to identify a block of Caché
ObjectScript code statements enclosed in curly braces. This block of code is
protected code for structured exception handling. If an exception occurs within
this block of code, Caché sets $ZERROR and $ECODE, then transfers execution to
an exception handler, identified by the CATCH command. This is known as
throwing an exception. If no error occurs, execution continues with the next
ObjectScript statement after the CATCH block of code.
An exception may occur as a result of a runtime error, such as attempting to
divide by 0, or it may be explicitly propagated by issuing a THROW command.
A TRY block must be immediately followed by a CATCH block. You cannot specify
either executable code statements or a label between the closing curly brace of
the TRY code block and the CATCH command. However, you can specify comments
between the TRY and CATCH blocks.
QUIT and GOTO
A QUIT command within a TRY block does not trigger CATCH code execution; it
transfers execution to the first code line after the CATCH block.
A GOTO command within a TRY block does not trigger CATCH code execution. You
cannot issue a GOTO into a CATCH block or into a TRY block. You cannot specify
a label on the same line as the TRY statement. Attempting to reference such a
label results in a <NOLINE> error.
Setting $ETRAP
When an exception occurs within a TRY block, Caché executes the CATCH block of
exception handler code that immediately follows the TRY block. However, if 
$ETRAP is set, Caché executes $ETRAP in preference to CATCH when an exception
occurs. Because $ETRAP is not associated with an execution level, setting 
$ETRAP causes any subsequent TRY exception to invoke $ETRAP (not CATCH) even
though you did not set $ETRAP at the execution level where the exception
occurred.
Examples
In the following examples, the TRY code block is executed. It attempts to set
the local variable a. In the first example, the code completes successfully,
and the CATCH is skipped over. In the second example, the code fails with an
<UNDEFINED> error, and execution is passed to the CATCH command.
TRY succeeds:

  TRY {
    SET x="fred"
    WRITE !,"x is a defined variable"
    SET a=x
  }
  CATCH exceptionvar
  {
      WRITE !,"this is the error routine"
      WRITE !,"the error was: ",$ZERROR
  }
  WRITE !,"this is where the code falls through"
      WRITE !,"the error was: ",$ZERROR
TRY fails:

  TRY {
    KILL x
    WRITE !,"x is an undefined variable"
    SET a=x
  }
  CATCH exceptionvar
  {
      WRITE !,"this is the error routine"
      WRITE !,"the error was: ",$ZERROR
      WRITE !,"the error was: ",$ECODE
  }
  WRITE !,"this is where the code falls through"
  WRITE !,"the error was: ",$ZERROR
  WRITE !,"the error was: ",$ECODE
TRY quits. In the following example, the CATCH block is not executed because
execution of the TRY block is ended by a QUIT, not an error:

  TRY {
    KILL x
    WRITE !,"x is an undefined variable"
    QUIT
    SET a=x
  }
  CATCH exceptionvar
  {
      WRITE !,"this is the error routine"
      WRITE !,"the error was: ",$ZERROR
  }
  WRITE !,"this is where the code falls through"
See Also

  • CATCH command
  • THROW command
  • $ETRAP special variable
  • Error Processing in Using Caché ObjectScript


 #}}}
*TSTART*  #{{{

Marks the beginning of a transaction.
Synopsis

TSTART:pc
TS:pc

Arguments

pc  Optional  A postconditional expression.

Description
TSTART marks the beginning of a transaction. Following TSTART, database
operations are journaled to enable a subsequent TCOMMIT or TROLLBACK command.
TSTART increments the value of the $TLEVEL special variable.
Any locks issued within a transaction will be held until the end of the
transaction even if the lock is released, unless the lock is specified as
short-term. Refer to the LOCK command for more details.
Nested TSTART / TCOMMIT
Caché supports the nesting of the TSTART/TCOMMIT commands, so that modules can
issue their TSTART/TCOMMIT pairs correctly, independent of any other TSTART/
TCOMMIT issued in the modules that called them or in the modules they call. The
current nesting level of the transaction is tracked by the special variable 
$TLEVEL.
Issuing a TCOMMIT for a nested transaction decrements $TLEVEL, but the actual
commitment of the nested transaction is deferred. A transaction is committed
when the outermost matching TCOMMIT is issued; that is, when $TLEVEL goes back
to 0.
You can issue a TROLLBACK 1 command to roll back the current level of nested
transaction. You can issue a TROLLBACK to roll back the whole transaction, no
matter how many levels of TSTART were issued.
You can use the $ZUTIL(78,21) function to search the journal file for TSTART
commands, and thus identify open transactions. A TSTART writes either a  BT 
(Begin Transaction) journal file record if $TLEVEL was zero, or a  BTL (Begin
Transaction with Level) journal file record if $TLEVEL was greater than 0.
The maximum number of levels of nested transactions is 255. Attempting to
exceed this nesting levels limit results in a <TRANSACTION LEVEL> error.
SQL and Transactions
Caché ObjectScript transaction processing, using TSTART and TCOMMIT, differs
from, and is incompatible with, SQL transaction processing using the SQL
statements START TRANSACTION and COMMIT. Caché ObjectScript transaction
processing provides limited support for nested transactions; SQL transaction
processing does not support nested transactions. An application should use one
type of transaction processing throughout, and not attempt to mix the two.
Arguments
pc
An optional postconditional expression. Caché executes the TSTART command if
the postconditional expression is true and does not execute the TSTART command
if the postconditional expression is false. For further details, refer to
Command Postconditional Expressions in Using Caché ObjectScript.
Examples
The following example shows nested pairs of TSTART/TCOMMIT amd the effects of
TROLLBACK on nested transactions. Each TSTART increments $TLEVEL and sets a
global. Issuing a TCOMMIT on the inner nested transaction decrements $TLEVEL,
but the commitment of changes made in a nested transaction is deferred. In this
case, the subsequent TROLLBACK on the outer transaction rolls back all changes
made, including those in the inner  committed nested transaction.

  SET ^a(1)="[- - -]",^b(1)="[- - -]"
  WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
  TSTART
   LOCK +^a(1)
   SET ^a(1)="hello"
   WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
     TSTART
     LOCK +^b(1)
     SET ^b(1)="world"
     WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
     TCOMMIT
  WRITE !,"After TCOMMIT"
  WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
  TROLLBACK
  WRITE !,"After TROLLBACK"
  WRITE !,"level:",$TLEVEL," ",^a(1)," ",^b(1)
  QUIT
The following example transfers money from one account to another as a
transaction:

  // Transfer funds from one account to another
Transfer(from,to,amount) {
  TSTART
  SET ^ACCOUNT(from,"Balance") = ^ACCOUNT(from,"Balance") - amount
  SET ^ACCOUNT(to,"Balance") = ^ACCOUNT(to,"Balance") + amount
  TCOMMIT
  QUIT
}

See Also

  • TCOMMIT command
  • TROLLBACK command
  • $TLEVEL special variable
  • Using ObjectScript for Transaction Processing in Using Caché ObjectScript


 #}}}
*USE*  #{{{

Establishes a device as the current device.
Synopsis

USE:pc useargument,...
U:pc useargument,...

where useargument can be

device:(parameters):"mnespace"

Arguments

pc          Optional  A postconditional expression.

            The device to be selected as the current device, specified by a
device      device ID or a device alias. A device ID can be an integer (a
            device number), a device name, or the pathname of a sequential
            file. If a string, it must be enclosed with quotation marks.

            Optional  The list of parameters used to set device
            characteristics. The parameter list is enclosed in parentheses, and
            the parameters in the list are separated by colons. Parameters can
parameters  either be positional (specified in a fixed order in the parameter
            list) or keyword (specified in any order). A mix of positional and
            keyword parameters is permitted. The individual parameters and
            their positions and keywords are highly device-dependent.

mnespace    Optional  The name of the mnemonic space that contains the control
            mnemonics to use with this device, specified as a quoted string.

Description
USE device establishes the specified device as the current device. The process
must have already established ownership of the device with the OPEN command.
The current device remains current until you issue another USE command to
select another owned device as the current device or until the process
terminates.
The USE command can establish as the current device such devices as terminal
devices, magnetic tape devices, spool devices, TCP bindings, interprocess
pipes, named pipes, and inter-job communications. The USE command can also be
used to open a sequential file. The device argument specifies the file pathname
as a quoted string.
The parameters available with the USE command are highly device-dependent. In
many cases the available parameters are the same as those available with the 
OPEN command; however, some device parameters can only be set using the OPEN
command, and other can only be set using the USE command.
The USE command can specify more than one useargument, separated by commas.
However, you can only have one current device at a time. If you specify more
than one useargument, the device specified in the last useargument becomes the
current device. This form of USE may be used to set parameters for several
devices, and then establish the last-named device as the current device.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
device
The device to be selected as the current device. Specify the same device ID (or
other device identifier) as you specified in the corresponding OPEN command.
For more information on specifying devices, refer to the OPEN command.
parameters
The list of parameters used to set operating characteristics of the device to
be used as the current device. The enclosing parentheses are required if there
is more than one parameter. (It is good programming practice to always use
parentheses when you specify a parameter.) Note the required colon before the
left parenthesis. Within the parentheses, colons are used to separate multiple
parameters.
The parameters for a device can be specified using either positional parameters
or keyword parameters. You can also mix positional parameters and keyword
parameters within the same parameter list.
In most cases, specifying contradictory, duplicate, or invalid parameter values
does not result in an error. Wherever possible, Caché ignores inappropriate
parameter values and takes appropriate defaults.
The available parameters are, in many cases, the same as those supported for
the OPEN command. For sequential files, TCP devices, and interprocess
communication pipes some parameters can only be set with the OPEN command; for
sequential files some parameters can only be set with the USE command. USE
parameters are specific to the type of device that is being selected and to the
particular implementation. The USE command keyword parameters are listed by
device type in I/O Devices and Commands in the Caché I/O Device Guide.
If you do not specify a list of USE parameters, Caché uses the device’s default
OPEN parameters. The default parameters for a device are configurable. Go to
the System Management Portal, select [Home] > [Configuration] > [Device
Settings] > [Devices] to display the current list of devices. For the desired
device, click  edit to display its Open Parameters: option. Specify this value
in the same way you specify the OPEN command parameters, including the
enclosing parentheses. For example, ("AVL":0:2048).
Positional Parameters
Positional parameters must be specified in a fixed sequence in the parameter
list. You can omit a positional parameter (and receive the default value), but
you must retain the colon to indicate the position of the omitted positional
parameter. Trailing colons are not required; excess colons are ignored. The
individual parameters and their positions are highly device-dependent. There
are two types of positional parameters: values and letter code strings.
A value can be an integer (for example, record size), a string (for example,
host name), or a variable or expression that evaluates to a value.
A letter code string uses individual letters to specify device characteristics
for the open operation. For most devices, this letter code string is one of the
positional parameters. You can specify any number of letters in the string, and
specify the letters in any order. Letter codes are not case sensitive. A letter
code string is enclosed in quotation marks; no spaces or other punctuation is
allowed within a letter code string (exception: K and Y may be followed by a
name delimited by backslashes: thus: K\name\). For example, when opening a
sequential file, you might specify a letter code string of  ANDFW (append to
existing file, create new file, delete file, fix-length records, write access.)
The position of the letter code string parameter, and the meanings of
individual letters is highly device-dependent.
Keyword Parameters
Keyword parameters can be specified in any sequence in the parameter list. A
parameter list can consist entirely of keyword parameters, or it can contain a
mix of positional and keyword parameters. (Commonly, the positional parameters
are specified first (in their correct positions) followed by the keyword
parameters.) You must separate all parameters (positional or keyword) with a
colon (:). A parameter list of keyword parameters has the following general
syntax:

USE device:(/KEYWORD1=value1:/KEYWORD2=value2:.../KEYWORDn=valuen):"mnespace"

The individual parameters and their positions are highly device-dependent. As a
general rule, you can specify the same parameters and values using either a
positional parameter or a keyword parameter. You can specify a letter code
string as a keyword parameter by using the /PARAMS keyword.
mnespace
The name of the mnemonic space that contains the device control mnemonics used
by this device. By default, Caché provides two mnemonic spaces: ^%XMAG for
magnetic tape devices, and ^%X364 (ANSI X3.64 compatible) for all other devices
and sequential files. Default mnemonic spaces are assigned by device type.
Go to the System Management Portal, select [Home] > [Configuration] > [Device
Settings] > [IO Settings]. View and edit the File, MagTape, Other, or Terminal
mnemonic space setting.
A mnemonic space is a routine that contains entry points for the device control
mnemonics used by READ and WRITE commands. The READ and WRITE commands invoke
these device control mnemonics using the /mnemonic(params) syntax. These device
control mnemonics perform operations such a moving the cursor to a specified
screen location or rewinding a magnetic tape.
Use the mnespace argument to override the default mnemonic space assignment.
Specify a Caché ObjectScript routine that contains the control mnemonics entry
points used with this device. The enclosing double quotes are required. Specify
this option only if you plan to use device control mnemonics with the READ or 
WRITE command. If the mnemonic space does not exist, Caché issues a <NOROUTINE>
error. For further details on mnemonic spaces, see I/O Devices and Commands in
the Caché I/O Device Guide.
Examples
In this example, the USE command sets the sequential file "STUDENTS" as the
current device and sets the file pointer so that subsequent reads begin at
offset 256 from the start of the file.

   USE "STUDENTS":256

Note:
Sequential file seeking with the USE command, such as that shown in the above
example, is not supported on OpenVMS systems.
Notes
Device Ownership
Device ownership is established with the OPEN command. The only exception is
the principal device, which is assigned to the process and is usually the
terminal at which you sign on. If the device specified in the USE command is
not owned by the process, Caché issues a <NOTOPEN> error message.
The Current Device
The current device is the device used for I/O operations by the READ and WRITE
commands. The READ command acquires input from the current device and the WRITE
command sends output to the current device.
Caché maintains the ID of the current device in the $IO special variable. If
the USE request is successful, Caché sets $IO to the ID of the specified
device. The $ZUTIL(96,14) function returns the device type of the current
device.
The Principal Device
The special device number 0 (zero) refers to the principal device. Each process
has one principal device. Caché maintains the ID of the principal device in the
$PRINCIPAL special variable. The principal device is automatically opened when
you start up Caché. Initially, the principal device ($PRINCIPAL) and the
current device ($IO) are the same.
After you issue a USE command, your current device ($IO) is normally the one
named in the last USE command you executed.
While many processes can have the same principal device, only one at a time can
own it. After a process successfully issues an OPEN command for a device, no
other process can issue OPEN for that device until the first process releases
it, either by explicitly issuing a CLOSE command, by halting, or because that
user ends the session.
Although you can issue OPEN and USE for a device other than your principal
device from the programmer prompt, each time Caché returns to the > prompt, it
implicitly issues USE 0. To continue using a device other than 0, you must
issue a USE command in each line you enter at the > prompt.
Your principal device automatically becomes your current device when you do any
of the following:

  • Log on.
  • Issue a USE 0 command.
  • Cause an error when an error trap is not set.
  • Close the current device.
  • Return to programmer mode.
  • Exit Caché by issuing a HALT command.

USE 0 implies an OPEN command to the principal device. If another process owns
the device, this process hangs on the implicit OPEN as it does when it
encounters any OPEN.
Although USE 0 implies OPEN 0 for the principal device, issuing a USE command
for any other device that the process does not own (due to a previous OPEN
command) produces a <NOTOPEN> error.
Note:
While most Caché platforms allow you to close your principal input device,
Caché for UNIX does not. Therefore, when a job that is the child of another job
tries to perform I/O on your login terminal, it hangs until you log off Caché.
At that time, the output may or may not appear.
Using the Null Device (UNIX and OpenVMS)
When you issue an OPEN and USE command to the null device (/dev/null on UNIX or
NL: on OpenVMS), Caché treats the null device as a dummy device. Subsequent 
READ commands immediately return a null string (""). Subsequent WRITE commands
immediately return success. No actual data is read or written. On UNIX-based
systems, the device /dev/null bypasses the UNIX open, write, and read system
calls entirely.
Processes started by other processes with the JOB command have a principal
device of /dev/null or NL: by default.
If you open /dev/null other than within Caché for example, by redirecting Caché
output to /dev/null from the UNIX shell the UNIX system calls operate as they
do for any other device.
See Also

  • OPEN command
  • CLOSE command
  • $IO special variable
  • $PRINCIPAL special variable
  • $ZUTIL(96,14) Return current device type function
  • I/O Devices and Commands in Caché I/O Device Guide
  • Terminal I/O in Caché I/O Device Guide
  • TCP Client/Server Communication in Caché I/O Device Guide
  • Magnetic Tape I/O in Caché I/O Device Guide
  • Sequential File I/O in Caché I/O Device Guide
  • The Spool Device in Caché I/O Device Guide


 #}}}
*VIEW*  #{{{

Reads and writes blocks directly to disk storage and writes locations in
memory.
Synopsis

VIEW:pc viewargument
V:pc viewargument

where viewargument is:

block
offset:mode:length:newvalue

Arguments

pc        Optional  An optional postconditional expression.

block     A block location, specified as an integer.

offset    An offset, in bytes, from a base address within the memory region
          specified by mode.

mode      The memory region whose base address will be used to calculate the
          data to be modified.

length    The length of the data to be modified.

newvalue  The replacement value to be stored at the memory location.

Description
The VIEW command reads and writes blocks directly to disk storage and writes
locations in memory. VIEW has three argument forms:

  • VIEW block transfers data between the Caché database and memory.
  • VIEW offset:mode:length:newvalue places newvalue in the memory location
    identified by offset, mode, and length.

You can examine data in memory with the $VIEW function.
Note:
InterSystems recommends that you avoid use of the VIEW command. When used in
any environment, it can corrupt memory structures.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
block
A block location, specified as an integer. If block is a positive integer, VIEW
reads that number block into the view buffer. If block is a negative integer, 
VIEW writes the block currently in the view buffer to that block address. The 
block and the offset:mode:length:newvalue arguments are mutually exclusive.
offset
An offset, in bytes, from a base address within the memory region specified by 
mode.
mode
The memory region whose base address will be used to calculate the data to be
modified. See Modifying Data in Memory for a description of the possible
values.
length
The length of the data to be modified.
Specify the number of bytes as an integer from 1-4. You can also use the letter
C to indicate a four-byte address or the letter P to indicate a four byte word
address). You must specify both the P or C and the positive integer in double
quotes.
If newvalue defines a string, specify the number of bytes as a negative integer
from 1 through 510. If the length of newvalue exceeds this number, Caché
ignores the extraneous characters. If the length of newvalue is less than this
number, Caché stores the supplied characters and leaves the rest of the memory
location unchanged.
To store a byte value in reverse order (low-order byte at lowest address)
append the letter O to the length number and enclose both in double quotes.
Note:
On a 2-byte or 4-byte machine, you can precede C, P, or O with the digit 2 or 4
to indicate your computer’s standard word length.
The Caché addressing scheme used on your system can affect the calculation of 
length.
newvalue
The replacement value to be stored at the memory location.
Examples
This command reads the sixth block from the Caché database into the View
Buffer.

   VIEW 6

This command writes the view buffer back to the sixth block of the Caché
database, presumably after the data has been modified.

   VIEW -6

This command copies the string "WXYZ" into four bytes starting at absolute
location ADDR. The expression $VIEW(0,ADDR,-4) would then result in the value
"WXYZ" .

   VIEW 0:ADDR:-4:"WXYZ"

Notes
Use VIEW with Caution
Use the VIEW command with caution. It is usually used for debugging and repair
of Caché databases and Caché system information. It is easy to corrupt memory
or your Caché database by using VIEW incorrectly.
The View Buffer
When used to read and write database buffers, the VIEW command works with the
view buffer (device 63). The view buffer is a special memory area that you must
opened before you can perform any VIEW operations.
When you open the view buffer (with the OPEN command), you indicate the Caché
database (CACHE.DAT) to be associated with the view buffer. Using the VIEW
command, you can then read individual blocks from the Caché database into the
view buffer.
After reading a block into the view buffer, you can use the $VIEW function to
examine the data. Or, you can use the VIEW command to modify the data. If you
modify the data, you can use the VIEW command again to write the modified block
back to the Caché database.
Reading and Writing Data in a Caché Database
Before you can read and write data blocks in a Caché database with VIEW, you
must first use the OPEN command to open the view buffer.

 1. Open the view buffer. The view buffer is designated as device number 63.
    Hence the command is:
   
       OPEN 63:location

    where location is the namespace that contains the CACHE.DAT file to be
    associated with the view buffer. The location is implementation specific.
    The OPEN 63 command creates the view buffer by allocating a region of
    system memory whose size is equal to the block size used by the Caché
    database.
 2. Use the VIEW block form to read in a block from the associated Caché
    database. Specify block as a positive integer. For example:
   
       VIEW 4

    This example reads the fourth block from the Caché database into the view
    buffer. Because the size of the view buffer equals the block size used in
    the Caché database, the view buffer can contain only one block at any given
    time. As you read in subsequent blocks, each new block overwrites the
    current block. To determine which blocks to read in from the Caché
    database, you should be familiar with the structure of the file.
 3. Read the data in the block with $VIEW function or modify it with the VIEW
    command.
 4. If you changed any of the data in the view buffer, write it back to the
    Caché database. To write data, use the VIEW block form but specify a
    negative integer for block. The block number usually matches the number of
    the current block in the view buffer, but it does not have to. The
    specified block number identifies which block in the file will be replaced
    (overwritten) by the block in the view buffer. For example: VIEW 5 This
    example replaces the fifth block in the Caché database with the current
    block in the view buffer.
 5. Close the view buffer. CLOSE 63

Transferring a Block between Caché Databases
When you open the view buffer, Caché does not automatically clear the existing
block. This allows you to transfer a block of data from one Caché database to
another using the following sequence:

 1. Use OPEN 63 and specify the namespace that contains the first Caché
    database.
 2. Use VIEW to read the desired block from the file into the view buffer.
 3. If necessary, use VIEW to modify the data in the view buffer.
 4. Use OPEN 63 again and specify the namespace that contains the second Caché
    database.
 5. Use VIEW to write the block from the view buffer to the second Caché
    database.
 6. Close the view buffer with a CLOSE 63 command.

Modifying Data in Memory
In addition to reading and writing data from a Caché database, the VIEW command
allows you to modify data in memory either in the view buffer or in other
system memory areas.
To modify data, use the following form:
VIEW offset:mode:length:newvalue
All four arguments are required.
You modify data by storing a new value into a memory location, which is
specified as a byte offset from the base address indicated by mode. You specify
the amount of memory affected in the length argument.
The possible values for mode are shown in the following table.

Mode              Memory Management Region                   Base Address

      Virtual address space of jobbed process n ,
n >0  where n is the value of $JOB for that jobbed      0
      process.

0     The view buffer                                   Beginning of view
                                                        buffer

-1    The process’s partition                           Beginning of partition

-2    The system table                                  Beginning of system
                                                        table

-3    The process’s virtual address space               0

-6    Reserved for InterSystems use                      

                                                        Special. See the Caché
-7    Used only by the integrity checking utility       High Availability Guide
                                                        .

See Also

  • OPEN command
  • CLOSE command
  • $VIEW function
  • Error Handling in Using Caché ObjectScript


 #}}}
*WHILE*  #{{{

Executes code while a condition is true.
Synopsis

WHILE expression,... {
  ;. . .
}

Arguments

            A test condition. You can specify one or more comma-separated test
expression  conditions, all of which must be TRUE for execution of the code
            block.

Description
WHILE tests expression and then executes the block of code (one or more
commands) between the opening and closing curly braces repeatedly, as long as 
expression evaluates to TRUE. If expression is not TRUE, block of code within
the curly braces is not executed, and the next command following the closing
curly brace ( } ) is executed.
There are no whitespace requirements before or after a curly brace.
The block of code within the curly braces can consist of one or more Caché
ObjectScript commands and function calls. This block of code may span several
lines. Indents, line returns, and blank spaces are permitted within the block
of code. Commands within this code block and arguments within commands may be
separated by one or more blank spaces and line returns. However, each command
keyword must be separated from its first argument by exactly one space.
Arguments
expression
A test condition. It can take the form of a single expression or a comma
separated list of expressions. For an expression list, Caché evaluates the
individual expressions in left to right order. It stops evaluation if it
encounters an expression that is FALSE. If all expressions evaluate to TRUE,
Caché executes the code commands. WHILE executes repeatedly, testing expression
for each loop. If any expression evaluates to FALSE, Caché ignores any
remaining expressions, and does not execute the code commands. It executes the
next command after the code commands.
Example

Mainloop
   SET x=1
   WHILE x < 10 {
      WRITE !," Looping",x
      SET x=x+1
   }
   WRITE !,"DONE"
   QUIT
This program writes:  Looping1 through  Looping9 , then writes  DONE .
Notes
WHILE and DO WHILE
The WHILE command tests expression before executing the loop. The DO WHILE
command executes the loop once and then tests expression.
WHILE and CONTINUE
Within the code block of a WHILE command, encountering a CONTINUE command
causes execution to immediately jump back to the WHILE command. The WHILE
command then evaluates its expression test condition, and, based on that
evaluation, determines whether to re-execute the code block loop. Thus, the 
CONTINUE command has exactly the same effect on execution as reaching the
closing curly brace of the code block.
QUIT and GOTO
The QUIT command within the block of code ends the WHILE loop and returns
execution to the command following the closing curly brace, as shown in the
following example:

Mainloop
  SET x=1
  WHILE x < 10
  {
    WRITE !,"looping "
    SET x=x+1
    WRITE " x=",x
    QUIT
  }
  WRITE " done"
This program writes: looping x=2 done
A GOTO command within the block of code may direct execution to a tag outside
the loop, terminating the loop. A GOTO command within the block of code may
direct execution to a tag within the same block of code; this tag may be in a
nested code block. A GOTO command within the block of code may not direct
execution to a tag within another code block.
The following forms of GOTO are legal:

mainloop ; Example of a GOTO to outside of the code block
  WHILE 1=1 {
      WRITE !,"In an infinite WHILE loop"
      GOTO tag
      WRITE !,"This should not display"
  }
  WRITE !,"This should not display"
tag
  WRITE !,"Went to tag and quit"
  QUIT

mainloop ; Example of a GOTO to within the code block
  SET x=1
  WHILE x<3 {
      WRITE !,"In the WHILE loop"
      GOTO tag
      WRITE !,"This should not display"
tag
      WRITE !,"Still in the WHILE loop after GOTO"
      SET x=x+1
      WRITE !,"x= ",x
      }
  WRITE !,"WHILE loop done"

mainloop ; Example of a GOTO from a nested code block
   SET x=1
   WHILE x<6
   {
     WRITE !,"First time through, x=",x
     IF x#2=0 {
       WRITE !,"Even numbered loop, x=",x
       SET x=x+1
       GOTO tag
       }
     ELSE {
       WRITE !,"Odd numbered loop, x=",x
       SET x=x+1
       GOTO tag
       }
     WRITE !,"This should never write"
tag
     WRITE !,"Bottom of the WHILE loop"
   }
   WRITE !,"WHILE loop done"
   QUIT
The following forms of GOTO are not legal:

mainloop ; ILLEGAL: a GOTO into a nested code block
 WHILE expression1 {
   // ...
   GOTO tag
   IF expression2 {
     // ...
   }
   ELSE {
tag // ...
   }
   // ...
  }
  WRITE "done"

mainloop ; ILLEGAL: a GOTO into another code block
    WHILE expression1 {
      // ...
      GOTO tag
    }
    IF expression2 {
tag // ...
    }

See Also

  • DO WHILE command
  • FOR command
  • IF command
  • CONTINUE command
  • GOTO command
  • QUIT command


 #}}}
*WRITE*  #{{{

Displays output.
Synopsis

WRITE:pc writeargument,...
W:pc writeargument,...

where writeargument can be

f
expression
*integer-expression

Arguments

pc                   Optional  A postconditional expression.

                     Optional  One or more format control code characters that
f                    position the output on the target device. Format control
                     characters include !, #, ?, and /.

                     Optional  The value to write to the output device. Any
expression           valid Caché ObjectScript expression, including literals,
                     variables, object methods, and object properties that
                     evaluates to either a numeric or a quoted string.

                     Optional  The numeric code for a character to write to the
                     output device. For ASCII, integers in the range 0 to 255;
                     for Unicode, integers in the range 0 to 65534. Any valid
                     Caché ObjectScript expression that evaluates to an integer
*integer-expression  in the appropriate range. The asterisk is mandatory.
                     Caché supports the use of negative integer expressions as
                     device controls. The values *-1 and *-10 are supported for
                     terminals, and several negative integer values are
                     supported for magnetic tape I/O.

Description
The WRITE command displays the specified output on the current I/O device. (To
set the current I/O device, use the USE command, which sets the value of the 
$IO special variable.) WRITE has two forms:

  • WRITE without an argument
  • WRITE with arguments

WRITE without an Argument
WRITE without an argument lists the names and values of all defined variables
in the local environment. It presents these variables as follows:

varname1=value1
varname2=value2

Note that an argumentless WRITE automatically provides formatting to separate
the listed variables. It lists string values enclosed in double quotation
marks.
Argumentless WRITE traverses an array in subscript tree order, as shown in the
following example:

a(1)="United States"
a(1,1)="Northeastern Region"
a(1,1,1)="Maine"
a(1,1,2)="New Hampshire"
a(1,2)="Southeastern Region"
a(1,2,1)="Florida"
a(2)="Canada"
a(2,1)="Maritime Provinces"

A postconditional expression can be specified with an argumentless WRITE. An
argumentless WRITE must be separated by at least two blank spaces from a
command following it on the same line.
WRITE with Arguments
WRITE expression displays the sequence of characters identified by the
expression. Expression can evaluate to a number or a quoted string.
WRITE *integer-expression displays the character represented by the integer
expression.
A WRITE command can take any combination of expression, *integer-expression,
and f arguments. WRITE arguments are separated by commas.
You must use the f argument and blank spaces within strings to provide any
desired output formatting; WRITE with arguments provides no automatic
formatting to separate argument values or indicate strings. For example:

   WRITE "numbers",1,2,3
   WRITE "letters","ABC"
displays as numbers123lettersABC.
Note that WRITE does not append a line return to its output string. In order to
separate WRITE output, you must explicitly specify line return (new line) using
the ! character.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). You can specify a postconditional expression for an
argumentless WRITE or a WRITE with arguments. For further details, refer to
Command Postconditional Expressions in Using Caché ObjectScript.
f
A format control to position the output on the target device. You can specify
any combination of format control characters without intervening commas, but
you must use a comma to separate a format control from an expression. For
example, when you issue the following WRITE to a terminal:

   WRITE #!!!?6,"Hello",!,"world!"

The format controls position to the top of a new screen (#), then issue three
line returns (!!!), then indent six columns (?6). The WRITE then displays the
string Hello, issues a line return, then displays the string world!. Note that
the line return repositions to column 1; thus in this example, Hello is
displayed indented, but world! is not.
Format control characters cannot be used with an argumentless WRITE.
For further details, see Using Format Controls with WRITE .
expression
The value you wish to output. Most commonly this is either a quoted string or a
numeric. However, expression can be any valid Caché ObjectScript expression,
including literals, variables, object methods, and object properties. For more
information on expressions, see Using Caché ObjectScript.
*integer-expression
Any valid Caché ObjectScript expression that evaluates to an integer that
corresponds to a character. An integer-expression in the range of 0 through 255
evaluates to the corresponding 8-bit ASCII character. An integer-expression in
the range of 256 through 65534 evaluates to the corresponding 16-bit Unicode
character. Integer expressions can be used to display accented characters. For
example to display the word  Caché you can use:

   WRITE "Cach",*233
To write the name of the composer Anton Dvorak with the proper Czech accent
marks, use:

   WRITE "Anton Dvo",*345,*225,"k"
Integer expressions can also be used to insert control characters (such as the
line feed: *12) which govern the appearance of the display, or special
characters such as *7, which rings the bell on a terminal.
*integer-expression and $X, $Y
An integer expression does not change the $X and $Y special variables when
writing to a terminal. Thus, WRITE "a" and WRITE $CHAR(97) both increment the
column number value contained in $X, but WRITE *97 does not increment $X.
You can issue a backspace (ASCII 8), a line feed (ASCII 10), or other control
character without changing the $X and $Y values by using *integer-expression.
The following Caché Terminal examples demonstrate this use of integer
expressions.
Backspace:

  WRITE $X,"/",$CHAR(8),$X   ; displays: 01
  WRITE $X,"/",*8,$X         ; displays: 02

Linefeed:

  WRITE $Y,$CHAR(10),$Y
     /* displays: 1
                   2  */
  WRITE $Y,*10,$Y
     /* displays: 4
                   4  */

For further details, see the $X and $Y special variables, and  Terminal I/O in 
Caché I/O Device Guide.
Examples
In the following example, the WRITE command sends the current value in variable
var1 to the current output device.

  SET var1="hello world"
  WRITE var1
In the following example, both WRITE commands display the Unicode character for
pi. The first uses the $CHAR function, the second an integer-expression:

   WRITE !,$CHAR(960)
   WRITE !,*960
The following example writes first name and last name values along with an
identifying text for each. The WRITE command combines multiple arguments on the
same line. It is equivalent to the two WRITE commands in the example that
follows it. The ! character is a format control that produces a line break.
(Note that the ! line break character is still needed when the text is output
by two different WRITE commands.)

   SET fname="Bertie"
   SET lname="Wooster"
   WRITE "First name: ",fname,!,"Last name: ",lname
is equivalent to:

   SET fname="Bertie"
   SET lname="Wooster"
   WRITE "First name: ",fname,!
   WRITE "Last name: ",lname
In the following example, assume that the current device is the user’s
terminal. The READ command prompts the user for first name and last name and
stores the input values in variables fname and lname, respectively. The WRITE
command displays the values in fname and lname for the user’s confirmation. The
string containing a space character (" ") is included to separate the output
names.

Test
  READ !,"First name: ",fname
  READ !,"Last name: ",lname
  WRITE !,fname," ",lname
  READ !,"Is this correct? (Y or N) ",check#1
  IF "Nn"[check {
    GOTO Test
  }

The following example writes the current values in the ^client(1,n) nodes.

   SET ^client(1,1)="Mary Smith"
   SET ^client(1,2)="123 Primrose Path"
   SET ^client(1,3)="Johnson City"
   SET ^client(1,4)="TN"
   SET n=1
Elements
    IF $DATA(^client(1,n)) {
      WRITE ^client(1,n),!
      SET n=n+1
      GOTO Elements
      }
    ELSE { QUIT }
The following command writes the current value of an object property:

   WRITE person.LastName

where person is the object reference, and LastName is the object property name.
Note that dot syntax is used in object expressions; a dot is placed between the
object reference and the object property name or object method name.
The following command writes the value returned by the object method 
TotalLines():

   WRITE invoice.TotalLines()

A write command for objects can take an expression with cascading dot syntax,
as shown in the following example:

   WRITE patient.Doctor.Hospital.Name

In this example, the patient.Doctor object property references the Hospital
object, which contains the Name property. Thus, this command writes the name of
the hospital affiliated with the doctor of the specified patient. The same
cascading dot syntax can be used with object methods.
A write command for objects can be used with system-level methods, such as the
following data type property method:

   WRITE patient.AdmitDateIsValid(date)

In this example, the AdmitDateIsValid() property method returns its result for
the current patient object. AdmitDateIsValid() is a boolean method for data
type validation of the AdmitDate property. Thus, this command writes a 1 if the
specified date is a valid date, and writes 0 if the specified date is not a
valid date.
Note that any object expression can be further specified by declaring the class
or superclass to which the object reference refers. Thus, the above examples
could also be written:

   WRITE ##class(Patient)patient.Doctor.Hospital.Name

   WRITE ##class(Patient)patient.AdmitDateIsValid(date)

Notes
WRITE with $X and $Y
A WRITE displays the characters resulting from the expression evaluation one at
a time in left-to-right order. Caché records the current output position in the
$X and $Y special variables, with $X defining the current column position and 
$Y defining the current row position. As each character is displayed, $X is
incremented by one.
In the following example, the WRITE command gives the column position after
writing the 11 character string Hello world.

   WRITE "Hello world"," "_$X," is the column number"

Note that writing a blank space between the displayed string and the $X value (
," ",$X) would cause that blank space to increment $X before it is evaluated;
but concatenating a blank space to $X (," "_$X) displays the blank space, but
does not increment the value of $X before it is evaluated.
Even using a concatenated blank, the display from $X or $Y does, of course,
increment $X, as shown in the following example:

   WRITE $Y," "_$X
   WRITE $X," "_$Y

In the first WRITE, the value of $X is incremented by the number of digits in
the $Y value (which is probably not what you wanted). In the second WRITE, the
value of $X is 0.
With $X you can display the current column position during a WRITE command. To
control the column position during a WRITE command, you can use the ? format
control character. The ? format character is only meaningful when $X is at
column 0. In the following WRITE commands, the ? performing indenting:

   WRITE ?5,"Hello world",!
   WRITE "Hello",!?5,"world"

WRITE with Integer Expressions
The *integer-expression form allows you to write an integer code to the current
device. Note that integer-expression can specify an arithmetic expression or
variable name (local variable, process-private global, or global). The only
requirement is that the resulting value be a positive integer. Integers in the
range 0 to 255 correspond to the ASCII character set. Integers in the range 0
to 65534 correspond to the Unicode character set.
The following examples all return the word  Caché :

   WRITE !,"Cach",*233
   WRITE !,*67,*97,*99,*104,*233
   SET accent=233
   WRITE !,"Cach",*accent  ; variables are evaluated
   WRITE !,"Cach",*232+1   ; arithmetic operations are evaluated
   WRITE !,"Cach",*00233.999 ; numbers are evaluated to integers
The integer resulting from the expression evaluation may correspond to a
control character. Such characters are interpreted according to the target
device. For example, if the current device is a terminal, the integer is
interpreted as ASCII control characters. The following commands send ASCII
codes 7 and 12 to the terminal.

   WRITE *7 ; Sounds the bell
   WRITE *12 ; Form feed (blank line)

Here’s an example using the form feed character:

   WRITE "stepping",*12,"down",*12,"the",*12,"stairs"

Using Format Controls with WRITE
The f argument allows you to include any of the following format control
characters. When used with output to the terminal, these controls determine
where the output data appears on the screen. You can specify any combination of
format control characters.
! Format Control Character
Advances one line and positions to column 0 ($Y is incremented by 1 and $X is
set to 0). The actual control code sequence is device-dependent; it generally
either ASCII 13 (RETURN), or ASCII 13 and ASCII 10 (LINE FEED).
Caché does not perform an implicit new line sequence for WRITE with arguments.
When writing to a terminal it is a good general practice to begin (or end)
every WRITE command with a ! format control character.
You can specify multiple ! format controls. For example, to advance five lines,
WRITE !!!!!. You can combine ! format controls with other format controls.
However, note that the following combinations, though permitted, are not in
most cases meaningful: !# or !,# (advance one line, then advance to the top of
a new screen, resetting $Y to 0) and ?5,! (indent by 5, then advance one line,
undoing the increment). The combination ?5! is not legal.
If the current device is a TCP device, ! does not output a RETURN and LINE
FEED. Instead, it flushes any characters that remain in the buffer and sends
them across the network to the target system.
# Format Control Character
Produces the same effect as sending the CR (ASCII 13) and FF (ASCII 12)
characters to a pure ASCII device. (The exact behavior depends on the operating
system type, device, and record format.) On a terminal, the # format control
character clears the current screen and starts at the top of the new screen in
column 0. ($Y and $X are reset to 0.)
You can combine # format controls with other format controls. However, note
that the following combinations, though permitted, are not in most cases
meaningful: !# or !,# (advance one line, then advance to the top of a new
screen, resetting $Y to 0) and ?5,# (indent by 5, then advance to the top of a
new screen, undoing the increment). The combination ?5# is not legal.
?n Format Control Character
This format control consists of a question mark (?) followed by an integer, or
an expression that evaluates to an integer. It positions output at the nth
column location (counting from column 0) and resets $X. If this integer is less
than or equal to the current column location (n<$X), this format control has no
effect. You can reference the $X special variable (current column) when setting
a new column position. For example, ?$X+3.
/mnemonic Format Control Character
This format control consists of a slash (/) followed by a mnemonic keyword, and
(optionally) a list parameters to be passed to the mnemonic.

/mnemonic(param1,param2,...)

Caché interprets mnemonic as an entry point name defined in the active mnemonic
space. This format control is used to perform such device functions as
rewinding a magnetic tape or positioning the cursor on a screen. If there is no
active mnemonic space, an error results. Amnemonic may (or may not) require a
parameter list.
You can establish the active mnemonic space in either of the following ways:

  • Go to the System Management Portal, select [Home] > [Configuration] >
    [Device Settings] > [IO Settings]. View and edit the File, MagTape, Other,
    or Terminal mnemonic space setting.
  • Include the /mnemonic space parameter in the OPEN or USE command for the
    device.

The following are some examples of mnemonic device functions:

Mnemonic                               Description

/IC(n)    Inserts spaces for n characters at the current cursor location,
          moving the rest of the line to the right

/DC(n)    Deletes n characters to the right of the cursor and collapses the
          line

/EC(n)    Erases n characters to the right of the cursor, leaving blanks in
          their stead

For further details on mnemonics, see the Caché I/O Device Guide.
Specifying a Sequence of Format Controls
Caché allows you to specify a sequence of format controls and to intersperse
format controls and expressions. When specifying a sequence of format controls
it is not necessary to include the comma separator between them (though commas
are permitted.) A comma separator is required to separate format controls from
expressions.
In the following example, the WRITE command advances the output by two lines
and positions the first output character at the column location established by
the input for the READ command.

   READ !,"Enter the number: ",num
   SET col=$X
   SET ans=num*num*num
   WRITE !!,"Its cube is: ",?col,ans

Thus, the output column varies depending on the number of characters input for
the READ.
Escape Sequences with WRITE
The WRITE command, like the READ command, provides support for escape
sequences. Escape sequences are typically used in format and control
operations. Their interpretation is specific to the current device type.
To output an escape sequence, use the form:

   WRITE *27,"char"

where *27 is the ASCII code for the escape character, and char is a literal
string consisting of one or more control characters. The enclosing double
quotes are required.
For example, if the current device is a VT-100 compatible terminal, the
following command erases all characters from the current cursor position to the
end of the line.

   WRITE *27,"[2J"

To provide device independence for a program that can run on multiple
platforms, use the SET command at the start of the program to assign the
necessary escape sequences to variables. In your program code, you can then
reference the variables instead of the actual escape sequences. To adapt the
program for a different platform, simply make the necessary changes to the
escape sequences defined with the SET command.
Device Controls
Caché supports the use of negative integer expressions as device controls. For
example, in OpenVMS, the following command rewinds and unloads the tape on the
current magnetic tape device.

   WRITE *-13

The following sections describe these controls for terminal and magnetic tape
devices.
Terminal Devices
Caché supports the *-1 and *-10 controls for terminal devices. These controls
clear the input buffer of any characters that have not yet been accepted by a 
READ command. The *-1 control clears the input buffer upon the next READ. The 
*-10 control clears the input buffer immediately.
An input buffer holds characters as they arrive from the keyboard, even those
the user types before the routine executes a READ command. In this way, the
user can type-ahead the answers to questions even before the prompts appear on
the screen. When the READ command takes characters from the buffer, Caché
echoes them to the terminal so that questions and answers appear together. When
a routine detects errors it may use the *-1 or *-10 control to delete these
type-ahead answers. For further details, see Terminal I/O in the 
Caché I/O Device Guide.
Magnetic Tape Devices
Caché platforms support a number of controls for magnetic tape devices. The
following table lists these controls and their functions. For further details,
see Magnetic Tape I/O in the Caché I/O Device Guide.

Code  Function                               Effect

-1    Backspace  Backspaces tape one block. (Not supported for cartridge tape.)

                 Advances tape one block (skipping labels) so that WRITE * 2 at
-2    Forward    the beginning of the tape (BOT) skips volume and header labels
      Space      as well as the first data block. (Not supported for cartridge
                 tape.)

-3    Write      Writes a tape mark. If the buffer contains unwritten data,
      Tape Mark  that data is written out first.

      Write      Writes out the current buffer. If the format specifies labels
-4    Block      and the tape is at BOT, header labels of the appropriate
                 format are written before the data block.

                 Rewinds the tape. Any unwritten data (in addition to trailer
-5    Rewind     labels and tape marks required by the format) is written
                 before rewinding occurs.

-6    Read       Reads the next block. If the tape is at BOT, skips header
      Block      labels before reading.

-7    Read       Reads the next block whether or not it is a label. (Not
      Label      supported for cartridge tape.)

      Write      If the format specifies labels, writes header labels. If the
-8    Header     tape is at BOT, writes a volume label before the header
      Label      labels. (Not supported for cartridge tape.)

                 Writes any unwritten data. If the format specifies labels,
-9    Write EOF  writes the appropriate trailer label. Writes two tape marks
      Label      and backspaces over the second. (Not supported for cartridge
                 tape.)

      Rewind     For OpenVMS only: performs all the function WRITE *-5, then
-13   and        unloads the tape. This control lets you create an output set
      Unload     that spans more than one tape volume.

When writing block-oriented data to magnetic tape, the $ZB special variable
contains the number of bytes remaining in the I/O buffer. Refer to $ZB for
further details.
See Also

  • USE command
  • READ command
  • $X special variable
  • $Y special variable
  • Writing escape sequences for Terminal I/O and Interprocess Communications
    in the Caché I/O Device Guide
  • Terminal I/O in Caché I/O Device Guide
  • Magnetic Tape I/O in Caché I/O Device Guide
  • Sequential File I/O in Caché I/O Device Guide
  • The Spool Device in Caché I/O Device Guide


 #}}}
*XECUTE*  #{{{

Executes the specified commands.
Synopsis

XECUTE:pc xecutearg,...
X:pc xecutearg,...

where xecutearg can be either of the following

"cmdline":pc

("(fparams) cmdline",params):pc

Arguments

pc       Optional  A postconditional expression.

         An expression that resolves to a command line consisting of one or
cmdline  more valid Caché ObjectScript commands. Note that the cmdline or (
         fparams) cmdline must be specified as a quoted string.

         Optional  A formal parameters list, specified as a comma-separated
fparams  list enclosed in parentheses. Formal parameters are variables use by 
         cmdline, the values of which are supplied by passing params. Note that
         the fparams are the first item within the quoted code string.

         Optional  A parameters list, specified as a comma-separated list.
params   These are the parameters passed to fparams. If params are specified,
         an equal or greater number of fparams must be specified.

Description
XECUTE executes one or more Caché ObjectScript command lines, each command line
specified by an xecutearg. You can specify multiple xecuteargs, separated by
commas. These xecutearg are executed in left-to-right sequence, the execution
of each being governed by an optional postconditional expression. There are two
syntactical forms of xecutearg:

  • Without parameter passing. This form uses no parentheses.
  • With parameter passing. This form requires enclosing parentheses.

An XECUTE can contain any combination of these two forms of xecutearg. You can
use $ZUTIL(62) to perform syntax checking on a xecutearg command line string.
In effect, each xecutearg is like a one-line subroutine called by a DO command
and terminated when the end of the argument is reached or a QUIT command is
encountered. After Caché executes the argument, it returns control to the point
immediately after the xecutearg.
Each invocation of XECUTE places a new context frame on the call stack for your
process. The $STACK special variable contains the current number of context
frames on the call stack.
The XECUTE command performs substantially the same operation as the $XECUTE
function, with the following differences: The command can use postconditionals,
the function cannot. The command can specify multiple xecuteargs, the function
can specify only one xecutearg. The command does not require a QUIT to complete
execution; the function requires an argumented QUIT for every execution path.
Arguments
pc
An optional postconditional expression. If a postconditional expression is
appended to the command keyword, Caché only executes the XECUTE command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the XECUTE command if the postconditional expression is
false (evaluates to zero).
If a postconditional expression is appended to an xecutearg, Caché evaluates
the argument only if the postconditional expression is true (evaluates to a
nonzero numeric value). If the postconditional expression is false, Caché skips
that xecutearg and evaluates the next xecutearg (if one exists). For further
details, refer to Command Postconditional Expressions in 
Using Caché ObjectScript.
cmdline
Each cmdline must evaluate to a string containing one or more Caché
ObjectScript commands. Note that in some cases two spaces must be inserted
between a command and the command following it. The cmdline string must not
contain a tab character at the beginning or a <Return> at the end. The string
must be no longer than a valid Caché ObjectScript program line.
The cmdline can evaluate to a null string (""). In this case, Caché performs no
action and continues execution with the next xecutearg (if one exists).
If you are passing parameters, the fparams formal parameter list must precede
the cmdline commands, with both elements enclosed in the same quotation marks.
The fparams must be separated from the cmdline by one or more spaces.

  SET x=1
  XECUTE ("(in,out) SET x=in+3 SET out=x",x,.y)
  WRITE x   ; the value of x is 4
By default, all local variables used in cmdline are public variables. You can
designate variables within the command line as private variables by enclosing
the command setting them within curly braces. For example:

  SET x=1
  XECUTE ("(in,out) {SET x=in+3 SET out=x}",x,.y)
  WRITE x     ; the value of x is 1
You can override this designation of private variables for specific variables
by specifying a public variable list, enclosed in square brackets, immediately
after the fparams formal parameter list. The following example specifies a
public variable list containing the variable x:

  SET x=1
  XECUTE ("(in,out) [x] {SET x=in+3 SET out=x}",x,.y)
  WRITE x     ;the value of x is 4
fparams
A list of formal parameters, separated by commas and enclosed by parentheses.
Formal parameter names must be valid identifiers. Because these formal
parameters are executed in another context, they must only be unique within
their xecutearg; they have no effect on local variables with the same name in
the program that issued the XECUTE, or in another xecutearg. You do not have to
use any or all of the fparams in cmdline. However, the number of fparams must
equal or exceed the number of params specified, or a <PARAMETER> error is
generated.
params
The actual parameters to be passed from the invoking program to fparams,
specified as a comma-separated list. The params must be defined variables
within the calling program.
You can use a dot prefix to pass a parameter by reference. This is useful for
passing a value out from a cmdline. An example is provided below. For further
details, refer to  Passing by Reference in the User-defined Code chapter of 
Using Caché ObjectScript.
Examples
The following example passes a parameter to a command line that sets a global.
Two command lines are provided. Execution of each depends upon their
postconditional setting.

  SET bad=0,good=1
  SET val="paid in full"
  XECUTE ("(pay) SET ^acct1=pay",val):bad,("(pay) SET ^acct2=pay",val):good

Here the first xecutearg is skipped because of the value of the bad
postconditional. The second xecutearg is executed with val being passed in as a
parameter, supplying a value to the pay formal parameter used in the command
line.
The following example uses passing by reference (.y) to pass a local variable
value from the cmdline to the invoking context.

CubeIt
  SET x=5
  XECUTE ("(in,out) SET out=in*in*in",x,.y)
  WRITE !,x," cubed is ",y
In the following example, the XECUTE command references the local variables x
and y. x and y each contain a string literal consisting of three separate Caché
ObjectScript commands that XECUTE invokes.

   SET x="SET id=ans QUIT:ans="""" DO Idcheck"
   SET y="SET acct=num QUIT:acct="""" DO Actcheck"
   XECUTE x,y

The following example uses XECUTE with a $SELECT construction.

   XECUTE "SET A=$SELECT(A>100:B,1:D)"

The following example executes the subroutine that is the value of A.

   SET A="WRITE ! FOR I=1:1:5 { WRITE ?I*5,I+1 }"
   XECUTE A
2 3 4 5 6
Notes
XECUTE and Objects
You can use XECUTE to call object methods and properties and execute the
returned value, as shown in the following examples:

   XECUTE patient.Name
   XECUTE "WRITE patient.Name"

XECUTE and FOR
If an XECUTE argument contains a FOR command, the scope of the FOR is the
remainder of the argument. When the outermost FOR in an XECUTE argument is
terminated, the XECUTE argument is also terminated.
XECUTE and DO
If an XECUTE command contains a DO command, Caché executes the routine or
routines specified in the DO argument or arguments. When it encounters a QUIT,
it returns control to the point immediately following the DO argument.
For example, in the following commands, Caché executes the routine ROUT and
returns to the point immediately following the DO argument to write the string
 DONE .

   XECUTE "DO ^ROUT WRITE !,""DONE"""

XECUTE and GOTO
If an XECUTE argument contains a GOTO command, Caché transfers control to the
point specified in the GOTO argument. When it encounters a QUIT, it does not
return to the point immediately following the GOTO argument that caused the
transfer. Instead, Caché returns control to the point immediately following the
XECUTE argument that contained the GOTO.
In the following example, Caché transfers control to the routine ROUT and
returns control to the point immediately following the XECUTE argument to write
the string  FINISH . It never writes the string  DONE .

   XECUTE "GOTO ^ROUT WRITE !,""DONE""" WRITE !,"FINISH"

XECUTE and QUIT
There is an implied QUIT at the end of each XECUTE argument.
XECUTE with $TEXT
If you include a $TEXT function within a cmdline, it designates lines of code
in the routine that contains the XECUTE. For example, in the following program,
the $TEXT function retrieves and executes a line.

A
   SET H="WRITE !!,$PIECE($TEXT(HELP+1),"","",3)"
   XECUTE H
   QUIT
HELP
   ;; ENTER A NUMBER FROM 1 TO 5

Running routine A extracts and writes  ENTER A NUMBER FROM 1 TO 5 .
Nested Invocation of XECUTE
Caché ObjectScript supports the use of XECUTE within an XECUTE argument.
However, you should use nested invocation of XECUTE with caution because it can
be difficult to determine the exact flow of processing at execution time.
Execution Time for Commands Called by XECUTE
The execution time for code called within XECUTE can be slower than the
execution time for the same code encountered in the body of a routine. This is
because Caché compiles source code that is specified with the XECUTE command or
that is contained in a referenced global variable each time it processes the 
XECUTE.
Implementing Generalized Operations
A typical use for XECUTE is to implement generalized operations within an
application. For example, assume that you want to implement an inline
mathematical calculator that would allow the user to perform mathematical
operations on any two numbers and/or variables. To make the calculator
available from any point in the application, you might use a specific function
key (say, F1) to trigger the calculator subroutine.
A simplified version of the code to implement such a calculator might appear as
follows.

Start  SET ops=$CHAR(27,21)
  READ !,"Total amount (or F1 for Calculator): ",amt
  IF $ZB=ops { DO Calc
    ; . . .
  }
Calc  READ !,"Calculator"
  READ !,"Math operation on two numbers and/or variables."
  READ !,"First number or variable name: ",inp1
  READ !,"Mathematical operator (+,,*,/): ",op
  READ !,"Second number or variable name: ",inp2
  SET doit="SET ans="_inp1_op_inp2
  XECUTE doit
  WRITE !,"Answer (ans) is: ",ans
  READ !,"Repeat? (Y or N) ",inp
  IF (inp="Y")!(inp="y") { GOTO Calc+2 }
  QUIT

When executed, the Calc routine accepts the user inputs for the numbers and/or
variables and the desired operation and stores them as a string literal
defining the appropriate SET command in variable doit. The XECUTE command
references doit and executes the command string that it contains. This code
sequence can be called from any number of points in the application, with the
user supplying different inputs each time. The XECUTE performs the SET command
each time, using the supplied inputs.
XECUTE and ZINSERT
You use the XECUTE command to define and insert a single line of executable
code from within a routine. You can use the ZINSERT command from the programmer
prompt to define and insert by line position a single line of executable code
into the current routine. You can use the ZREMOVE command from the programmer
prompt to delete by line position one or more lines of executable code from the
current routine.
An XECUTE command cannot be used to define a new label. Therefore, XECUTE does
not require an initial blank space before the first command in its code line. 
ZINSERT can be used to define a new label. Therefore, ZINSERT does require an
initial blank space (or the name of a new label) before the first command in
its command line.
See Also

  • DO command
  • GOTO command
  • QUIT command
  • ZINSERT command
  • $TEXT function
  • $XECUTE function
  • $ZUTIL(62) function
  • $STACK special variable


 #}}}
*ZBREAK*  #{{{

Sets a breakpoint.
Synopsis

ZBREAK:pc location:action:condition:execute_code
ZB:pc location:action:condition:execute_code

ZBREAK:pc /command:option
ZB:pc /command:option

Arguments

pc            Optional  A postconditional expression.

              Specifies a code location (that sets a breakpoint) or a local or
location      system variable (which sets a watchpoint). If the location
              specified already has a breakpoint/watchpoint defined, the new
              specification completely replaces the old one.

              Optional  Specifies the action to take when the breakpoint/
              watchpoint is triggered, specified as an alphabetic code. Action
:action       code letters may be uppercase or lowercase, but must be enclosed
              in quotation marks. If omitted, default is  B . If omitted, and
              either :condition or :execute_code is specified, the colon must
              appear as a placeholder.

              Optional  Specifies an expression that will be evaluated to a
              boolean value when the breakpoint/watchpoint is triggered. The
:condition    expression must be surrounded by quotation marks. If true, action
              is carried out. If not specified, the default is true. If
              omitted, and :execute_code is specified, the colon must appear as
              a placeholder.

:             Optional  Specifies Caché ObjectScript code to be executed if :
execute_code  condition is true. The code must be surrounded by quotation marks
              if it is a literal.

              A command governing all breakpoints and watchpoints. The slash
/command:     (/) prefix is mandatory. Available commands are: /CLEAR, /DEBUG,
option        /TRACE, /ERRORTRAP, /INTERRUPT, /STEP, and /NOSTEP. All except /
              CLEAR take an option, as described below.

Description
ZBREAK sets breakpoints at specific lines of code and watchpoints on specific
variables to allow you to interrupt program execution for debugging. This
command is described fully in the Debugging chapter in Using Caché ObjectScript
.
You can set a maximum of 20 breakpoints within a routine. Attempting to set
more than 20 breakpoints results in a <COMMAND> error.
To view online help text about ZBREAK at the terminal prompt, specify a
question mark, as follows:

USER>ZBREAK ?

Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
location
A required argument that specifies the breakpoint location as a line reference,
*variable, or $. To set a breakpoint, specify the location and, optionally, the
action, condition, and/or execute_code. Any of these optional arguments may be
omitted, but if specified or skipped, the mandatory colon separators (:) must
be specified.
The location argument may be prefixed by plus and minus signs, which indicate
what to do with an existing breakpoint at the specified location:

Sign Prefix              Meaning

location     Set breakpoint at location.

 location    Disable breakpoint at location.

+location    Enable breakpoint at location.

- location   Remove breakpoint at location.

action
A code that specifies the action to take when the breakpoint/watchpoint is
triggered. For breakpoints, the action occurs before the line of code is
executed. For watchpoints, the action occurs after the command that modifies
the local variable.

Action                                Description
 Code

        Suspends execution and displays the line at which the break occurred,
 B      with a caret (^) indicating the location within the line. A GOTO
        resumes execution.  B is the default.

        Suspends execution for single-step execution of lines using GOTO.
 L      Single-step mode suspended during DO, XECUTE, or user-defined
        functions.

        Suspends execution for single-step execution of lines using GOTO.
 L+     Single-step mode also applies to DO, XECUTE, and user-defined
        functions.

        Suspends execution for single-step execution of commands using GOTO.
 S      Single-step mode suspended during DO, FOR, XECUTE, or user-defined
        functions.

        Suspends execution for single-step execution of commands using GOTO.
 S+     Single-step mode also applies to DO, FOR, XECUTE, and user-defined
        functions.

        Outputs a trace message to the trace device. Can be combined with any
        other action code. For example  TB means suspend execution ( B ) and
 T      output trace message ( T ).  T by itself does not suspend execution.
        This action only works if a previous ZBREAK command specifies ZBREAK /
        TRACE:ON.

 N      Take no action at this breakpoint or watchpoint.

condition
A boolean expression. When true (1), the action should be taken and the 
execute_code (if present) executed. When false (0), the action and execute_code
are ignored. Default is true (1).
execute_code
The Caché ObjectScript code to be executed. This code is executed before the 
action being carried out. Before the code is executed, the value of $TEST is
saved. After the code has executed, the value of $TEST as it existed in the
program being debugged is restored.
/command:option
A command keyword used to set the ZBREAK environment for subsequent ZBREAK
commands. The /CLEAR command takes no option. The other command keywords are
followed by an option, separated by a colon.

 Keyword                               Description

/CLEAR     Remove all breakpoints.

/DEBUG:    Clear or set debug device.
device

           Enable or disable sending trace messages to the trace device (the  T
            action in subsequent ZBREAK commands.) Options are :ON=enable
/TRACE     trace. :OFF=disable trace. :ALL=trace all lines. You can redirect
           output with the :ON or :ALL options by specifying a device. For
           example ZBREAK /TRACE:ON:device.

/          Enable or disable $ZTRAP, $ETRAP, and TRY/CATCH error trapping.
ERRORTRAP  Options are :ON and :OFF.

/          Specify Ctrl-C action. Options are :NORMAL and :BREAK.
INTERRUPT

           Enable stepping through code modules. Options are :EXT (user
/STEP      language extensions); :METHOD (object methods); :DESTRUCT (the
           %Destruct object method).

           Disable stepping through code modules. Options are :EXT (user
/NOSTEP    language extensions); :METHOD (object methods); :DESTRUCT (the
           %Destruct object method).

The /STEP and /NOSTEP command keywords control whether the debugger steps
through certain types of code modules:

  • The :EXT option governs user-written language extensions created in %ZLANG.
    To an application, these language extensions appear as a single command or
    function call. By default, the debugger does not step through these %ZLANG
    routines, regardless of the action argument setting.
  • The :METHOD option governs stepping through object methods called by the
    application. By default, the debugger steps through object method code.
  • The :DESTRUCT option governs stepping through the %Destruct object method.
    The %Destruct method is implicitly called whenever an object is destroyed.
    By default, the debugger does not step through %Destruct object method
    code.

See Also

  • BREAK command
  • OPEN command
  • USE command
  • $ZUTIL(68,5) Argumentless BREAK Process Switch function
  • $ZUTIL(69,5) Argumentless BREAK System Default function
  • Debugging chapter in Using Caché ObjectScript


 #}}}
*ZINSERT*  #{{{

Inserts a line of code in the current routine.
Synopsis

ZINSERT:pc "code":location
ZI:pc "code":location

Arguments

pc        Optional  A postconditional expression.

          A line of Caché ObjectScript code, specified as a string literal
code      (enclosed in quotation marks) or a variable that contains a string
          literal. The first character must be either a space or a label name.

location  Optional  The line after which ZINSERT inserts the code.

Description
ZINSERT "code" inserts a specified line of Caché ObjectScript code in the
current routine at the current line location (edit pointer), as established by
the ZPRINT or ZREMOVE command, by a previous ZINSERT command, or by some forms
of the $TEXT function.
ZINSERT "code":location inserts the specified line of code in the current
routine after the specified line location. Line location can be specified as
number of lines offset from the beginning of the routine, or number of lines
offset from a specified label.
After ZINSERT inserts a line of code, it resets the edit pointer to the end of
this new line of code. This means the next ZINSERT places its line of code
directly after the last new line, unless it explicitly specifies a location.
ZINSERT effects only the local copy of the routine. It does not change the
routine as stored on disk. To store inserted lines, you must use the ZSAVE
command to save the routine. ZINSERT incrementally compiles each line.
The ZINSERT command is usually executed from the programmer prompt. It should
not be coded into the body of a routine, because its operation would effect the
execution of that routine. To call ZINSERT from a routine, use the XECUTE
command.
Caution:
ZINSERT and other commands move the edit pointer.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
code
A line of Caché ObjectScript code, specified as a string literal (in quotes),
or a variable that contains a string literal. This line of code can contain one
or more Caché ObjectScript commands, a new label name, or both a label and one
or more commands. Because the code is inserted into a routine, it must follow
Caché ObjectScript formatting. Therefore, the first character of the code
string literal must either be a blank space (standard Caché ObjectScript
indentation) or a label. The enclosing quotation marks are required. Since
quotation marks enclose the line of code you are inserting, quotes within the
code itself must be doubled.
location
The line after which ZINSERT will insert the code. It can take either of the
following forms:

+offset       Specifies a line number within the routine. (The plus sign is
              required.)

label+offset  Specifies a label and a line number within the labelled section.

Note:
Specifying label^routine for the location generates a <SYNTAX> error.
Lines of code are numbered beginning with 1. Thus a location of +1 inserts a
line of code after the first line of the routine. To insert a line at the start
of the routine or the start of a labelled section (before the existing first
line), use an offset of +0. For example:

   ZINSERT "Altstart SET c=12,d=8":+0

inserts the code line at the start of the routine.
By using an offset of +0, you can insert a line into an otherwise empty current
routine.
If location is omitted, the code is inserted at the current line location (edit
pointer).
Examples
The following example inserts the code line SET x=24 after the fourth line
within the current routine. Because this inserted code line does not begin with
a label, an initial space must be included as the required line start
character.

   ZINSERT " SET x=24":+4

In the following example, assume that the currently loaded routine contains a
label called "Checktest". The ZINSERT command inserts a new line after the
sixth line within Checktest (Checktest+6). This new line contains the label
"Altcheck" and the command SET y=12.

   ZINSERT "Altcheck SET y=12":Checktest+6

Note that because the inserted code line begins with the label  Altcheck , no
initial space is required after the quotation mark.
The following example inserts the code line SET x=24 WRITE !,"x is set to ",x
after the fourth line within the current routine. Because an inserted code line
is enclosed in quotation marks, the quotation marks in the WRITE command must
be doubled.

   ZINSERT " SET x=24 WRITE !,""x is set to "",x":+4

Notes
ZINSERT and ZREMOVE
You can use the ZREMOVE command to remove one or more lines of code from the
currently executing routine. Thus by using ZREMOVE and ZINSERT, you can
substitute a new code line for an existing code line. These operations only
affect the copy of the routine currently being run by your process.
ZINSERT, XECUTE, and $TEXT
You use the XECUTE command to define and insert a single line of executable
code from within a routine. You use the ZINSERT command to define and insert by
line position a single line of executable code from outside a routine.
An XECUTE command cannot be used to define a new label. Therefore, XECUTE does
not require an initial blank space before the first command in its code line. 
ZINSERT can be used to define a new label. Therefore ZINSERT does require an
initial blank space (or the name of a new label) before the first command in
its command line.
The $TEXT function permits you to extract a line of code by line position from
within a routine. $TEXT simply copies the specified line of code as a text
string; it does not affect the execution of that line or change the current
line location (edit pointer) when extracting from the current routine. (Using 
$TEXT to extract code from a routine other than the current routine does change
the current line location.) $TEXT can supply a line of code to the XECUTE
command. $TEXT can also supply a line of code to a WRITE command, and thus
supply a code line to the programmer prompt.
See Also

  • XECUTE command
  • ZLOAD command
  • ZPRINT command
  • ZREMOVE command
  • ZSAVE command
  • $TEXT function


 #}}}
*ZKILL*  #{{{

Deletes a node while preserving the node’s descendants.
Synopsis

ZKILL:pc array-node,...
ZK:pc array-node,...

Arguments

pc          Optional  A postconditional expression.

            A local variable, a process-private global, or a global that is an
array-node  array node, or a comma-separated list of local, process-private
            global, or global array nodes.

Description
The ZKILL command removes the value of a specified array node without killing
that node’s descendants. In contrast, the KILL command removes the value of a
specified array node and all of that node’s descendants. An array node can be a
local variable, a process-private variable, or a global variable.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
array-node
A local, process-private global, or global array node. You can specify a single
array node, or a comma-separated list of array nodes. For further details on
subscripts and nodes, refer to Global Structure in Using Caché Globals.
Example
In this example, the ZKILL command deletes node a(1), but does not remove node
a(1,1).

    SET a(1)=1,a(1,1)=11
    SET x=a(1)
    SET y=a(1,1)
    ZKILL a(1)
    SET z=a(1,1)
    WRITE "x=",x," y=",y," z=",z
returns x=1 y=11 z=11. However, then issuing a:

   WRITE a(1)

generates an <UNDEFINED> error.
See Also

  • KILL command


 #}}}
*ZLOAD*  #{{{

Loads routines into the routine buffer.
Synopsis

ZLOAD:pc routine
ZL:pc routine

Arguments

pc       Optional  A postconditional expression.

routine  Optional  The routine to be loaded. If omitted, Caché loads a routine
         from the current device.

Description
The ZLOAD command loads Caché ObjectScript routines into the routine buffer. 
ZLOAD has two forms:

  • ZLOAD without an argument
  • ZLOAD with an argument

ZLOAD without an Argument
The ZLOAD command without an argument loads a Caché ObjectScript routine from
the current device into the routine buffer. To load a routine from a device,
execute the following:

 1. An OPEN command to open the device.
 2. A USE command to make the device the current device.
 3. A ZLOAD command without arguments.

Line loading will continue until Caché reads a null string line (""). This
loaded routine has no name until you file it with the ZSAVE command.
ZLOAD with an Argument
ZLOAD routine loads the specified (existing) routine into the routine buffer
from the current namespace.
ZLOAD does an implicit ZREMOVE when it loads the routine. That is, ZLOAD
deletes any routine previously loaded as it writes the loaded routine. You can
use the $ZNAME special variable to determine the currently loaded routine. When
ZLOAD loads a routine, it leaves the line pointer at the end of the last line
of the routine.
Once loaded, a routine remains the current one for the process until you load
another routine explicitly, with a ZLOAD command, or implicitly, with a DO or a
GOTO command. As long as the routine is current, you can edit the routine (with
ZINSERT and ZREMOVE commands) and display it (with the ZPRINT command).
You can only use the ZLOAD command when you enter it from the programmer prompt
or when you call it using an XECUTE command or a $XECUTE function. It should
not be coded into the body of a routine because its operation would affect the
execution of that routine. Specifying ZLOAD in a routine results in a compile
error. Any attempt to execute ZLOAD from within a routine also generates an
error.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
routine
The name of the routine to be loaded. Routine names are case-sensitive. If the
specified routine does not exist, Caché generates a <NOROUTINE> error.
You must have execute permission for routine to be able to ZLOAD it. If you do
not have this permission, Cache generates a <PROTECT> error.
If ZLOAD successfully loads routine, all subsequent errors append the name of
the currently loaded routine. This occurs whether or not the error has any
connection to the routine, and occurs across namespaces. For further details,
refer to the $ZERROR special variable.
Examples
The following Caché Terminal example loads the routine ROUT, saved on disk:

USER>ZLOAD ROUT

The following Caché Terminal example loads the first routine from the device 
dev:

USER>OPEN dev
USER>USE dev
USER>ZLOAD

Notes
Routine Behavior with ZLOAD
If you specify routine, Caché looks for the routine in the pool of routine
buffers in memory. If the routine is not there, Caché loads the Caché
ObjectScript object code version of the routine into one of the buffers. The
Caché ObjectScript source (intermediate) code remains in the ^ROUTINE global of
the current namespace, but is updated if you make edits and save the changes.
For example, ZLOAD Test loads the object code version of the routine Test (if
it is not already loaded). You can view and edit the contents of the ^ROUTINE
global using the System Management Portal. Select [Home] > [Globals], then
select the current namespace from the list of namespaces in the left-hand
column.
If you omit routine, Caché loads new lines of code that you enter from the
current device, usually the keyboard until you terminate the code by entering a
null line (that is, just press <Return>). This routine has no name until you
save it with a subsequent ZSAVE command.
ZLOAD and Language Modes
When a routine is loaded, the current language mode changes to the loaded
routine’s language mode. At the conclusion of called routines, the language
mode is restored to the language mode of the calling routine. However, at the
conclusion of a routine loaded with ZLOAD the language mode is not restored to
the previous language mode. For further details on checking and setting
language modes, refer to the $ZUTIL(55) function.
See Also

  • OPEN command
  • USE command
  • XECUTE command
  • ZSAVE command
  • $XECUTE function
  • $ZNAME special variable


 #}}}
*ZNSPACE*  #{{{

Sets the current namespace.
Synopsis

ZNSPACE:pc nspace
ZN:pc nspace

Arguments

pc      Optional  A postconditional expression.

nspace  A string expression that evaluates to the name of an existing
        namespace.

Description
ZNSPACE nspace changes the current namespace to the nspace value. If nspace
does not exist, Caché generates a <NAMESPACE> error.
nspace can be an explicit namespace or an implied namespace.
Caché maintains the name of the current namespace in the $ZNSPACE special
variable.
You can change the current namespace by using the ZNSPACE command, the 
$ZUTIL(5) function, the %CD utility (DO ^%CD), or by setting the $ZNSPACE
special variable. Use of ZNSPACE or %CD is preferable, because these provide
more extensive error checking.
You can determine the current namespace from the $ZNSPACE special variable or
the $ZUTIL(5) function. You can determine whether an explicit namespace is
defined on your system using the $ZUTIL(90,10) function.
On UNIX and OpenVMS systems, you can set the system-wide default namespace
using the $ZUTIL(90,4) function. Calling this function has no effect on Windows
systems. For Windows systems, the system-wide default namespace can be set
using a command-line startup option.
For information on creating and modifying namespaces, and mapping databases,
routines, and globals to a namespace, see Configuring Namespaces in 
Caché System Administration Guide.
Arguments
pc
Optional  An optional postconditional expression. Caché executes the command if
the postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
nspace
Any valid string expression that evaluates to the name of the new namespace. 
nspace can be an explicit namespace or an implied namespace. In either case, it
must be specified as a quoted string.
Namespace names are not case-sensitive. Caché always displays explicit
namespace names in all uppercase letters, and implied namespace names in all
lowercase letters.
An implied namespace specifies the namespace by system name and directory.
There are two forms:

  • "^^dir" (if the namespace directory is on the current system)
  • "^system^dir" (if the namespace directory is on a remote system)

For dir, specify a directory path or an OpenVMS file specification. This is
shown in the following Windows example:

  ZNSPACE "^^c:\InterSystems\Cache\Mgr\CacheTemp"
  WRITE $ZNSPACE

Examples
The following example assumes that a namespace called "accounting" already
exists. Otherwise, you receive a <NAMESPACE> error.
From the programmer prompt:

USER>ZNSPACE "Accounting"
ACCOUNTING>

By default, as shown in this example, the Caché Terminal prompt displays the
current namespace name. Namespace names are always displayed in uppercase
letters.
The following example tests for the existence of a namespace, then sets the
current namespace and the Caché Terminal prompt either to the specified
namespace or to USER:

   WRITE !,"Current namespace is ",$ZNSPACE
   SET ns="accounting"
   IF 1=$ZUTIL(90,10,ns) {
     WRITE !,"Changing namespace to: ",ns
     ZNSPACE ns
     XECUTE "SET x=$ZUTIL(68,26,1)"
     WRITE !,"and ",$ZNSPACE," will display at the prompt"
     }
   ELSE {
     WRITE !,"Namespace ",ns," does not exist"
     SET ns="user"
     WRITE !,"Changing namespace to: ",ns
     ZNSPACE ns
     XECUTE "SET x=$ZUTIL(68,26,1)"
     WRITE !,"and ",$ZNSPACE," will display at the prompt"
     }
Notes
Namespaces with Default Directories
If the namespace you select has a default directory on a remote machine, 
ZNSPACE does not change the current directory of your process to that
namespace’s directory. Thus, your current namespace becomes the namespace you
selected, but your current directory remains the directory that was current
before you issued the ZNSPACE command.
Controlling Namespace Display
Terminal Prompt
By default, the Caché Terminal prompt displays the current namespace name. This
default is configurable:
Go to the System Management Portal, select [Home] > [Configuration] >
[Compatibility Settings]. View and edit the current setting of NamespacePrompt.
This also sets the prompt for Telnet windows. You can override this default for
the current process by using $ZUTIL(68,26), or system-wide by using 
$ZUTIL(69,26).
$NAME and $QUERY Functions
The $NAME and $QUERY functions can return the extended global reference form of
a global variable, which includes the namespace name. You can control whether
these functions return namespace names as part of the global variable name. 
$ZUTIL(68,7) sets this extended global reference switch for the current
process; $ZUTIL(69,7) sets this extended global reference switch system-wide.
For further information on extended global references, see Global Structure in 
Using Caché Globals.
ZNSPACE and $ZUTIL(5)
Both ZNSPACE and $ZUTIL(5) can be used to change the current namespace to an
implied namespace, with USER as the default database. However, their mapping of
this implied namespace differs. This difference affects the user’s ability to
locate and run % routines such as %SS, %GD, and %RI, and to access some %
globals, such as those whose names begin with %q.

  • ZNSPACE creates additional default mappings from the implied namespace.
    These mappings are the same as for a normal (explicit) namespace. They
    allow a process to find and execute the % routines and % globals that are
    physically located in the CACHELIB database.
  • $ZUTIL(5) does not create additional default mappings from the implied
    namespace. A process cannot find and execute % routines and % globals that
    are physically located in the CACHELIB database. Attempting to access these
    % routines results in a <NOROUTINE> error. Attempting to access these %q
    globals results in an <UNDEFINED> error.

Setting the $ZNSPACE special variable or running the %CD routine with an
implied namespace is the same as issuing a ZNSPACE command.
ZNSPACE and $ZUTIL(39)
When a process switches namespaces using the ZNSPACE command, $ZUTIL(39)
information is normally reset. The only exception to this is when the process
switches from an implied namespace to an implied namespace, in which case 
$ZUTIL(39) settings are preserved. For further information on implied
namespaces, see Global Structure in Using Caché Globals.
Changing Namespaces within Application Code
Object and SQL code assumes that it is running in a single namespace; hence,
changing namespaces with open object instances or SQL cursors can lead to code
running incorrectly. Typically, there is no need to explicitly change
namespaces, as the various Object, SQL, and CSP servers automatically ensure
that application code is run in the correct namespace.
Also, changing namespaces demands a relatively high amount of computing power
compared to other commands; if possible, application code should avoid it.
See Also

  • JOB command
  • $ZUTIL(5) Display or Switch Namespace function
  • $ZUTIL(39) Specify Search Path function
  • $ZUTIL(90,4) Start Up in a Specified Namespace function
  • $ZUTIL(90,10) Test Whether a Namespace is Defined function
  • $ZNSPACE special variable
  • Configuring Namespaces in Caché System Administration Guide


 #}}}
*ZPRINT*  #{{{

Displays lines of code from the current routine on the current device.
Synopsis

ZPRINT:pc lineref1:lineref2
ZP:pc lineref1:lineref2

Arguments

pc         Optional  A postconditional expression.

           Optional  The line to be displayed, or the first line in a range of
lineref1   lines to be displayed. Can be a label name, a numeric offset (+n) or
           a label name and a numeric offset.

:lineref2  Optional  The last line in a range of lines to be displayed. To
           define a range, lineref1 must be specified.

Description
The ZPRINT command displays lines of code from the currently loaded routine.
The output is sent to the current device. You establish the current device with
the USE command. Caché maintains the current device ID in the $IO special
variable.
ZPRINT has two forms:

  • Without arguments
  • With arguments

ZPRINT without arguments displays all the lines of code in the currently loaded
routine.
ZPRINT with arguments displays the specified lines of code. ZPRINT lineref1
displays the line specified by lineref1. ZPRINT lineref1:lineref2 displays the
range of lines starting with lineref1 and ending with lineref2.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
lineref1
The line to be printed or the first in a range of lines to be displayed or
printed. Can be specified in either of the following forms: +offset where 
offset is a positive integer specifying the line number within the current
routine. label[+offset] where label is a label within the routine and offset is
the line number within the label. If you omit the offset option, Caché prints
the first code line and the label. Note that with this form, offset actually
evaluates to offset+1. For example, label+1 prints the second line within the
label.
lineref2
The last line in a range of lines to be displayed or printed. Specify in the
same way as lineref1. The preceding colon is required.
Notes
ZPRINT Equivalent to PRINT
The ZPRINT command is the exact equivalent of the PRINT command.
See Also

  • PRINT command
  • ZINSERT command
  • ZLOAD command
  • ZREMOVE command
  • ZSAVE command
  • $IO special variable
  • The Spool Device in Caché I/O Device Guide


 #}}}
*ZQUIT (legacy command)*  #{{{

Exits a program with error handling.
Synopsis

ZQ:pc expression

where

pc          Optional  A postconditional expression.

expression  Optional  An expression that evaluates to an integer greater than
            0.

Caché platforms recognize only the ZQ abbreviation for ZQUIT.
Description
Note:
This page describes the legacy ZQUIT command. The ZQUIT command is considered
legacy as of Caché 5.1, and should not be used in new programming. It is
described here solely for compatibility with legacy applications. New
programming should use the ZTRAP command with the $ZERROR argument to pass
control between error handlers. A ZQUIT command in new procedure code will
result in a <COMMAND> error. Refer to the ZTRAP command for further details.
The ZQUIT command exits a coded routine and provides explicit control for error
handling.
Each time a DO, FOR, or XECUTE command is executed, or a user-defined function
is invoked, Caché places return information on the program stack (sometimes
called the "call stack"). ZQUIT provides a mechanism whereby a nested
error-handling routine can pass control to a higher level error handler. ZQUIT
re-signals the error condition and causes Caché to unwind the program (call)
stack.
ZQUIT is similar to the QUIT command, but it provides explicit control for
error handling. Unlike the QUIT command, ZQUIT can be used only in a coded
routine. Caché ignores ZQUIT when entered from the programmer prompt.
ZQUIT has two forms:

  • Without an argument.
  • With an argument.

ZQUIT Without an Argument
Argumentless ZQUIT clears the entire stack.
ZQUIT With an Argument
ZQ expression unwinds the stack to another call stack level with a $ZTRAP error
handler. The value of expression specifies the number of handler-specified
stack levels ZQUIT unwinds. If you use 1 as expression, Caché unwinds the stack
to the first encountered $ZTRAP handler. If you use 2 as expression, Caché
unwinds the stack to the second encountered $ZTRAP handler, and so on.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
expression
Any valid Caché ObjectScript expression that evaluates to an integer greater
than 0. Caché platforms use the settings of $ZTRAP to clear the program stack
back to the setting indicated by the resulting integer.
Examples
The following is an example of a magnetic-tape read routine that reads a record
into x, returns a tapemark flag (tm) TRUE (1) if it reads a tape mark (an
"expected" error), and lets its caller’s errortrap routine, if any, handle any
other errors:

Mtread
  SET $ZTRAP="Mterr"
  USE 47
  READ x
  SET tm=0
  QUIT ; Normal return
Mterr
  IF $ZERROR?1"<MAGTAPE>" ; Pattern matching: repcount stringliteral
  { } ; Automatic branch to error-trap handler
  ELSE { SET tm=123 }
  IF tm=1 { QUIT }
  ELSE {ZQ 1 }
  IF $ZTRAP'="" {GOTO @$ZTRAP} ; To caller's error routine
  ELSE
  { ; No caller's error routine
   USE 0
   WRITE !,$ZERROR ZQ
   QUIT
  }

Notes
Behavior of Argumentless ZQUIT
When specified with no arguments, ZQUIT unwinds the entire stack. Execution
continues at the main program level; that is, the level at which the job began,
in either programmer mode or application mode.
ZQUIT does not change the flow of control. Execution continues with the Caché
ObjectScript command that follows ZQUIT. To mimic the errortrap behavior of M/
11, an error processing routine should end with the commands

   ZQ  QUIT

Note that there are two spaces after ZQ.
Here the QUIT command returns to programmer mode if the job began in programmer
mode or it exits if the job began in application mode. To log application
errors, end your errortrap code with:

   ZQ  GOTO ^%ET

Again, note the two spaces after ZQ.
Behavior of ZQUIT with an Argument
When specified with an argument, ZQUIT does not clear the entire stack, but
instead clears it back one or more levels to the level at which a $ZTRAP
special variable was set. The number of levels is specified by the expression
argument, which must evaluate to an integer greater than 0. $ZTRAP directs
error trapping to the routine to which it is set.
For example:

   ZQ 1

clears the stack back to the previous level at which $ZTRAP was set. Passing an
argument of "2" to ZQUIT clears the stack back to the second to last level at
which $ZTRAP was set, and so on.
Caché continues program execution on the execution level that contains the
errortrap routine currently set in $ZTRAP. When that errortrap routine quits,
control reverts to the same place that it would on a QUIT from the subroutine
that set $ZTRAP.
If Caché should find an error handler specified by the $ETRAP special variable
at a stack level before reaching the stack level of the specified $ZTRAP error
handler, Caché passes control to that $ETRAP error handler. If the $ETRAP error
handler cannot dismiss the error, the $ZTRAP error handler that issued the
original ZQUIT gains control again. At that point, the $ZTRAP error handler can
use a GOTO command to transfer control to the $ZTRAP handler originally
specified.
Note:
Do not use an indirect GOTO (for example, ZQ 1 GOTO @$ZT) within a procedure or
an object method with the default ProcedureBlock attribute. This results in a
compile error, because you cannot use a GOTO to exit a procedure. Existing
routines that use this construct should not be converted to procedures. Object
methods that use this construct must be excepted from the ProcedureBlock
attribute.
You can alter this error-return sequence by using ZQUIT in any of the following
ways:

  • ZQ 1 QUIT  Returns to the caller of the subroutine that set the previous
    error trap.
  • ZQ 1 GOTO @$ZT  Invokes the previous errortrap routine. (See Note above.)
  • ZQ QUIT  Either halts the application or enters programmer mode with an
    empty program stack. Note the two spaces between ZQUIT and QUIT.
  • ZQ GOTO ^routine  Clears the program stack and resumes execution at the
    specified top-level routine that is typically a function driver. Note the
    two spaces between ZQUIT and GOTO.

See Also

  • QUIT command
  • ZTRAP command
  • $ZUTIL(68,30) Sets Error-Handling Behavior for the Current Process function
  • $ZTRAP special variable
  • Error Handling in Using Caché ObjectScript


 #}}}
*ZREMOVE*  #{{{

Erases lines from the current routine.
Synopsis

ZREMOVE:pc lineref1:lineref2
ZR:pc lineref1:lineref2

Arguments

pc         Optional  A postconditional expression.

lineref1   Optional  The line or first in a range of lines to be removed.

:lineref2  Optional  The last in a range of lines to be removed.

Description
The ZREMOVE command erases routine lines from the current routine. ZREMOVE has
two forms:

  • Without an argument
  • With arguments

ZREMOVE without an argument erases the entire current routine.
ZREMOVE lineref1 as an argument erases the specified line. ZREMOVE lineref1:
lineref2 as an argument erases the range for lines starting with the first line
reference and ending with the second line reference.
You can only use the ZREMOVE command when you enter it at the programmer prompt
or when you call it using an XECUTE command. It should not be coded into the
body of a routine because its operation would effect the execution of that
routine.
Only the local copy of the routine is affected, not the routine as stored on
disk. To store the modified code, you must use the ZSAVE command to save the
routine.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
lineref1
The line to be removed, or the first in a range of lines to be removed. It can
take any of the following forms:

+offset       Specifies a line number within the routine.

              Specifies a label within the routine. ZREMOVE erases only the
label         label line itself. This includes any code that follows the label
              on that line.

label+offset  Specifies a label and the number of line to offset within the
              labeled section.

You can use lineref1 to specify the beginning of a range of lines (
lineref1:lineref2). The only requirement is that the first location appear
before the second in your routine.
If you omit lineref1, ZREMOVE deletes the entire current routine.
lineref2
The last in a range of lines to be removed. Specify in any of the same formats
used for lineref1. The colon prefix (:) is mandatory.
Examples
This command erases the fourth line within the current routine.

   ZREMOVE +4

This command erases the sixth line within the subroutine Test1.

   ZREMOVE Test1+6

This command erases lines three through ten, inclusive, within the current
routine.

   ZREMOVE +3:+10

See Also

  • XECUTE command
  • ZINSERT command
  • ZSAVE command


 #}}}
*ZSAVE*  #{{{

Saves the current routine.
Synopsis

ZSAVE:pc routine
ZS:pc routine

Arguments

pc       Optional  A postconditional expression.

routine  Optional  A new name for the routine.

Description
The ZSAVE command saves the current routine. Use ZSAVE to save any changes you
have made to the routine with ZINSERT and ZREMOVE commands. You can use the
$ZNAME special variable to determine the name of the currently loaded routine. 
ZSAVE is also used to name a routine loaded with an argumentless ZLOAD.
ZSAVE has two forms:

  • Without an argument
  • With an argument

ZSAVE without arguments saves the current routine under its current name (that
is, the name under which you previously saved it) on disk in the current
namespace.
ZSAVE routine saves the current routine to disk as the specified routine name
in the current namespace.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
routine
A new name under which to save the routine. If a routine by that name already
exists, Caché overwrites it. Note that you are not asked to confirm the
overwrite. A routine name must be unique within the first 255 characters;
routine names longer than 220 characters should be avoided. If you omit routine
, Caché saves the routine under its current name.
Example
This example saves the currently loaded routine with "Test" as its new name.

   SET x="ZSAVE Test"
   XECUTE x

Notes
Where to Use ZSAVE
The ZSAVE command works only when entered at the programmer prompt or when
coded within an XECUTE statement in a routine. It should not be coded into the
body of a routine because its operation would effect the execution of that
routine. If you code ZSAVE in a routine, but outside of an XECUTE statement,
that ZSAVE saves the current program.
ZSAVE and Routine Recompilation
If you have issued a command that modifies source code, ZSAVE recompiles and
saves the routine. If the source code for the routine is unavailable, ZSAVE
fails with a <NO SOURCE> error and does not replace the existing object code.
For example, the following commands load the %SS object code routine, attempt
to remove lines from the (nonexistent) source code, and then attempt to save to
the ^text global. This operation fails with a <NO SOURCE> error:

  ZLOAD %SS ZREMOVE +3 ZSAVE ^test

If you have not issued a command that modifies source code, ZSAVE saves the
object code in the specified routine. (Obviously, no recompile occurs.) For
example, the following commands load the %SS object code routine and then save
it to the ^text global. This operation succeeds:

  ZLOAD %SS ZSAVE ^test

ZSAVE with % Routines
You receive a <PROTECT> error if you try to ZSAVE a %routine to a remote
dataset, even if that dataset is the current dataset for the process. The
percent sign prefix is used for the names of non-modifiable routines, such as
system utilities.
Concurrent ZSAVE Operations
When using ZSAVE in a networked environment, a situation may occur in which two
different jobs might concurrently save a routine and assign it the same name.
This operation has the potential for one routine overwriting part of the other,
producing unpredictable results. When this possibility exists, acquire an
advisory lock on the routine before the ZSAVE operation. For example, 
LOCK ^ROUTINE("name"). For further details, refer to the LOCK command. When
running a job across ECP, the saved source is more vulnerable to such
concurrent saves because local buffer protection is not visible to other
clients.
See Also

  • XECUTE command
  • ZLOAD command
  • ZINSERT command
  • ZREMOVE command
  • $ZNAME special variable


 #}}}
*ZSYNC*  #{{{

Synchronizes and forces the end of networked transactions for the current job.
Synopsis

ZSYNC:pc

Arguments

pc  Optional  A postconditional expression.

Description
ZSYNC synchronizes and forces the conclusion of all network transactions for
the current job. You can also use ZSYNC in nonnetworked applications that might
later be run in a networked environment. Simply place it at the end of each
complete transaction.
ZSYNC ensures that if multiple updates to a global (SET or KILL operations) are
synchronized by LOCK operations, that READs of that global return those updates
in the correct order. It does this by synchronizing delock operations across a
network. When a delock occurs on an existing lock, any updates to a global that
have been initiated (on any system) before the delock is initiated will be
completed before the delock completes.
Note:
ZSYNC is used with Distributed Cache Protocol (DCP). ZSYNC performs no
operation on a system configured for an Enterprise Cache Protocol (ECP) data
server. ECP uses synchronous-commit transactions to perform similar
synchronization functionality. Because ECP is commonly used with Caché server
system networks and clusters, your use of ZSYNC may be limited. For further
details on ECP, see the Caché Distributed Data Management Guide.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
Notes
ZSYNC Guarantees Return of Asynchronous Errors
Depending on the operation requested, network errors are reported at different
times. Errors for synchronous operations, such as LOCK, $GET, $ORDER and $QUERY
, are reported immediately through the normal error trap on the command that
performed the error.
Errors for asynchronous operations, such as SET and KILL, may be reported
either immediately or after a delay.
Delayed errors return as a result of buffered asynchronous operations. When a
job invokes either SET or KILL, processing can continue on the client while the
operation on the server completes. In this case, a special interrupt trap may
occur sometime later in the program. The error code returned is identical to
the error that originally occurred on the server.
When you use the ZSYNC command to synchronize the activity of clients and
servers, you force the return of any asynchronous errors. That is to say, all
global errors return to the job before the ZSYNC command completes.
ZSYNC Guarantees Transaction Completion
The ZSYNC command lets applications synchronize activity on network servers.
Executing this command forces the completion of all network transactions for
this job. Do not use this command at the end of an update transaction that
completes the filing of all global nodes on all servers, because it forces any
delayed errors to be returned. In other words, all global errors are delivered
to the job before the ZSYNC command completes.
See Also

  • $ZUTIL(68,34) Process Interruptible by Asynchronous Errors function
  • $ZUTIL(69,34)  Processes Interruptible by Asynchronous Errors function
  • Using ObjectScript for Transaction Processing in Using Caché ObjectScript


 #}}}
*ZTRAP*  #{{{

Forces an error with a specified error code.
Synopsis

ZTRAP:pc ztraparg

ZTRAP:pc $ZERROR
ZTRAP:pc $ZE

Arguments

pc        Optional  A postconditional expression.

          Optional  An error code string. An error code string is specified as
ztraparg  a string literal or an expression that evaluates to a string; only
          the first four characters of the string are used.

$ZERROR   The special variable $ZERROR, which can be abbreviated $ZE.

Description
The ZTRAP command accepts both a command postconditional and argument
indirection. ZTRAP has three forms:

  • Without an argument
  • With a string argument
  • With $ZERROR

ZTRAP without an argument forces an error with the error code <ZTRAP>.
ZTRAP ztraparg forces an error with the error code <Zxxxx>, where xxxx is the
first four characters of the string specified by ztraparg. If you specify an
expression, rather than a quoted string literal, the compiler evaluates the
expression and uses the first four characters of the resulting string. When
evaluating an expression, Caché strips the plus sign and leading and trailing
zeros from numbers. All remaining characters of ztraparg are ignored.
ZTRAP $ZERROR does not force a new error. It stops execution at the current
program stack level and pops stack levels until another error handler is found.
Execution then continues in that error handler with the current error code.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
ztraparg
A string literal or an expression that evaluates to a string. Any of the
following values can be specified for ztraparg:

  • A quoted string of any length containing any characters. ZTRAP uses only
    the first four characters to generate an error code; if there are fewer
    than four characters, it uses the characters provided. Unlike system error
    codes, which are always uppercase, case is preserved. Thus:
   
      ZTRAP "FRED"  ; generates <ZFRED>
      ZTRAP "Fred"  ; generates <ZFred>
      ZTRAP "Freddy"  ; generates <ZFred>
      ZTRAP "foo"  ; generates <Zfoo>
      ZTRAP " foo"  ; generates <Z foo>
      ZTRAP "@#$%"  ; generates <Z@#$%>
      ZTRAP ""  ; generates <Z>
      ZTRAP """"  ; generates <Z">

  • An expression that evaluates to a string.
   
      ZTRAP 1234  ; generates <Z1234>
      ZTRAP 2+2  ; generates <Z4>
      ZTRAP 10/3  ; generates <Z3.33>
      ZTRAP +0.700  ; generates <Z.7>
      ZTRAP $ZPI  ; generates <Z3.14>
      ZTRAP $CHAR(64)_$CHAR(37)  ; generates <Z@%>
      ZTRAP ""  ; generates <Z>
      ZTRAP """"  ; generates <Z">

The ZTRAP command accepts argument indirection. For more information, refer to
Indirection in Using Caché ObjectScript.
Passing Control to an Error Handler with $ZERROR
When the ZTRAP argument is the special variable $ZERROR, special processing is
performed which is useful in $ZTRAP error handlers. ZTRAP $ZERROR does not
force a new error. It stops execution at the current program stack level and
pops stack levels until another error handler is found. Execution then
continues in that error handler with the current error code. This error handler
may be located in a different namespace.
This way of passing control to an error handler is preferable to use of the
legacy ZQUIT command.
Examples
This example shows how you use the ZTRAP command with an expression to produce
an error code:

   ; at this point the routine discovers an error ...
   ZTRAP "ER23"
   ...

When the routine is run and it discovers the anticipated error condition, the
output appears as follows:
<ZER23>tag+offset^routine
This example shows how the use of a postconditional affects the ZTRAP command:

   ;
   ZTRAP:y<0 "yNEG"
   ;

When the routine is run and y is negative, the output is:
<ZyNEG>tag+offset^routine
This example shows how you use argument indirection in the ZTRAP command:

   ;
   SET ERPTR="ERMSG"
   SET ERMSG="WXYZ"
   ;
   ;
   ZTRAP @ERPTR

The output is:
<ZWXYZ>tag+offset^routine
The following example shows a ZTRAP command that invokes a $ZTRAP error trap
handler defined at a previous context level.

Main
   NEW $ESTACK
   SET $ZTRAP="OnErr"
   WRITE !,"$ZTRAP set to: ",$ZTRAP
   WRITE !,"Main $ESTACK= ",$ESTACK   // 0
   WRITE !,"Main $ECODE= ",$ECODE," $ZERROR=",$ZERROR
   DO SubA
   WRITE !,"Returned from SubA"   // not executed
   WRITE !,"MainReturn $ECODE= ",$ECODE," $ZERROR=",$ZERROR
   QUIT
SubA
   WRITE !,"SubA $ESTACK= ",$ESTACK   // 1
   ZTRAP
   WRITE !,"SubA $ECODE= ",$ECODE," $ZERROR=",$ZERROR
   QUIT
OnErr
   WRITE !,"OnErr $ESTACK= ",$ESTACK   // 0
   WRITE !,"OnErr $ECODE= ",$ECODE," $ZERROR=",$ZERROR
   QUIT
See Also

  • $ZERROR special variable
  • $ZTRAP special variable
  • Error Handling in Using Caché ObjectScript


 #}}}
*ZWRITE*  #{{{

Displays variables and their values.
Synopsis

ZWRITE:pc variable
ZW:pc variable

Arguments

pc        Optional  A postconditional expression.

variable  Optional  Name of a variable to display, or a comma-separated list of
          variables to display.

Description
The ZWRITE command lists variables defined for the current process. It lists
these variables in the format name=value, one variable per line, on the current
device. The ZWRITE command has two forms:

  • Without an argument
  • With arguments

ZWRITE without an argument displays the names and values of all variables in
the local variable environment, including private variables. It does not
display process-private globals. It lists variables by name in ASCII order. It
lists subscripted variables in subscript tree order.
ZWRITE with a local variable, process-private global, or global variable name
as an argument writes the name and value of that variable and all of its
defined nodes. ZWRITE with a subscripted global or local variable name as an
argument writes only the specified node and all its descendant nodes. A private
variable cannot be specified as a ZWRITE argument.
ZWRITE displays a non-numeric string value as a quoted string. ZWRITE displays
a numeric value as an unquoted canonical number. A numeric string in canonical
form is displayed as an unquoted canonical number. A numeric string not in
canonical form is displayed as a quoted string.
Arguments
pc
An optional postconditional expression. Caché executes the command if the
postconditional expression is true (evaluates to a nonzero numeric value).
Caché does not execute the command if the postconditional expression is false
(evaluates to zero). For further details, refer to Command Postconditional
Expressions in Using Caché ObjectScript.
variable
Name of a variable to display, or a comma-separated list of the names of
variables to display. The variable can be a local variable, a process-private
global, or a global variable. It cannot be a private variable. Variables can be
subscripted. You can use extended global reference to specify a global variable
not mapped to the current namespace. ZWRITE displays extended global references
even when $ZUTIL(68,7) or $ZUTIL(69,7) has been set to strip extended global
references. For further information on subscripted variables and extended
global reference, refer to Global Structure in Using Caché Globals.
Examples
ZWRITE Without an Argument
In following example, ZWRITE without an argument lists all defined local
variables in ASCII name order.

   SET A="A",a="a",AA="AA",aA="aA",aa="aa",B="B",b="b"
   ZWRITE

returns:

A="A"
AA="AA"
B="B"
a="a"
aA="aA"
aa="aa"
b="b"

In the following example ZWRITE without an argument lists canonical and
non-canonical numeric values:

   SET w=10
   SET x=++0012.00
   SET y="6.5"
   SET z="007"
   SET a=w+x+y+z
   ZWRITE

returns:

a=35.5
w=10
x=12
y=6.5
z="007"

ZWRITE with Arguments
The following example shows ZWRITE displaying two of the variables that were
set in the previous example:

   SET x=100
   SET y=80
   SET d=x+y
   ZWRITE d,y
returns:

d=180
y=80

Note that a line break is automatically inserted after each variable.
The following example compares ZWRITE and WRITE when displaying different
variable values:

   SET a=+007.00
   SET b=9E3
   SET c="+007.00"
   SET d=""
   SET e="Rhode Island"
   SET f="Rhode"_"Island"
   ZWRITE a,b,c,d,e,f
   WRITE !,a,!,b,!,c,!,d,!,e,!,f
ZWRITE Displaying a Global in the Current Namespace
The following example shows ZWRITE displaying the contents of a subscripted
global variable (located in the current namespace):

   ZNSPACE "SAMPLES"
   ZWRITE ^CinemaooFilmD(17)
returns:

^CinemaooFilmD(17)=".A complex history of struggle and redemption
Cooking with Jane Austen 5  u R"

ZWRITE Displaying a Global in Another Namespace
The following example shows ZWRITE using extended global reference to display
the contents of a subscripted global variable located in another namespace
called SAMPLES:

   ZNSPACE "USER"
   ZWRITE ^["SAMPLES"]CinemaooFilmD(17)
ZWRITE always displays the extended global reference, regardless of the setting
of $ZUTIL(69,7) or $ZUTIL(68,7) which can be set to strip extended global
references from globals returned by $QUERY or $NAME.
ZWRITE Displaying a Global and Descendants
The following example shows ZWRITE displaying the contents of a subscripted
global variable and all its descendent nodes. Note that the descendent nodes
contain list structures, which are displayed as $LISTBUILD ($lb) constructions:

   ZNSPACE "SAMPLES"
   ZWRITE ^CinemaooFilmCategoryD
returns:

^CinemaooFilmCategoryD=5
^CinemaooFilmCategoryD(1)=$lb("Drama","")
^CinemaooFilmCategoryD(2)=$lb("Animation","")
^CinemaooFilmCategoryD(3)=$lb("Thriller","")
^CinemaooFilmCategoryD(4)=$lb("Action","")
^CinemaooFilmCategoryD(5)=$lb("Comedy","")

Additional non-printing characters used in lists are also displayed.
See Also

  • WRITE command
  • ZZDUMP command


 #}}}
*ZZDUMP*  #{{{

Displays an expression in hexadecimal dump format.
Synopsis

ZZDUMP:pc expression,...

Arguments

pc          Optional  A postconditional expression.

            The data to be displayed in hexadecimal dump format. You can
            specify a number, a string (enclosed in quotation marks), a list
expression  (created with $LISTBUILD), or a variable that resolves to one of
            these. You can specify a single expression, or a comma-separated
            list of expressions.

Description
ZZDUMP displays an expression in hexadecimal dump format. ZZDUMP is primarily
of interest to system programmers, but it can be useful in viewing strings that
contain control characters.
ZZDUMP returns lines in one of the following formats:
For a number or string value:

position: hexdata printdata

For a list value:

position: length datatype hexdata printdata

These format elements are described in the following table:

Returned
  Line                                 Description
 Element

           The zero-based relative position of the initial character of the
position   displayed line of the dump (in hexadecimal), followed by a colon.
           This value is always 0000 for the first line of a dump, and then
           increments for subsequent lines.

           Optional  In a list created with $LISTBUILD, the length, in bytes,
length     of the list item, specified in hexadecimal. A list item containing a
           one-character string has a length of 03 because ZZDUMP counts the 
           length byte, the datatype byte, and the actual data byte.

           Optional  In a list created with $LISTBUILD, the data type of the
           stored list item, specified as a two-digit hexadecimal code.
           00 = Marker (no hexdata value)
           01 = Binary string (8 bits per character)
datatype   02 = Unicode string (16 bits per character)
           04 = Positive integer
           05 = Negative integer
           06 = Positive decimal floating-point number
           07 = Negative decimal floating-point number
           08 = $DOUBLE binary floating-point number (positive or negative)

           The data values for each character, represented in hexadecimal. If
hexdata    ASCII, these data values are represented by 2 hexadecimal digits per
           character. If Unicode, these data values are represented by 4
           hexadecimal digits per character.

           The printable character version of the data. If a character is not
           printable, it is represented by a dot. In a list created with 
printdata  $LISTBUILD, the printable data characters are preceded by dots
           representing the length byte (see Notes below) and the datatype
           byte.

You can use the $ZHEX function to convert hexadecimal to decimal and vice
versa.
Arguments
pc
Caché executes the ZZDUMP command if the postconditional expression is true
(evaluates to a nonzero numeric value). Caché does not execute the command if
the postconditional expression is false (evaluates to zero). For further
details, refer to Command Postconditional Expressions in 
Using Caché ObjectScript.
expression
You can specify expression as a numeric, a string literal, a list, or a
variable that resolves to one of these. You can specify a single expression, or
a comma-separated list of expressions. Specifying a comma-separated list of
expressions is parsed as issuing a separate ZZDUMP command for each expression.
Examples
The following example shows ZZDUMP returning hex dumps for two single-character
string variables. Note that each comma-separated expression is treated as a
separate invocation of ZZDUMP:

   SET x="A"
   SET y="B"
   ZZDUMP x,y

0000: 41                                                A
0000: 42                                                B

The following example shows ZZDUMP returning a hex dump for a string variable
too long for a single dump line. Note that the position for the second dump
line (0010:) is in hexadecimal:

   SET z="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   ZZDUMP z

0000: 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50     ABCDEFGHIJKLMNOP
0010: 51 52 53 54 55 56 57 58 59 5A                       QRSTUVWXYZ

The following example shows ZZDUMP returning hex dumps for three variables.
Note that no hex dump (not even a blank line) is returned for a null string
variable. Also note that a number is converted to canonical form (leading and
trailing zeros and plus sign removed); a string containing a number is not
converted to canonical form:

   SET x=+007
   SET y=""
   SET z="+007"
   ZZDUMP x,y,z

0000: 37                                         7
0000: 2B 30 30 37                                +007

Examples of List Elements
The following examples show ZZDUMP returning hex dumps for lists created using 
$LISTBUILD.
The following example shows two lists, the first with a single item, the second
with three items. Note that each list item has its own length and datatype, and
that these two bytes are represented both in the length count and as dots
(nonprinting characters) in the printdata on the right side of each line. The 
datatype code for a string is 01.

   SET x=$LISTBUILD("ABC")
   SET y=$LISTBUILD("A","B","C")
   ZZDUMP x,y

0000: 05 01 41 42 43                                 ..ABC
0000: 03 01 41 03 01 42 03 01 43                     ..A..B..C

The following example shows a list element that do not contain a value. Note
how an undefined list differs from the null string list. An undefined list has
a length of 01 (the length byte itself) and no datatype or value. A null string
list has a length of 02 (the length byte and the datatype byte) and has a 
datatype of 01 (string).

   ZZDUMP $LISTBUILD()     // 01     .
   ZZDUMP $LISTBUILD("")   // 02 01  ..
The following example shows two lists that contain different forms of the
number 65. In the first case, ZZDUMP treats  65 as a two-character string and
returns the hexadecimal value for each character. In the second case, ZZDUMP
treats 65 as a decimal number and returns the equivalent hexadecimal number
(41) and the corresponding ASCII character ( A ) , in the printdata on the
right side of the dump line.

   ZZDUMP $LISTBUILD("65")    // 04 01 36 35  ..65
   ZZDUMP $LISTBUILD(65)      // 03 04 41     ..A
The following example shows lists with different datatype values. The comments
for each line show the length and datatype values returned:

   ZZDUMP $LISTBUILD("A")            // 03 01
   ZZDUMP $LISTBUILD($CHAR(960))     // 04 02
   ZZDUMP $LISTBUILD(7)              // 03 04
   ZZDUMP $LISTBUILD(-7)             // 03 05
   ZZDUMP $LISTBUILD($ZPI)           // 0B 06
   ZZDUMP $LISTBUILD(-$ZPI)          // 0B 07
   ZZDUMP $LISTBUILD($DOUBLE($ZPI))  // 0A 08
   ZZDUMP $LISTBUILD($DOUBLE(-$ZPI)) // 0A 08
   ZZDUMP $LISTBUILD(-$DOUBLE($ZPI)) // 0A 08
Notes
The Length Byte and Long List Elements
In the relatively small list items in the above examples, the length byte has
always appeared in the printdata as a dot (a nonprinting character). In fact,
the character displayed in printdata for the length byte depends on the
hexadecimal value of the length byte. Therefore, strings longer than 29
characters (length=31) display the length byte as a printable character in 
printdata.
When a list item exceeds 253 characters, length can no longer be specified
using a single-byte length indicator. In these cases, length is represented by
a three-byte field. Unlike the single-byte length, the three-byte length field
is not included in the total length.
Unicode
If one or more characters in a ZZDUMP expression is a wide (Unicode) character,
all characters in that expression are represented as wide characters. The
following examples show three variables containing a Unicode character. In all
three cases, all characters are displayed as wide characters. Note however,
that $LISTBUILD imposes its own formatting on the representation of wide
characters, always using little-endian order regardless of the hardware
platform. For further details, refer to the $LISTBUILD function.

   SET x=$CHAR(987)
   SET y=$CHAR(987)_"ABC"
   SET z=$LISTBUILD($CHAR(987)_"ABC")
   ZZDUMP x,y,z

0000: 03DB                                                    ?
0000: 03DB 0041 0042 0043                                     ?ABC
0000: 0A 02 DB 03 41 00 42 00 43 00                           ..Û.A.B.C.

See Also

  • $CHAR function
  • $DOUBLE function
  • $LISTBUILD function
  • $ZHEX function


 #}}}

==============================================================================
  vim:tw=78:fo=tcq2:ts=8:ft=help:norl:fdm=marker:fmr={{{,}}}:cms=\ #%s  

